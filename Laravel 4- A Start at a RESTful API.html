<h1>Laravel 4: Começando com API RESTful</h1>

<p>APIs RESTful são difíceis! Há muitos aspectos quando se quer planejar e criar uma que seja bem sucedida. Por exemplo, alguns dos tópicos que você acabará lidando, incluem auntenticação, hipermídia/HATEOS, versionamento, limitação de uso e negociação de conteúdo. Ao invés de lidar com todos esses conceitos de uma vez, vamos focar nos conceitos básicos do REST. Criaremos alguns pontos de acesso JSON protegidos por um sistema básico de autenticação, e aprenderemos alguns truques do Laravel 4 no caminho.</p>

<h2>A Aplicação</h2>

<p>Criaremos uma API para uma simples app de administração e leitura de artigos da internet. Os usuários serão capazes de criar, ler, atualizar e apagar URLs (links) que eles salvaram para ler depois. Pronto para começar?</p>

<h3>Instale o Laravel 4</h3>

<p>Crie uma nova <a href="http://four.laravel.com/#install-laravel" title="install laravel">instalação do Laravel 4</a>. Se você sabe usar a linha de comando, use esse <a href="http://fideloper.com/laravel-4-uber-quick-start-with-auth-guide?utm_source=nettuts&amp;utm_medium=article&amp;utm_content=api&amp;utm_campaign=guest_author" title="laravel quick start">guia básico</a>. Se não, nós temos um <a href="http://net.tutsplus.com/tutorials/php/how-to-setup-laravel-4/" title="install laravel video">tutorial em vídeo, aqui no Nettuts+</a> que cobre todo o processo.</p>

<p>Nós, primeiro, criaremos uma chave de criptografia para segurar as senhas. Você pode fazer isso, facilmente, executando o comando a seguir, na linha de comando, tendo como diretório base o diretório raiz do seu projeto:</p>

<pre class="brush: bash">$ php artisan key:generate</pre>

<p>Alternativamente, você pode editar, diretamente, o arquivo <code>app/config/app.php</code> e inserir sua chave de criptografia:</p>

<pre class="brush: php">/*
|--------------------------------------------------------------------------
| Encryption Key
|--------------------------------------------------------------------------
|
| This key is used by the Illuminate encrypter service and should be set
| to a random, long string, otherwise these encrypted values will not
| be safe. Make sure to change it before deploying any application!
|
*/

'key' =&gt; md5('altere esse texto para o que será sua chave de criptografia'),</pre>

<p>Usando a função <code>md5()</code>, ao invés de uma cadeia de caracteres fixa, criará sua chave de criptografia. O método da linha de comando é mais aconselhável</p>

<h3>Base de Dados</h3>

<p>Assim que você tiver com uma cópia do Laravel 4 funcionando, poderemos começar a nos divertir de verdade. Começaremos criando a base de dados da app.</p>

<p>Ela só vai precisar de duas tabelas:</p>

<ol>
<li><strong>Users</strong>, com os campos username e password</li>
<li><strong>URLs</strong>, com os campos url e description</li>
</ol>

<p>Nós usaremos as <a href="http://four.laravel.com/docs/migrations" title="create Laravel migrations">migrações</a> (do inglês, <em>migrations</em>) do Laravel para criar e popular a base de dados.</p>

<h3>Configure sua Base de Dados</h3>

<p>Edite o arquivo <code>app/config/database.php</code> preenchendo com as configurações da sua base de dados. Nota: é importante criar uma base de dados para ser usada com essa aplicação. Nesse artigo, assumiremos que você usará uma base de dados MySQL.</p>

<pre class="brush: php">'connections' =&gt; array(

  'mysql' =&gt; array(
      'driver'    =&gt; 'mysql',
      'host'      =&gt; 'localhost',
      'database'  =&gt; 'nome_da_base_de_dados',
      'username'  =&gt; 'usuario_do_mysql',
      'password'  =&gt; 'senha_do_mysql',
      'charset'   =&gt; 'utf8',
      'collation' =&gt; 'utf8_unicode_ci',
      'prefix'    =&gt; '',
  ),
),</pre>

<h3>Criando os Arquivos de Migração</h3>

<pre class="brush: bash">$ php artisan migrate:make create_users_table --table=users --create
$ php artisan migrate:make create_urls_table --table=urls --create</pre>

<p>Esses comandos criarão os arquivos necessários que usaremos para gerar nossas tabelas no banco de dados. Nosso trabalho, agora, é preenchê-los com as colunas corretas das tabelas.</p>

<p>Edite o arquivo <code>app/database/migrations/SOME_DATE_create_users_table.php</code> e adicione o método <code>up()</code>:</p>

<pre class="brush: php">public function up()
{
  Schema::create('users', function(Blueprint $table)
  {
      $table-&gt;increments('id');
      $table-&gt;string('username')-&gt;unique();
      $table-&gt;string('password');
      $table-&gt;timestamps();
  });
}</pre>

<p>No código acima, estamos criando os campos username (que deve ser único), password, bem como os campos <em>timestamps</em> (campos de criação e alteração do registro da tabela). Salve o arquivo e, então, edite o <code>app/database/migrations/SOME_DATE_create_urls_table.php</code> (<em>SOME_DATE</em> está no formato YYYY_MM_DD_HMS), e adicione o método <code>up()</code>, como o abaixo:</p>

<pre class="brush: php">public function up()
{
  Schema::create('urls', function(Blueprint $table)
  {
      $table-&gt;increments('id');
      $table-&gt;integer('user_id');
      $table-&gt;string('url');
      $table-&gt;string('description');
      $table-&gt;timestamps();
  });
}</pre>

<p>O único ponto importante nesse trecho de código é que estamos criando um elo entre a tabela <code>url</code> e <code>users</code>, através do campo <code>user_id</code>.</p>

<h3>Adicionando Usuários de Exemplo</h3>

<p>Nós podemos usar os <a href="http://four.laravel.com/docs/migrations#database-seeding" title="laravel seed database">semeadores</a> (do inglês, <em>seeder</em>) do Laravel para criar alguns usuários para usarmos de exemplo.</p>

<p>Crie um arquivo dentro da pasta <code>app/database/seeds</code> com o mesmo nome da tabela que ele preencherá; no nosso caso, <code>UserTableSeeder.php</code>. Digite:</p>

<pre class="brush: php">&lt;?php

class UserTableSeeder extends Seeder {

  public function run()
  {
      DB::table('users')-&gt;delete();

      User::create(array(
          'username' =&gt; 'firstuser',
          'password' =&gt; Hash::make('first_password')
      ));

      User::create(array(
          'username' =&gt; 'seconduser',
          'password' =&gt; Hash::make('second_password')
      ));
  }

}</pre>

<p>Depois disso, garanta que a classe semeadora seja executada quando a base de dados tiver de ser semeada. Edite o arquivo <code>app/database/seeds/DatabaseSeeder.php</code>:</p>

<pre class="brush: php">public function run()
{
  Eloquent::unguard();

  // Adicione ou remova o comentário da linha abaixo
  $this-&gt;call('UserTableSeeder');
}</pre>

<h3>Execute as Migrações</h3>

<p>São os comandos a seguir que permitirão os códigos acima criar as duas tabelas e inserir os usuários de exemplo.</p>

<pre class="brush: php">// Cria as duas tabelas
$ php artisan migrate

// Cria os usuários exemplo
$ php artisan db:seed</pre>

<h2>Modelos</h2>

<p>O Laravel 4 continua a usar o excelente ORM Eloquent. Por conta disso, lidar com as chamadas à base de dados será moleza. Nós utilizaremos um modelo por tabela.</p>

<p>Por sorte, o Laravel vem com um modelo User já pronto. A nós, somente resta a criação do modelo para nossa tabela urls.</p>

<p>Crie e edite o arquivo <code>app/models/Url.php</code>.</p>

<pre class="brush: php">&lt;?php

class Url extends Eloquent {

  protected $table = 'urls';

}</pre>

<h2>Autenticação</h2>

<p>Os <a href="http://four.laravel.com/docs/routing#route-filters" title="laravel filters">filtros</a> são os responsáveis por lidar com a autenticação para nós. Peculiarmente, agora, o Laravel vem com um filtro de Autenticação Básica (via HTTP), o qual podemos utilizar como um simples modelo de autenticação para as requisições à nossa API.</p>

<p>Se você abrir o arquivo <code>app/filters.php</code>, você verá como ele é:</p>

<pre class="brush: php">Route::filter('auth.basic', function()
{
  return Auth::basic();
});</pre>

<p>Nós só precisamos fazer um ajuste. Por padrão, o filtro busca pelo campo "email" da tabela para identificar o usuário. Como estamos lidando com o campo "username" (nomes de usuários), devemos indicar ao filtro que ele deve usar esse campo. Mude a chamada ao método estático <code>Auth::basic()</code> para que ele receba o campo "username" como parâmetro:</p>

<pre class="brush: php">Route::filter('auth.basic', function()
{
  return Auth::basic("username");
});</pre>

<h3>Rotas</h3>

<p>Vamos testar a aplicação. Crie uma rota chamada <code>testauth</code>, e faça com que o filtro <code>auth.basic</code> seja executado logo antes dela.</p>

<p>Edite o arquivo <code>app/routes.php</code>:</p>

<pre class="brush: php">Route::get('/authtest', array('before' =&gt; 'auth.basic', function()
{
  return View::make('hello');
}));</pre>

<p>Podemos verificar se está funcionando, ao fazer uma requisição curl. Da sua linha de comando, faça uma requisição para o endereço local da sua aplicação Laravel. No meu caso, se parece com isso (Sua URL, provavelmente, será diferente!):</p>

<pre class="brush: php">$ curl -i localhost/l4api/public/index.php/authtest
HTTP/1.1 401 Unauthorized
Date: Tue, 21 May 2013 18:47:59 GMT
WWW-Authenticate: Basic
Vary: Accept-Encoding
Content-Type: text/html; charset=UTF-8

Invalid credentials</pre>

<p>Como você pode ver, uma requisição não autorizada (HTTP/1.1 401 Unauthorized) foi detectada e a mensagem "Invalid Credentials" (em português, Credenciais Inválidas) foi retornada com um código de estado 401. Agora, tente a mesma requisição passando o nome de usuário e senha (<em>username</em> e <em>password</em>).</p>

<pre class="brush: php">$ curl --user firstuser:first_password localhost/l4api/public/index.php/authtest
HTTP/1.1 200 OK
Date: Tue, 21 May 2013 18:50:51 GMT
Vary: Accept-Encoding
Content-Type: text/html; charset=UTF-8

&lt;h1&gt;Hello World!&lt;/h1&gt;</pre>

<p>Funcionou!</p>

<p>Até agora, a base de nossa API está pronta. Nós já temos:</p>

<ul>
<li>Instalação do Laravel 4</li>
<li>Base de Dados criada</li>
<li>Modelos criados</li>
<li>Modelo de Autenticação criado</li>
</ul>

<h2>Criando Requisições Funcionais</h2>

<p>Você já deve conhecer os <a href="http://four.laravel.com/docs/controllers#restful-controllers" title="laravel restful controller">controladores RESTful</a> do Laravel. Eles ainda existem no Laravel 4; contudo, nós também podemos usar os <a href="http://four.laravel.com/docs/controllers#resource-controllers" title="laravel resourceful controller">controladores inteligentes</a> (Resourceful Controllers) do Laravel, que cria um paradigma que podemos usar para criar uma API consistente. Nós usaremos esses controladores inteligentes.</p>
<blockquote>
<p><a href="http://four.laravel.com/docs/controllers#resource-controllers">Eis um resumo</a> do que cada controlador inteligente é capaz de lidar. Atente que você pode desconsiderar as rotas /resource/create e /resource/{id}/edit, uma vez que não mostraremos formulários para criar ("create") ou editar ("edit") formulários em um API.</p>
</blockquote>

<h3>Criando Controladores Inteligentes</h3>

<pre class="brush: bash">$ php artisan controller:make UrlController</pre>

<p>Agora, crie uma rota para usar o controlador e faça com que todas as rotas precisem de autenticação.</p>

<p>Edite o arquivo <code>app/routes.php</code> e adicione:</p>

<pre class="brush: php">// Agrupamento de rota para garantir versionamento da API
Route::group(array('prefix' =&gt; 'api/v1', 'before' =&gt; 'auth.basic'), function()
{
  Route::resource('url', 'UrlController');
});</pre>

<p>Eis o que está acontecendo:</p>

<ol>
<li>Essa rota responderá a requisições feitas ao ponto de acesso <code>http://example.com/api/v1/url</code>.</li>
<li>Isso permite que adicionemos rotas extras, se precisarmos expandir nossa API. Por exemplo, você pode adicionar um ponto de acesso aos usuários, como <code>/api/v1/user</code>.<br /></li>
<li>Também há uma mecanismo de nomeação de rotas para o versionamento da API, permitindo que lancemos novas versões de nossa API sem quebrar a comaptibilidade com versões anteriores &ndash; basta criarmos um agrupamento de rotas chamado <strong>v2</strong> e apontá-lo para um novo controlador!</li>
</ol>

<p>Nota: Talvez você possa querer usar técnicas mais avançadas de versionamento de APIs, como através do uso do cabeçalho HTTP <code>Accept</code> ou através de um subdomínio, os quais podem ajudar você a ter diferentes conjuntos de código para cada uma das versões da API em questão.</p>

<h3>Adicionando Funcionalidade</h3>

<p>Edite o arquivo <code>app/controllers/UrlController.php</code> recém-criado:</p>

<pre class="brush: php">// Edite isso:
public function index()
{
  return 'Hello, API';
}</pre>

<p>Vamos testá-lo:</p>

<pre class="brush: php">$ curl -i localhost/l4api/public/index.php/api/v1/url
HTTP/1.1 401 Unauthorized
Date: Tue, 21 May 2013 19:02:59 GMT
WWW-Authenticate: Basic
Vary: Accept-Encoding
Content-Type: text/html; charset=UTF-8

Invalid credentials.

$ curl --user firstuser:first_password localhost/l4api/public/index.php/api/v1/url
HTTP/1.1 200 OK
Date: Tue, 21 May 2013 19:04:19 GMT
Vary: Accept-Encoding
Content-Type: text/html; charset=UTF-8

Hello, API</pre>

<p>Agora, temos um novo controlador inteligente com sistema de autenticação básica funcionando, pronto para adicionarmos funcionalidades.</p>

<h3>Salvando uma nova URL</h3>

<p>Edite o arquivo <code>app/controllers/UrlController.php</code>:</p>

<pre class="brush: php">/**
 * Salva um novo recurso - nova url - na base de dados
 *
 * @return Response
 */
public function store()
{
  $url = new Url;
  $url-&gt;url = Request::get('url');
  $url-&gt;description = Request::get('description');
  $url-&gt;user_id = Auth::user()-&gt;id;

  // Filtragem e validação é extremamento necessário!!
  // sério, sou um cara mal por deixá-las de fora.

  $url-&gt;save();

  return Response::json(array(
      'error' =&gt; false,
      'urls' =&gt; $urls-&gt;toArray()),
      200
  );
}</pre>

<p>É hora de testar, usando outra requisição curl. Dessa vez, enviaremos uma requisição do tipo POST, que corresponderá ao método <code>store()</code> criado logo acima.</p>

<pre class="brush: bash">$ curl -i --user firstuser:first_password -d 'url=http://google.com&amp;description=Um mecanismo de busca' localhost/l4api/public/index.php/api/v1/url
HTTP/1.1 201 Created
Date: Tue, 21 May 2013 19:10:52 GMT
Content-Type: application/json

{"error":false,"message":"URL created"}</pre>

<p>Ótimo! Vamos salvar algumas outras URL para os nossos dois usuários.</p>

<pre class="brush: bash">$ curl --user firstuser:first_password -d 'url=http://fideloper.com&amp;description=Um otimo blog' localhost/l4api/public/index.php/api/v1/url

$ curl --user seconduser:second_password -d 'url=http://digitalsurgeons.com&amp;description=Agencia de Marketing' localhost/l4api/public/index.php/api/v1/url

$ curl --user seconduser:second_password -d 'url=http://www.poppstrong.com/&amp;description=Tenho pena dele' localhost/l4api/public/index.php/api/v1/url</pre>

<p>Agora, criaremos os métodos que retornarão as URLs salvas.</p>

<pre class="brush: php">/**
 * Mostra uma lista de recursos.
 *
 * @return Response
 */
public function index()
{
  // Antes: return 'Hello, API';

  $urls = Url::where('user_id', Auth::user()-&gt;id)-&gt;get();

  return Response::json(array(
      'error' =&gt; false,
      'urls' =&gt; $urls-&gt;toArray()),
      200
  );
}

/**
 * Mostra um recurso em específico
 *
 * @param  int  $id
 * @return Response
 */
public function show($id)
{
  // Garanta que o usuário atual é dono do recurso requisitado
  $url = Url::where('user_id', Auth::user()-&gt;id)
          -&gt;where('id', $id)
          -&gt;take(1)
          -&gt;get();

  return Response::json(array(
      'error' =&gt; false,
      'urls' =&gt; $url-&gt;toArray()),
      200
  );
}</pre>

<p>Vamos testá-los:</p>

<pre class="brush: bash">$ curl --user firstuser:first_password localhost/l4api/public/index.php/api/v1/url
{
  "error": false,
  "urls": [
     {
          "created_at": "2013-02-01 02:39:10",
          "description": "Um mecanismo de busca",
          "id": "2",
          "updated_at": "2013-02-01 02:39:10",
          "url": "http://google.com",
          "user_id": "1"
      },
      {
          "created_at": "2013-02-01 02:44:34",
          "description": "Um otimo blog",
          "id": "3",
          "updated_at": "2013-02-01 02:44:34",
          "url": "http://fideloper.com",
          "user_id": "1"
      }
  ]
}

$ curl --user firstuser:first_password localhost/l4api/public/index.php/api/v1/url/1
{
  "error": false,
  "urls": [
      {
          "created_at": "2013-02-01 02:39:10",
          "description": "Um mecanismo de busca",
          "id": "2",
          "updated_at": "2013-02-01 02:39:10",
          "url": "http://google.com",
          "user_id": "1"
      }
  ]
}</pre>

<p>Quase pronto. Agora, precisamos permitir os usuários apagar uma das URLs salvas.</p>

<pre class="brush: php">/**
 * Remove o recurso requisitado da base de dados.
 *
 * @param  int  $id
 * @return Response
 */
public function destroy($id)
{
  $url = Url::where('user_id', Auth::user()-&gt;id)-&gt;find($id);

  $url-&gt;delete();

  return Response::json(array(
      'error' =&gt; false,
      'message' =&gt; 'url apagada'),
      200
      );
}</pre>

<p>Agora podemos apagar uma URL ao fazer uma requisição do tipo DELETE:</p>

<pre class="brush: bash">$ curl -i -X DELETE --user firstuser:first_password localhost/l4api/public/index.php/api/v1/url/1
HTTP/1.1 200 OK
Date: Tue, 21 May 2013 19:24:19 GMT
Content-Type: application/json

{"error":false,"message":"url apagada"}</pre>

<p>Por último, temos de permitir que os usuários atualizem as URLs.</p>

<pre class="brush: php">/**
 * Atualiza um recurso especificado na base de dados.
 *
 * @param  int  $id
 * @return Response
 */
public function update($id)
{
  $url = Url::where('user_id', Auth::user()-&gt;id)-&gt;find($id);

  if ( Request::get('url') )
  {
      $url-&gt;url = Request::get('url');
  }

  if ( Request::get('description') )
  {
      $url-&gt;description = Request::get('description');
  }

  $url-&gt;save();

  return Response::json(array(
      'error' =&gt; false,
      'message' =&gt; 'url atualizada'),
      200
  );
}</pre>

<p>Para testar se conseguimos atualizar as URL, execute:</p>

<pre class="brush: bash">$ curl -i -X PUT --user seconduser:second_password -d 'url=http://yahoo.com' localhost/l4api/public/index.php/api/v1/url/4
HTTP/1.1 200 OK
Date: Tue, 21 May 2013 19:34:21 GMT
Content-Type: application/json

{"error":false,"message":"url atualizada"}

// View our changes
$ curl --user seconduser:second_password localhost/l4api/public/index.php/api/v1/url/4
{
  "error": false,
  "urls": [
      {
          "created_at": "2013-02-01 02:44:34",
          "description": "Tenho pena dele",
          "id": "3",
          "updated_at": "2013-02-02 18:44:18",
          "url": "http://yahoo.com",
          "user_id": "1"
      }
  ]
}</pre>

<h2>Isso é tudo!</h2>

<p>Agora, temos o começo de uma API totalmente funcional. Espero que você tenha aprendido bastante sobre o funcionamento e criação de uma API com o Laravel 4.</p>

<p>Para recapitular, nós fomos capazes de realizar as seguintes tarefas, seguinda esse tutorial:</p>

<ol>
<li>Instalar o Laravel</li>
<li>Criar uma base de dados, usando migrações (<em>migrations</em>) e semeadores (<em>seeders</em>)</li>
<li>Usar modelos baseados no ORM Eloquent</li>
<li>Autenticar usuários com Autenticação HTTP básica</li>
<li>Criar rotas, incluindo versionamento da API</li>
<li>Criar as funcionalidades da API usando Controladores Inteligentes (<em>Resourceful Controllers</em>)</li>
</ol>

<h3>Os próximos passos</h3>

<p>Se você quer ter uma API profissional, talvez queira dar uma olhada nas indicações a seguir.</p>

<ol>
<li>Validação (dica: Laravel tem uma <a href="http://four.laravel.com/docs/validation">biblioteca de Validação</a>).</li>
<li>Tratamento de erros em requisições a API – É possível receber respostas HTML em requisições a APIs (Dica: <a href="http://fideloper.com/laravel4-error-handling" title="laravel error handling">Tratamento de Error no Laravel</a> e Negociação de Conteúdo)</li>
<li>Negociação de Conteúdo - ouvindo ao cabeçalho HTTP <em>Accept</em>. (Dica: <a href="http://four.laravel.com/docs/requests#request-information" title="Laravel request class">A classe Request do Laravel</a> possibilita acesso aos cabeçalhos da requisição).</li>
<li>Dê uma olhada no grupo <a href="http://groups.google.com/group/api-craft/">API Craft Google Group</a></li>
<li>Aprenda sobre os <a href="http://fideloper.com/quick-caching-explanation?utm_source=nettuts&amp;utm_medium=article&amp;utm_content=api&amp;utm_campaign=guest_author" title="http cache">diferentes tipos de <em>caching</em></a> e como o <em>caching</em> de validação pode aprimorar sua API.</li>
<li><a href="leanpub.com/laravel-testing-decoded">Realize testes unitários para sua App</a></li>
<li>Confira a <a href="http://apigee.com/about/api-best-practices">ótima seleção da Apigee sobre APIs</a></li>
</ol>