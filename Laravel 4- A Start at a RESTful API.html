<h1>Laravel 4: Começando com API RESTful</h1>

<p>APIs RESTful dão difíceis! Há muitos aspectos quando se quer planejar e criar uma que seja bem sucedida. Por exemplo, alguns dos tópicos que você acabará lidando, incluem auntenticação, hipermídia/HATEOS, versionamento, limitação de uso e negociação de conteúdo. Ao invés de lidar com todos esses conceitos de uma vez, vamos focar nos conceitos básicos do REST. Criaremos alguns pontos de acesso JSON protegidos por um sistema básico de autenticação, e aprenderemos alguns truques do Laravel 4, no caminho.</p>

<h2>A Aplicação</h2>

<p>Criaremos uma API para uma simples app de administração e leitura de artigos da internet. Os usuários serão capazes de criar, ler, atualizar e deleter URLs (links) que eles salvaram para ler depois. Pronto para começar?</p>

<h3>Instale o Laravel 4</h3>

<p>Crie uma nova<a href="http://four.laravel.com/#install-laravel" title="install laravel">instalação do Laravel 4</a>. Se você sabe usar a linha de comando, use esse <a href="http://fideloper.com/laravel-4-uber-quick-start-with-auth-guide?utm_source=nettuts&amp;utm_medium=article&amp;utm_content=api&amp;utm_campaign=guest_author" title="laravel quick start">guia básico</a>. Se não, nós temos um <a href="http://net.tutsplus.com/tutorials/php/how-to-setup-laravel-4/" title="install laravel video">tutorial em vídeo, aqui no Nettuts+</a> que cobre todo o processo.</p>

<p>Nós, primeiro, criaremos uma chave de criptografia para criptografia segura de senhas. Você pode fazer isso, facilmente, executando o comando a seguir, na linha de comando, tendo como diretório base o diretório raiz do seu projeto:</p>

<pre class="brush: bash">$ php artisan key:generate</pre>

<p>Alternativamente, você pode editar, diretamente, o arquivo <code>app/config/app.php</code> e inserir sua chave de criptografia:</p>

<pre class="brush: php">/*
|--------------------------------------------------------------------------
| Encryption Key
|--------------------------------------------------------------------------
|
| This key is used by the Illuminate encrypter service and should be set
| to a random, long string, otherwise these encrypted values will not
| be safe. Make sure to change it before deploying any application!
|
*/

'key' =&gt; md5('altere esse texto para o que será sua chave de criptografia'),</pre>

<p>Usando a função <code>md5()</code>, ao invés de uma cadeia de caracteres fixa, criará sua chave de criptografia. O método a linha de comando é mais aconselhável</p>

<h3>Base de Dados</h3>

<p>Assim que você tiver com uma cópia do Laravel 4 funcionando, poderemos começar a nos divertir de verdade. Começaremos criando a base de dados da app.</p>

<p>Ela só vai precisar de duas tabelas:</p>

<ol>
<li><strong>Users</strong>, com os campos username e password</li>
<li><strong>URLs</strong>, com os campos url e description</li>
</ol>

<p>Nós usaremos as <a href="http://four.laravel.com/docs/migrations" title="create Laravel migrations">migrações</a> (do inglês, <em>migrations</em>) do Laravel para criar e popular a base de dados.</p>

<h3>Configure sua Base de Dados</h3>

<p>Edite o arquivo <code>app/config/database.php</code> preenchendo com as configurações da sua base de dados. Nota: é importante criar uma base de dados para ser usada com essa aplicação. Nesse artigo, assumiremos que você usará uma base de dados MySQL.</p>

<pre class="brush: php">'connections' =&gt; array(

  'mysql' =&gt; array(
      'driver'    =&gt; 'mysql',
      'host'      =&gt; 'localhost',
      'database'  =&gt; 'nome_da_base_de_dados',
      'username'  =&gt; 'usuario_do_mysql',
      'password'  =&gt; 'senha_do_mysql',
      'charset'   =&gt; 'utf8',
      'collation' =&gt; 'utf8_unicode_ci',
      'prefix'    =&gt; '',
  ),
),</pre>

<h3>Criando os Arquivos de Migração</h3>

<pre class="brush: bash">$ php artisan migrate:make create_users_table --table=users --create
$ php artisan migrate:make create_urls_table --table=urls --create</pre>

<p>Esses comandos criar os arquivos necessários que usaremos para criar nossas tabelas no banco de dados. Nosso trabalho, agora, é preenchê-los com as colunas corretas das tabelas.</p>

<p>Edite o arquivo <code>app/database/migrations/SOME_DATE_create_users_table.php</code> e adicione o método <code>up()</code>:</p>

<pre class="brush: php">public function up()
{
  Schema::create('users', function(Blueprint $table)
  {
      $table-&gt;increments('id');
      $table-&gt;string('username')-&gt;unique();
      $table-&gt;string('password');
      $table-&gt;timestamps();
  });
}</pre>

<p>No código acima, estamos criando os campos username (que deve ser único), password, bem como os campos *timestamps* (campos de criação e alteração do registro da tabela). Salve o arquivo e, agora, edite o arquivo <code>app/database/migrations/SOME_DATE_create_urls_table.php</code> (<em>SOME_DATE</em> está no formato YYYY_MM_DD_HMS), e adicione o método <code>up()</code>, como o abaixo:</p>

<pre class="brush: php">public function up()
{
  Schema::create('urls', function(Blueprint $table)
  {
      $table-&gt;increments('id');
      $table-&gt;integer('user_id');
      $table-&gt;string('url');
      $table-&gt;string('description');
      $table-&gt;timestamps();
  });
}</pre>

<p>O único ponto importante nesse trecho de código é que estamos criando um elo entre a tabela <code>url</code> e <code>users</code>, através do campo <code>user_id</code>.</p>

<h3>Adicionando Usuários de Exemplo</h3>

<p>Nós podemos usar os <a href="http://four.laravel.com/docs/migrations#database-seeding" title="laravel seed database">semeadores</a> (do inglês, <em>seeder</em>) do Laravel para criar alguns usuários para usarmos de exemplo.</p>

<p>Crie um arquivo dentro da pasta <code>app/database/seeds</code> com o mesmo nome da tabela que ele preencherá; no nosso caso, <code>UserTableSeeder.php</code>. Digite:</p>

<pre class="brush: php">&lt;?php

class UserTableSeeder extends Seeder {

  public function run()
  {
      DB::table('users')-&gt;delete();

      User::create(array(
          'username' =&gt; 'firstuser',
          'password' =&gt; Hash::make('first_password')
      ));

      User::create(array(
          'username' =&gt; 'seconduser',
          'password' =&gt; Hash::make('second_password')
      ));
  }

}</pre>

<p>depois disso, garanta que a classe semeadora seja executada quando a base de dados for semeada. Edite o arquivo <code>app/database/seeds/DatabaseSeeder.php</code>:</p>

<pre class="brush: php">public function run()
{
  Eloquent::unguard();

  // Adicione ou remova o comentário da linha abaixo
  $this-&gt;call('UserTableSeeder');
}</pre>

<h3>Execute as Migrações</h3>

<p>São os comandos a seguir que permitiram os códigos acima criar as duas tabelas e inserir os usuários de exemplo.</p>

<pre class="brush: php">// Cria as duas tabelas
$ php artisan migrate

// Cria os usuários exemplo
$ php artisan db:seed</pre>

<h2>Modelos</h2>

<p>O Laravel 4 continua a usar o excelente ORM, Eloquent. Por conta disso, lidar com as chamadas à base de dados será moleza. Nós utilizaremos um modelo por tabela.</p>

<p>Por sorte, o Laravel vem com um modelo User já preparado. A nós, somente resta a criação do modelo para nossa tabela urls.</p>

<p>Crie e edite o arquivo <code>app/models/Url.php</code>.</p>

<pre class="brush: php">&lt;?php

class Url extends Eloquent {

  protected $table = 'urls';

}</pre>

<h2>Autenticação</h2>

<p>Os <a href="http://four.laravel.com/docs/routing#route-filters" title="laravel filters">filtros</a> são os responsáveis por lidar com a autenticação para nós. Peculiarmente, agora, o Laravel vem com um filtro de Autenticação Básica (via HTTP), o qual podemos utilizar como um simples modelo de autenticação para as requisições à nossa API.</p>

<p>Se você abrir o arquivo <code>app/filters.php</code>, você verá como ele é:</p>

<pre class="brush: php">Route::filter('auth.basic', function()
{
  return Auth::basic();
});</pre>

<p>Nós só precisamos fazer um ajuste. Por padrão, o filtro busca pelo campo "email" da tabela para identificar o usuário. Como estamos lidando com o campo "username" (nomes de usuários), devemos indicar ao filtro que ele deve usar esse campo. Mude a chamada ao método estático <code>Auth::basic()</code> para que ele receba o campo "username" como parâmetro:</p>

<pre class="brush: php">Route::filter('auth.basic', function()
{
  return Auth::basic("username");
});</pre>

<h3>Rotas</h3>

<p>Vamos testar a aplicação. Crie uma rota chamada <code>testauth</code>, e faça com que o filtro <code>auth.basic</code> seja executando logo antes dela.</p>

<p>Edite o arquivo <code>app/routes.php</code>:</p>

<pre class="brush: php">Route::get('/authtest', array('before' =&gt; 'auth.basic', function()
{
  return View::make('hello');
}));</pre>

<p>Podemos verificar se está funcionando, fazendo uma requisição curl. Da sua linha de comando, faça uma requisição para o endereço local da sua aplicação Laravel. No meu caso, se parece com isso (Sua URL, provavelmente, será diferente!):</p>

<pre class="brush: php">$ curl -i localhost/l4api/public/index.php/authtest
HTTP/1.1 401 Unauthorized
Date: Tue, 21 May 2013 18:47:59 GMT
WWW-Authenticate: Basic
Vary: Accept-Encoding
Content-Type: text/html; charset=UTF-8

Invalid credentials</pre>

<p>Como você pode ver, uma requisição não autorizada (HTTP/1.1 401 Unauthorized) foi detectada e a mensagem "Invalid Credentials" (em português, Credenciais Inválidas) foi retornada com um código de estado 401. Agora, tente a mesma requisição passando o nome de usuário e senha (<em>username</em> e <em>password</em>).</p>

<pre class="brush: php">$ curl --user firstuser:first_password localhost/l4api/public/index.php/authtest
HTTP/1.1 200 OK
Date: Tue, 21 May 2013 18:50:51 GMT
Vary: Accept-Encoding
Content-Type: text/html; charset=UTF-8

&lt;h1&gt;Hello World!&lt;/h1&gt;</pre>

<p>Funcionou!</p>

<p>Até agora, a base de nossa API está pronta. Nós já temos:</p>

<ul>
<li>Instalação do Laravel 4</li>
<li>Base de Dados criada</li>
<li>Modelos criados</li>
<li>Modelo de Autenticação criado</li>
</ul>

<h2>Criando Requisições Funcionais</h2>

<p>Você já deve conhecer os <a href="http://four.laravel.com/docs/controllers#restful-controllers" title="laravel restful controller">controladores RESTful</a> do Laravel. Eles ainda existem no Laravel 4; contudo, nós também podemos usar os <a href="http://four.laravel.com/docs/controllers#resource-controllers" title="laravel resourceful controller">controladores inteligentes</a> (Resourceful Controllers) do Laravel, que cria um paradigma que podemos usar para criar uma API consistente. Nós usaremos esses controladores inteligentes.</p>
<blockquote>
<p><a href="http://four.laravel.com/docs/controllers#resource-controllers">Eis um resumo</a> do que cada controlador inteligente é capaz de lidar. Atente que você pode desconsiderar as rotas /resource/create e /resource/{id}/edit, uma vez que não mostraremos formulários para criar ("create") ou editar ("edit") formulários em um API.</p>
</blockquote>

<h3>Criando Controladores Inteligentes</h3>

<pre class="brush: bash">$ php artisan controller:make UrlController</pre>

<p>Agora, crie uma rota para usar o controlador e faça com que todas as rotas precisem de autenticação.</p>

<p>Edite o arquivo <code>app/routes.php</code> e adicione:</p>

<pre class="brush: php">// Agrupamento de rota para garantir versionamento da API
Route::group(array('prefix' =&gt; 'api/v1', 'before' =&gt; 'auth.basic'), function()
{
  Route::resource('url', 'UrlController');
});</pre>

<p>Algumas coisas estão acontecendo aqui:</p>

=========================================================================================

<ol>
<li>This is going to respond to requests made to <code>http://example.com/api/v1/url</code>.</li>
<li>This allows us to add extra routes, if we need to expand our API. For instance, if you add a user end-point, such as <code>/api/v1/user</code>.<br /></li>
<li>There is also a naming mechanism in place for versioning our API. This gives us the opportunity to roll out new API versions without breaking older versions - We can simply create a <strong>v2</strong> route group, and point it to a new controller!</li>
</ol>

<p>Note: You may want to consider more advanced API versioning techniques, such as using an <code>Accept</code> header or subdomain which can help you point different API versions separate code bases.</p>

<h3>Add the Functionality</h3>

<p>Edit the new <code>app/controllers/UrlController.php</code> file:</p>

<pre class="brush: php">// Edit this:
public function index()
{
  return 'Hello, API';
}</pre>

<p>Let's test it:</p>

<pre class="brush: php">$ curl -i localhost/l4api/public/index.php/api/v1/url
HTTP/1.1 401 Unauthorized
Date: Tue, 21 May 2013 19:02:59 GMT
WWW-Authenticate: Basic
Vary: Accept-Encoding
Content-Type: text/html; charset=UTF-8

Invalid credentials.

$ curl --user firstuser:first_password localhost/l4api/public/index.php/api/v1/url
HTTP/1.1 200 OK
Date: Tue, 21 May 2013 19:04:19 GMT
Vary: Accept-Encoding
Content-Type: text/html; charset=UTF-8

Hello, API</pre>

<p>We now have a resourceful controller with authentication working, and are ready to add functionality.</p>

<h3>Create a URL</h3>

<p>Edit <code>app/controllers/UrlController.php</code>:</p>

<pre class="brush: php">/**
 * Store a newly created resource in storage.
 *
 * @return Response
 */
public function store()
{
  $url = new Url;
  $url-&gt;url = Request::get('url');
  $url-&gt;description = Request::get('description');
  $url-&gt;user_id = Auth::user()-&gt;id;

  // Validation and Filtering is sorely needed!!
  // Seriously, I'm a bad person for leaving that out.

  $url-&gt;save();

  return Response::json(array(
      'error' =&gt; false,
      'urls' =&gt; $urls-&gt;toArray()),
      200
  );
}</pre>

<p>It's time to test this with another curl request. This one will send a POST request, which will correspond to the <code>store()</code> method created above.</p>

<pre class="brush: bash">$ curl -i --user firstuser:first_password -d 'url=http://google.com&amp;description=A Search Engine' localhost/l4api/public/index.php/api/v1/url
HTTP/1.1 201 Created
Date: Tue, 21 May 2013 19:10:52 GMT
Content-Type: application/json

{"error":false,"message":"URL created"}</pre>

<p>Cool! Let's create a few more, for both of our users.</p>

<pre class="brush: bash">$ curl --user firstuser:first_password -d 'url=http://fideloper.com&amp;description=A Great Blog' localhost/l4api/public/index.php/api/v1/url

$ curl --user seconduser:second_password -d 'url=http://digitalsurgeons.com&amp;description=A Marketing Agency' localhost/l4api/public/index.php/api/v1/url

$ curl --user seconduser:second_password -d 'url=http://www.poppstrong.com/&amp;description=I feel for him' localhost/l4api/public/index.php/api/v1/url</pre>

<p>Next, let's create methods for retrieving URLs.</p>

<pre class="brush: php">/**
 * Display a listing of the resource.
 *
 * @return Response
 */
public function index()
{
  //Formerly: return 'Hello, API';

  $urls = Url::where('user_id', Auth::user()-&gt;id)-&gt;get();

  return Response::json(array(
      'error' =&gt; false,
      'urls' =&gt; $urls-&gt;toArray()),
      200
  );
}

/**
 * Display the specified resource.
 *
 * @param  int  $id
 * @return Response
 */
public function show($id)
{
  // Make sure current user owns the requested resource
  $url = Url::where('user_id', Auth::user()-&gt;id)
          -&gt;where('id', $id)
          -&gt;take(1)
          -&gt;get();

  return Response::json(array(
      'error' =&gt; false,
      'urls' =&gt; $url-&gt;toArray()),
      200
  );
}</pre>

<p>Let's test them out:</p>

<pre class="brush: bash">$ curl --user firstuser:first_password localhost/l4api/public/index.php/api/v1/url
{
  "error": false,
  "urls": [
     {
          "created_at": "2013-02-01 02:39:10",
          "description": "A Search Engine",
          "id": "2",
          "updated_at": "2013-02-01 02:39:10",
          "url": "http://google.com",
          "user_id": "1"
      },
      {
          "created_at": "2013-02-01 02:44:34",
          "description": "A Great Blog",
          "id": "3",
          "updated_at": "2013-02-01 02:44:34",
          "url": "http://fideloper.com",
          "user_id": "1"
      }
  ]
}

$ curl --user firstuser:first_password localhost/l4api/public/index.php/api/v1/url/1
{
  "error": false,
  "urls": [
      {
          "created_at": "2013-02-01 02:39:10",
          "description": "A Search Engine",
          "id": "2",
          "updated_at": "2013-02-01 02:39:10",
          "url": "http://google.com",
          "user_id": "1"
      }
  ]
}</pre>

<p>Almost done. Let's now allow users to delete a url.</p>

<pre class="brush: php">/**
 * Remove the specified resource from storage.
 *
 * @param  int  $id
 * @return Response
 */
public function destroy($id)
{
  $url = Url::where('user_id', Auth::user()-&gt;id)-&gt;find($id);

  $url-&gt;delete();

  return Response::json(array(
      'error' =&gt; false,
      'message' =&gt; 'url deleted'),
      200
      );
}</pre>

<p>Now, we can delete a URL by using a DELETE request:</p>

<pre class="brush: bash">$ curl -i -X DELETE --user firstuser:first_password localhost/l4api/public/index.php/api/v1/url/1
HTTP/1.1 200 OK
Date: Tue, 21 May 2013 19:24:19 GMT
Content-Type: application/json

{"error":false,"message":"url deleted"}</pre>

<p>Lastly, let's allow users to update a url.</p>

<pre class="brush: php">/**
 * Update the specified resource in storage.
 *
 * @param  int  $id
 * @return Response
 */
public function update($id)
{
  $url = Url::where('user_id', Auth::user()-&gt;id)-&gt;find($id);

  if ( Request::get('url') )
  {
      $url-&gt;url = Request::get('url');
  }

  if ( Request::get('description') )
  {
      $url-&gt;description = Request::get('description');
  }

  $url-&gt;save();

  return Response::json(array(
      'error' =&gt; false,
      'message' =&gt; 'url updated'),
      200
  );
}</pre>

<p>To test URL updates, run:</p>

<pre class="brush: bash">$ curl -i -X PUT --user seconduser:second_password -d 'url=http://yahoo.com' localhost/l4api/public/index.php/api/v1/url/4
HTTP/1.1 200 OK
Date: Tue, 21 May 2013 19:34:21 GMT
Content-Type: application/json

{"error":false,"message":"url updated"}

// View our changes
$ curl --user seconduser:second_password localhost/l4api/public/index.php/api/v1/url/4
{
  "error": false,
  "urls": [
      {
          "created_at": "2013-02-01 02:44:34",
          "description": "I feel for him",
          "id": "3",
          "updated_at": "2013-02-02 18:44:18",
          "url": "http://yahoo.com",
          "user_id": "1"
      }
  ]
}</pre>

<h2>And That's It</h2>

<p>We now have the beginnings of a fully-functioning API. I hope that you've learned a lot about how to get an API underway with Laravel 4.</p>

<p>To recap, we achieved the following in this lesson:</p>

<ol>
<li>Install Laravel</li>
<li>Create the database, using migrations and seeding</li>
<li>Use Eloquent ORM models</li>
<li>Authenticate with Basic Auth</li>
<li>Set up Routes, including versioning the API</li>
<li>Create the API functionality using Resourceful Controllers</li>
</ol>

<h3>The Next Steps</h3>

<p>If you'd like to push your API up a notch, you might consider any of the following as a next step.</p>

<ol>
<li>Validation (Hint: Laravel has a <a href="http://four.laravel.com/docs/validation">Validation library</a>).</li>
<li>API-request error handling – It's still possible to receive HTML response on API requests (Hint: <a href="http://fideloper.com/laravel4-error-handling" title="laravel error handling">Laravel Error Handling</a>, plus Content Negotiation.)</li>
<li>Content Negotiation - listening for the Accept header. (Hint: <a href="http://four.laravel.com/docs/requests#request-information" title="Laravel request class">Laravel's Request Class</a> will give you the request headers).</li>
<li>Check out the <a href="http://groups.google.com/group/api-craft/">API Craft Google Group</a></li>
<li>Learn about the <a href="http://fideloper.com/quick-caching-explanation?utm_source=nettuts&amp;utm_medium=article&amp;utm_content=api&amp;utm_campaign=guest_author" title="http cache">different types caching</a> and how Validation Caching can improve your API</li>
<li><a href="leanpub.com/laravel-testing-decoded">Unit test your code</a></li>
<li>Check out <a href="http://apigee.com/about/api-best-practices">Apigee's great API resources</a></li>
</ol>
