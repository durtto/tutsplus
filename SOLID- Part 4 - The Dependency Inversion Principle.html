<h1>Princípos SOLID Parte 4 - Princípio da Inversão de Dependência</h1>

<p><a href="http://code.tutsplus.com/tutorials/solid-part-1-the-single-responsibility-principle--net-36074">Responsabilidade Única (SRP - Single Responsability)</a>, <a href="http://code.tutsplus.com/tutorials/solid-part-2-the-openclosed-principle--net-36600">Aberto para Expansão, Fechado para Modificações (Open/Close)</a>, <a href="http://code.tutsplus.com/tutorials/solid-part-3-liskov-substitution-interface-segregation-principles--net-36710">Substituição de Liskov (Liskov's Substitution), Segregação de Interface (Interface Segregation);</a> e <em>Inversão de Dependência (Dependency Inversion)</em>. Cinco princípios ágeis que deveriam guiar você todas as vezes que fosse programar.</p>

<p>Não seria justo dizer que qualquer um dos princípios SOLID fosse mais importante que os outros. Contudo, é bem provável que nenhum dos outros princípios tenha efeito tão imediato e profundo em seu código quanto o Princípio da Inversão de Dependência (Dependency Inversion Principle - DIP). Se você acha os outros princípios difíceis de entender e aplicar, comece com esse daqui e aplique os outros princípios nos códigos que respeitem o DIP.</p>

<h2>Definição</h2>

<blockquote><p>A. Módulos de alto nível não deveriam depender em módulos de baixo nível. Ambos deveriam depender de abstrações.<br>
B. Abstrações não deveriam depender de detalhes. Detalhes devem depender de abstrações.</p>
</blockquote>

<p>Esse princípio foi definido por <a href="http://www.8thlight.com/our-team/robert-martin">Robert C. Martin</a> em seu livro <a href="http://www.amazon.com/Software-Development-Principles-Patterns-Practices/dp/0135974445/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1378755964&amp;sr=1-1&amp;keywords=robert+c+martin">Agile Software Development, Principles, Patterns, and Practices</a> e depois na versão em C# do mesmo livro, <a href="http://www.amazon.com/Agile-Principles-Patterns-Practices-C/dp/0131857258">Agile Principles, Patterns, and Practices in C#</a>, e é o último dos cinco princípios ágeis SOLID.</p>

<h2>DIP no Mundo Real</h2>

<p>Antes de começarmos a codificar algo, quero contar-lhes uma história. Lá na Syneto, não fomos, sempre, cuidados com os códigos que criamos. Alguns anos atrás, sabíamos menos e, embora puséssemos o melhor de nós, nem todos nossos projetos eram legais. Nós fomos ao inferno e voltamos, e aprendemos algumas coisas, na tentativa e erro.</p>

<p>Os princípios SOLID e a clara arquitetura do Tio Bob (Robert C. Martin) mudaram nossa situação, e transformaram a maneira como codificamos, de tal forma, que é difícil de descrever. Tentarei explicar, de forma simples, algumas decisões arquiteturais impostas pelo DIP que tiveram um grande impacto em nossos projetos.</p>

<p>A maioria dos projetos web contém três tecnologias principais: HTML, PHP, e SQL. As versões específicas dessas tecnologias ou o tipo da implementação SQL que usamos, são irrelevantes. O ponto é, a informação em um formulário HTML deve acabar, de uma forma ou de outra, no banco de dados. A "cola" necessária entre os dois, pode ser dado pelo PHP.</p>

<p>O que é preciso entender dessa situação, é como essas três tecnologias representam tão bem três camadas arquiteturais diferentes: interface do usuário, lógica de negócios e persistência. Nós trataremos sobre as implicações dessas três camadas em um minuto. Por hora, foquemos numa forma esquisita e frequentente vista para fazer essas tecnologias trabalharem juntas.</p>

<p>Já vi diversos projetos que usam código SQL em um script PHP, dentro de um arquivo HTML, ou, ainda, códigos PHP imprimindo páginas e mais páginas de HTML, interpretando, diretamente, variáveis globais de <code>$_GET</code> ou <code>$_POST</code>. Mas, por que isso é ruim?</p>

<figure>
<img width="600" alt="html-php-sql-cross-dependencies" src="http://cdn.tutsplus.com/net/uploads/2014/02/html-php-sql-cross-dependencies.png" height="423"><br>
</figure>

<p>As imagens acima representam uma versão bem crua do que descrevemos no parágrafo anterior. As setas representam várias dependências e, podemos concluir que, basicamente, tudo depende tudo. Se precisamos mudar uma tabela da base de dados, talvez tenhamos de alterar até algum arquivo HTML. Ou, se mudarmos algum campo de formulário no HTML, nós talvez precisemos mudar o nome de alguma coluna em alguma instrução SQL. Ou, se aprendermos algum outro esquema, talvez precisemos mudar nosso código PHP se o HTML mudar, ou, em casos bem ruins, se geramos o HTML a partir de um arquivo PHP, é certo que tenhamos de modificar o código PHP para modificar o HTML. Então, não há dúvidas, as dependências estão ziguezagueando entre as clsses e módulos. Mas, não acaba aí. Você pode ter procedimentos armazenados: Código PHP em tabelas SQL.</p>

<figure>
<img width="600" alt="html-php-sql-stored-procedures" src="http://cdn.tutsplus.com/net/uploads/2014/02/html-php-sql-stored-procedures.png" height="503"><br>
</figure>

<p>No esquema acima, as consultas SQL na base de dados retornam código PHP gerado com os dados vindos das tabelas. Essas funções ou classes PHP executam outras consultas SQL que retornam outros códigos PHP, e o ciclo continua até, finalmente, toda a informação obtida é retornada... provavelmente para a Interface do Usuário.</p>

<p>Sei que isso pode parecer terrível para a maioria de vocês, mas, se você não trabalhou com um projeto inventado e implementado dessa forma, você, provavelmente, irá em algum projeto futuro. A maioria dos projetos existentes, independente da linguagem de programação usada, foram escritos com antigos princípios em mente, por programadores que não se importavam ou não sabiam como fazer melhor. Se você está lendo esses tutoriais, você, certamente, está um nível acima. Você está pronto ou preparando-se para respeitar seu trabalho, abraçar sua arte e fazer mais e melhor.</p>

<p>A outra opção é repetir os erros de seus predecessores cometeram e viver com as consequências. Lá na Syneto, depois que um de nossos projetos alcançou um estado de uma manutenção quase que impraticável, devido a sua arquitetura antiga e interdependente, tivemos de abandoná-la para sempre, nós decidimos que não queríamos seguir aquele caminho, novamente. Desde então, nós buscamos uma arquitetura clara, que respeita os princípios SOLID e, de forma mais importante, o Princípio da Inversão de Dependência.</p>

<figure>
<img width="600" alt="HighLevelDesign" src="http://cdn.tutsplus.com/net/uploads/2014/02/HighLevelDesign.png" height="388"><br>
</figure>

<p>What's so amazing about this architecture is how the dependencies are pointing:</p>

<ul>
<li>The user interface (in most cases a web MVC framework) or whatever other delivery mechanism there is for your project will depend on the business logic. Business logic is quite abstract. A user interface is very concrete. The UI is just a detail for the project, and it is also very volatile. Nothing should depend on the UI, nothing should depend on your MVC framework.</li>
<li>The other interesting observation we can make is that the persistence, the database, your MySQL or PostgreSQL, depends on the business logic. Your business logic is database agnostic. This allows exchanging persistence as you wish. If tomorrow you want to change MySQL with PostgreSQL or just plain text files, you can do that. You will, of course, need to implement a specific persistence layer for the new persistence method, but you will not need to modify a single line of code in your business logic. There is a more detailed explanation on the persistence topic in the <a href="http://code.tutsplus.com/tutorials/evolving-toward-a-persistence-layer--net-27138">Evolving Toward a Persistence Layer</a> tutorial. </li>
<li>Finally, on the right of the business logic, outside of it, we have all the classes that are creating business logic classes. These are factories and classes created by the entry point to our application. Many people tend to think these belong to the business logic, but while they are creating business objects, their sole reason is to do this. They are classes just to help us create other classes. The business objects and the logic they provide are independent of these factories. We could use different patterns, like Simple Factory, Abstract Factory, Builder or plain object creation to provide the business logic. It doesn't matter. Once the business objects are created they can do their job.</li>
</ul>

<h2>Show Me the Code</h2>

<p>Applying the Dependency Inversion Principle (DIP) at an architectural level is quite easy if you respect the classic <a href="https://tutsplus.com/course/agile-design-patterns/">agile design patterns</a>. Exercising and exemplifying it inside the business logic is quite easy also and can even be fun. We will imagine an e-book reader application.</p>

<pre class="brush: php">class Test extends PHPUnit_Framework_TestCase {

	function testItCanReadAPDFBook() {
		$b = new PDFBook();
		$r = new PDFReader($b);

		$this-&gt;assertRegExp('/pdf book/', $r-&gt;read());
	}

}

class PDFReader {

	private $book;

	function __construct(PDFBook $book) {
		$this-&gt;book = $book;
	}

	function read() {
		return $this-&gt;book-&gt;read();
	}

}

class PDFBook {

	function read() {
		return "reading a pdf book.";
	}
}</pre>

<p>We start developing our e-reader as a PDF reader. So far so good. We have a <code>PDFReader</code> class using a <code>PDFBook</code>. The <code>read()</code> function on the reader delegates to the book's <code>read()</code> method. We just verify this by doing a regex check after a key part of the string returned by <code>PDFBook</code>'s <code>reader()</code> method.</p>

<p>Please bear in mind that this is just an example. We will not implement the reading logic of PDF files or other file formats. That's why our tests will just simply check for some basic strings. If we were to write the real application, the only difference would be how we test the different file formats. The dependency structure would be very similar to our example.</p>

<figure>
<img width="600" alt="pdfreader-pdfbook" src="http://cdn.tutsplus.com/net/uploads/2014/02/pdfreader-pdfbook.png" height="89"><br>
</figure>

<p>Having a PDF reader using a PDF book may be a sound solution for a limited application. If our scope was to write a PDF reader and nothing more, it would actually be an acceptable solution. But we want to write a generic e-book reader, supporting several formats, amongst which our first implemented version PDF. Let's rename our reader class.</p>

<pre class="brush: php">class Test extends PHPUnit_Framework_TestCase {

	function testItCanReadAPDFBook() {
		$b = new PDFBook();
		$r = new EBookReader($b);

		$this-&gt;assertRegExp('/pdf book/', $r-&gt;read());
	}

}

class EBookReader {

	private $book;

	function __construct(PDFBook $book) {
		$this-&gt;book = $book;
	}

	function read() {
		return $this-&gt;book-&gt;read();
	}

}

class PDFBook {

	function read() {
		return "reading a pdf book.";
	}
}</pre>

<p>Renaming had no functional counter effects. The tests are still passing.</p>

<p>Testing started at 1:04 PM ...<br>
PHPUnit 3.7.28 by Sebastian Bergmann.<br>
Time: 13 ms, Memory: 2.50Mb<br>
OK (1 test, 1 assertion)<br>
Process finished with exit code 0</p>

<p>But it has a serious design effect.</p>

<figure>
<img width="600" alt="ebookreader-pdfbook" src="http://cdn.tutsplus.com/net/uploads/2014/02/ebookreader-pdfbook.png" height="89"><br>
</figure>

<p>Our reader became much more abstract. Much more general. We have a generic <code>EBookReader</code> that uses a very specific book type, <code>PDFBook</code>. An abstraction depends on a detail. The fact that our book is of type PDF should only be a detail, and no one should depend on it.</p>

<pre class="brush: php">class Test extends PHPUnit_Framework_TestCase {

	function testItCanReadAPDFBook() {
		$b = new PDFBook();
		$r = new EBookReader($b);

		$this-&gt;assertRegExp('/pdf book/', $r-&gt;read());
	}

}

interface EBook {
	function read();
}

class EBookReader {

	private $book;

	function __construct(EBook $book) {
		$this-&gt;book = $book;
	}

	function read() {
		return $this-&gt;book-&gt;read();
	}

}

class PDFBook implements EBook{

	function read() {
		return "reading a pdf book.";
	}
}</pre>

<p>The most common, and most frequently used solution to invert the dependency is to introduce a more abstract module in our design. "The most abstract element in OOP is an Interface. Thus, any other class can depend on an Interface and still respect DIP".</p>

<p>We created an interface <em>for our reader</em>. The interface is called <code>EBook</code> and represents the needs of the <code>EBookReader</code>. This is a direct result of respecting the <a href="http://dev.tutsplus.com/tutorials/solid-part-3-liskov-substitution-interface-segregation-principles--net-36710">Interface Segregation Principle (ISP)</a> which promotes the idea that interfaces should reflect the needs of the clients. Interfaces belong to the clients, and thus they are named to reflect the types and objects the clients need and they will contain methods the clients wants to use. It is only natural for an <code>EBookReader</code> to use <code>EBooks</code> and have a <code>read()</code> method.</p>

<figure>
<img width="600" alt="ebookreader-ebookinterface-pdfbook" src="http://cdn.tutsplus.com/net/uploads/2014/02/ebookreader-ebookinterface-pdfbook.png" height="246"><br>
</figure>

<p>Instead of a single dependency, we have two dependencies now.</p>

<ul>
<li>The first dependency points from <code>EBookReader</code> toward the <code>EBook</code> interface and it is of type usage. <code>EBookReader</code> uses <code>EBooks</code>.</li>
<li>The second dependency is different. It points from <code>PDFBook</code> toward the same <code>EBook</code> interface but it is of type implementation. A <code>PDFBook</code> is just a particular form of <code>EBook</code>, and thus implements that interface to satisfy the client's needs.</li>
</ul>

<p>Unsurprisingly, this solution also allows us to plug in different types of ebooks into our reader. The single condition for all these books is to satisfy the <code>EBook</code> interface and implement it.</p>

<pre class="brush: php">class Test extends PHPUnit_Framework_TestCase {

	function testItCanReadAPDFBook() {
		$b = new PDFBook();
		$r = new EBookReader($b);

		$this-&gt;assertRegExp('/pdf book/', $r-&gt;read());
	}

	function testItCanReadAMobiBook() {
		$b = new MobiBook();
		$r = new EBookReader($b);

		$this-&gt;assertRegExp('/mobi book/', $r-&gt;read());
	}

}

interface EBook {
	function read();
}

class EBookReader {

	private $book;

	function __construct(EBook $book) {
		$this-&gt;book = $book;
	}

	function read() {
		return $this-&gt;book-&gt;read();
	}

}

class PDFBook implements EBook {

	function read() {
		return "reading a pdf book.";
	}
}

class MobiBook implements EBook {

	function read() {
		return "reading a mobi book.";
	}
}</pre>

<p>Which in turn leads us to <a href="http://dev.tutsplus.com/tutorials/solid-part-2-the-openclosed-principle--net-36600">The Open/Closed Principle</a>, and the circle is closed.</p>

<p>The Dependency Inversion Principle is one that leads or helps us respect all the other principles. Respecting DIP will:</p>

<ul>
<li>Almost force you into respecting OCP.</li>
<li>Allow you to separate responsibilities.</li>
<li>Make you correctly use subtyping.</li>
<li>Offer you the opportunity to segregate your interfaces.</li>
</ul>

<h2>Final Thoughts</h2>

<p>That's it. We are done. All tutorials about the SOLID principles are complete. For me, personally, discovering these principles and implementing projects with them in mind was a huge change. I completely changed the way I think about design and architecture and I can say since then all the projects I work on are exponentially easier to manage and understand.</p>

<p>I consider the SOLID principles one of the most essential concepts of object-oriented design. These concepts that must guide us in making our code better and our life as programmers much much easier. Well-designed code is easier for programmers to understand. Computers are smart, they can understand code regardless of its complexity. Human beings on the other hand have a limited number of things they can keep in their active, focused mind. More specifically, the number of such things is <a href="http://www.musanim.com/miller1956/">The Magical Number Seven, Plus or Minus Two</a>.</p>

<p>We should strive to have our code structured around these numbers and there are several techniques that help us do so. Functions with a maximum of four lines in length (five with the definition line included) so that they can all fit at once within our mind. Indentations not passing five levels deep. Classes with no more than nine methods. Design patterns that usually use a number of five to nine classes. Our high level design in the schemas above uses four to five concepts. There are five SOLID principles, each requiring five to nine sub-concepts/modules/classes to be exemplified. The ideal size of a programming team is between five and nine. The ideal number of teams in a company is between five and nine.</p>

<p>As you can see, the magical number seven, plus or minus two is all around us, so why should your code be different?</p>
