<h1>PHP Orientado a Objetos para Iniciantes</h1>

<p>Para muitos programadores PHP, orientação a objetos é um conceito amedrontador, cheio de sintaxes complicadas e paradas. Com o mesmo detalhamento do meu livro, <em><a href="http://www.amazon.com/gp/product/1430228474?ie=UTF8&amp;tag=ennudesi-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=1430228474">Pro PHP and jQuery,</a></em> você aprenderá os conceitos pro trás da <strong>programação orientada a objetos</strong> (POO), um estilo de codigicação onde as ações relacionadas são agrupadas em classes para ajudar na criação de códigos mais compactos e efetivos.</p>


<h2>Compreendendo a Programação Orientada a Objetos</h2>

<p>
Programação orientada a objetos é um estilo de programação que permite os desenvolvedores agrupar tarefas semelhantes em <strong>classes</strong>. Isso ajuda a nos mantermos dentro do princípio <a href="http://en.wikipedia.org/wiki/Don't_repeat_yourself">"don't repeat yourself" (DRY)</a> (em português, <em>não se repita</em>) and e facilta a manutenção do mesmo.</p>

<blockquote class="pullquote pqRight">
<p>"Programação orientada a objetos é um estilo de programação que permite os desenvolvedores agrupar tarefas semelhantes em <strong>classes</strong>."</p>

</blockquote>

<p>Um dos maiors benefícios da programação DRY programming é que, se alguma informação é alterada em seu programa, geralmente, <strong>só uma mudança é necessária para atualizar o código</strong>. Um dos maiores problemas para os desenvolvedores é ter de manter códigos onde os dados são declarados e redeclarados, acarretando num jogo de pique esconde, em busca de funcionalidade e dados duplicados pelo código.</p>

<p>POO é intimidadora para uma grande quantidade de programadores porque ela introduz uma nova sintaxe e, a primeira vista, parece ser bem mais complexa que a simples programação procedural. Entretanto, se analisar bem, POO é bem direta e fundamentalmente uma abordagem mais simples para programação.</p>

<h2>Compreendendo Objetos e Classes</h2>

<p>Antes de lidar diretamente com as partes mais interessante da POO, um entendimento básico das diferenças entre <strong>objetos</strong> e <strong>classes</strong> é necessário. Essa seção falará sobre a base das classes, suas diferentes capacidades e alguns de seus usos.</p>

<h3>Reconhecendo as Diferenças Entre Objetos e Classes</h3>

<figure>
  <img src="http://s3.amazonaws.com/nettuts/734_oop/images/blueprint-houses.jpg" border="0" />
  <figcaption>Fotos por <a href="http://www.flickr.com/photos/instantjefferson/">Instant Jefferson</a> e <a href="http://www.flickr.com/photos/johnwardell/">John Wardell</a></figcaption>
</figure>

<blockquote>
<p>Quando programadores de longa data falam sobre objetos e classes, esses termos parecem permutáveis. Porém, não é bem assim.</p>
</blockquote>

<p>Logo de cara, há uma grande confusão na POO: quando programadores de longa data falam sobre objetos e classes, esses termos parecem permutáveis. Porém, não é bem assim, muito embora a diferença entre eles seja um pouco complicada de perceber, no início.</p>

<p>Uma classe, por exemplo, é como uma <strong>planta baixa para uma casa</strong>. Ela define a forma da casa no papel, com as relações entre as diferentes partes da casa, claramente, definidas e planejadas, mesmo a casa ainda não existindo.</p>

<p>Um objeto, por outro lado, <strong>seria a casa de verdade</strong>, construída de acordo com a planta baixa. Os dados guardados no objeto são como a madeira, fios e concreto que compoem a casa: sem a ordem criada pela planta baixa, são só um monte de materiais. Entretanto, quando tudo é colocado seguido uma ordem, eles viram uma casa organizada e útil.</p>

<p><strong>As classes servem de estrutura para os dados e ações, e usam essa informaçao para construir objetos.</strong> Mais de um objeto pode ser construido de uma mesma classe, ao mesmo tempo, cada um independente dos outros. Continuando a nossa analogia à construção, é parecida com a maneira que um condomínio de casa pode ser construído, usando a mesma planta baixa: 150 casas diferentes, todas bastante parecidas umas às outras, porém, contem <br />
famílias e decorações diferentes, por dentro.</p>

<h3>Estruturando Classes</h3>

<p>A sintaxe para criar uma classe é bem direta: declare-a usando a palavra chave <code>class</code>, seguida do nome da classe e um par de chaves (<code>{}</code>):</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  // As propriedades e métodos da Classe vem aqui
}

?&gt;</pre>

<p>Após criar a classe, a classe pode ser instanciada e guardada em alguma variável usando a palavra chave <code>new</code>:</p>

<pre class="brush: php">
$obj = new MyClass;</pre>

<p>Para vermos o conteúdo da classe, usamos <code>var_dump()</code>:</p>

<pre class="brush: php">
var_dump($obj);</pre>

<p>Experimente isso, colocando todo o código anterior em um único arquivo php, chamado <code>test.php</code> na sua pasta local de testes:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  // As propriedades e métodos da Classe vem aqui
}

$obj = new MyClass;

var_dump($obj);

?&gt;</pre>

<p>Carregue a página no seu navegador, usando o endereço <code>http://localhost/test.php</code> (ou o endereço indicado pelo seu servidor local) e o resultado a seguir deve aparecer:</p>

<pre class="brush: php">
object(MyClass)#1 (0) { }</pre>

<p><strong>De uma forma bem simplória, você acabou de criar seu primeiro código em POO.</strong></p>

<h2>Definindo as Propriedades da Classe</h2>

<p>Para adicionar dados à classe, usamos as <strong>propriedades</strong>, que são variáveis específicas à classe. Elas funcionam de forma parecida às variáveis normais, exceto que elas estão ligadas ao objeto e só podem ser acessadas usando o objeto.</p>

<p>Para adicionar uma propriedade a <code>MyClass</code>, adicione o seguinte trecho de código ao seu script:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou um propriedade de classe!";
}

$obj = new MyClass;

var_dump($obj);

?&gt;</pre>

<p>A palavra chave <code>public</code> determina a visibilidade da propriedade, a qual você aprenderá mais sobre, no próximo capítulo. Depois disso, a propriedade é nomeada usando os padrões básicos de nomeação de variáves, e, então, um valor é atribuído (embora propriedades de classe não necessitem de valores iniciais).</p>

<p>Para ver o valor da propriedade e mostrá-la no navegador, referencie o objeto o qual será feita a leitura, bem como a propriedade a ser lida, dessa forma:</p>

<pre class="brush: php">
echo $obj-&gt;prop1;</pre>

<p>Já que múltiplas instâncias de uma mesma classe podem existir, se um objeto em específico não for referenciado, o código não será capaz de determinar de qual objeto ler a propriedade. O uso da flecha (<code>-&gt;</code>) é um construto da POO no PHP que permite acessar as propriedades e métodos de um dado objeto.</p>

<p>Modifique o código do arquivo <code>test.php</code> para ler a propriedade ao invés de mostrar todo o conteúdo da classe, dessa forma:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou um propriedade de classe!";
}

$obj = new MyClass;

echo $obj-&gt;prop1; // Mostra a saída/conteúdo da propriedade

?&gt;</pre>

<p>Atualizando a página no seu navegador, você obtem isso, agora:</p>

<pre class="brush: php">
Sou uma propriedade de classe!</pre>

<h2>Definindo Métodos de Classe</h2>

<p><strong>Métodos</strong> são funções específicas das classes. Ações particulares que os objetos serão capazes de executar são definidas dentro das classes na forma de métodos.</p>

<p>Por exemplo, para criar métodos que atribuam e retornem o valor de uma propriedade de classe chamada <code>$prop1</code>, adicione o código a seguir:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou um propriedade de classe!";

  public function setProperty($newval)
  {
      $this-&gt;prop1 = $newval;
  }

  public function getProperty()
  {
      return $this-&gt;prop1 . "&lt;br /&gt;";
  }
}

$obj = new MyClass;

echo $obj-&gt;prop1;

?&gt;</pre>

<p><strong>Nota</strong> — POO permite que os objetos referenciem-se usando <code>$this</code>. Quando estiver dentro de um método, use <code>$this</code> da mesma forma que você usaria o nome do objeto fora da classe.</p>

<p>Para usar os métodos, execute-os da mesma forma que faria com funções normais, mas, antes, referencia o objeto ao qual eles pertencem. Para ler o valor da propriedade <code>$prop1</code> da classe <code>MyClass</code>, depois altera-lo e, por fim, le-lo novamente, faça as seguintes alterações no código:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou uma propriedade de classe!";

  public function setProperty($newval)
  {
      $this-&gt;prop1 = $newval;
  }

  public function getProperty()
  {
      return $this-&gt;prop1 . "&lt;br /&gt;";
  }
}

$obj = new MyClass;

echo $obj-&gt;getProperty(); // Lê o valor da propriedade

$obj-&gt;setProperty("Sou um novo valor da propriedade!"); // Atribui um novo valor

echo $obj-&gt;getProperty(); // Lê o valor novamente para mostrar a mudança

?&gt;</pre>

<p>Atualize a página no seu navegador e você verá o resultado a seguir:</p>

<pre class="brush: php">
Sou uma propriedade de classe!
Sou um novo valor da propriedade!</pre>

<blockquote>
<p>"O poder da POO mostra-se ao usar múltiplas instâncias da<br />
mesma classe."</p>

</blockquote>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou uma propriedade de classe!";

  public function setProperty($newval)
  {
      $this-&gt;prop1 = $newval;
  }

  public function getProperty()
  {
      return $this-&gt;prop1 . "&lt;br /&gt;";
  }
}

// Create two objects
$obj = new MyClass;
$obj2 = new MyClass;

// Mostra o valor de $prop1 de ambos os objetos
echo $obj-&gt;getProperty();
echo $obj2-&gt;getProperty();

// Atribui novos valores para ambos os objetos
$obj-&gt;setProperty("Sou um novo valor de propriedade!");
$obj2-&gt;setProperty("Pertenço à segunda instância!");

// Mostra o valor de $prop1 de ambos os objetos|
echo $obj-&gt;getProperty();
echo $obj2-&gt;getProperty();

?&gt;</pre>

<p>Quando atualizar a página do seu navegador, verá o resultado a seguir:</p>

<pre class="brush: php">
Sou uma propriedade de classe!
Sou uma propriedade de classe!
Sou um novo valor de propriedade!
Pertenço à segunda instância!</pre>

<p>Como pode ver, <strong>POO mantém os objetos como entidades diferentes</strong>, o que torna fácil a separação de diferentes partes de código em pedaços pequenos e relacionados.</p>

<h2>Métodos Mágicos em POO</h2>

<p>Para facilitar o uso dos objetos, o PHP provê uma série de <strong>métodos mágicos</strong>, métodos especiais chamados quando certas ações comuns ocorrem com objetos. Isso permite executar várias tarefas úteis com certa facilidade.</p>

<h3>Usando Construtores e Destruidores</h3>

<p>Quando um ojeto é isntanciado, é desejável que algumas coisas ocorram de cara. Para lidar com isso, o PHP provê o método <code>__construct()</code>, que é chamado automaticamente quando um novo objeto é<br />
criado.</p>

<p>Para ilustrar os conceitos dos construtores, adicione um construtor à classe <code>MyClass</code> que mostre uma mensagem todoa vez que uma nova instância for criada:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou uma propriedade de classe!";

  public function __construct()
  {
      echo 'A classe "', __CLASS__, '" foi instanciada!&lt;br /&gt;';
  }

  public function setProperty($newval)
  {
      $this-&gt;prop1 = $newval;
  }

  public function getProperty()
  {
      return $this-&gt;prop1 . "&lt;br /&gt;";
  }
}

// Cria um novo objeto
$obj = new MyClass;

// Mostra o valor de $prop1
echo $obj-&gt;getProperty();

// Mostra uma mensagem ao final do arquivo
echo "Fim do arquivo.&lt;br /&gt;";

?&gt;</pre>

<p><strong>Nota</strong> — <code>__CLASS__</code> retorna o nome da classe na qual foi usado; isso é o que chamaos de <a href="http://us3.php.net/manual/en/language.constants.predefined.php">constante mágica</a>. Há inúmeras constantes mágicas disponíveis e você pode ler mais sobre elas no <a href="http://us3.php.net/manual/en/language.constants.predefined.php">manual do PHP</a>.</p>

<p>Atualize a página no seu navegador e terá os resultados a seguir:</p>

<pre class="brush: php">
A classe "MyClass" foi instanciada!
Sou uma propriedade de classe!
Fim do arquivo.</pre>

<p>Para chamar uma função quando um objeto for destruído, o método mágico <code>__destruct()</code> está disponível. Ele é útil para finalizar as tarefas da classe (encerrar uma conexão com a base de dados, por exemplo).</p>

<p>Mostre uma mensagem quando um objeto for destruído usando o método mágico<br /><code>__destruct()</code> na class <code>MyClass</code>:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou uma propriedade de classe!";

  public function __construct()
  {
      echo 'A classe "', __CLASS__, '" foi instanciada!&lt;br /&gt;';
  }

  public function __destruct()
  {
      echo 'A classe "', __CLASS__, '" foi destruída.&lt;br /&gt;';
  }

  public function setProperty($newval)
  {
      $this-&gt;prop1 = $newval;
  }

  public function getProperty()
  {
      return $this-&gt;prop1 . "&lt;br /&gt;";
  }
}

// Cria um novo objeto
$obj = new MyClass;

// Mostra o valor de $prop1
echo $obj-&gt;getProperty();

// Mostra uma mensagem ao final do arquivo
echo "Fim do arquivo.&lt;br /&gt;";

?&gt;</pre>

<p>Com um método destruidor definido, atualize a página no seu navegador e verá o resultado a seguir:</p>

<pre class="brush: php">
A classe "MyClass" foi instanciada!
Sou uma propriedade de classe!
Fim do arquivo.
A classe "MyClass" foi destruída.</pre>

<blockquote>
<p>"Quando o fim do arquivo é alcançado, o PHP libera, automaticamente, todos os recursos."</p>

</blockquote>

<p>Para executar, explicitamente o método destruído, você pode destruir o objeto usando a função<br/> <code>unset()</code>:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou uma propriedade de classe!";

  public function __construct()
  {
      echo 'A classe "', __CLASS__, '" foi isntanciada!&lt;br /&gt;';
  }

  public function __destruct()
  {
      echo 'A classe "', __CLASS__, '" foi destruída.&lt;br /&gt;';
  }

  public function setProperty($newval)
  {
      $this-&gt;prop1 = $newval;
  }

  public function getProperty()
  {
      return $this-&gt;prop1 . "&lt;br /&gt;";
  }
}

// Cria um novo objeto
$obj = new MyClass;

// Mostra o valor de $prop1
echo $obj-&gt;getProperty();

// Destrói o objeto
unset($obj);

// Mostra uma mensagem ao final do arquivo
echo "Fim do arquivo.&lt;br /&gt;";

?&gt;</pre>

<p>Os resultados das mudanças aparecerão assim que você atualizar a página no seu navegador:</p>

<pre class="brush: php">
A classe "MyClass" foi iniciada!
Sou uma propriedade de classe!
A classe "MyClass" foi destruída.
Fim do arquivo.</pre>

<h3>Convertendo Em Uma String</h3>

<p>Para evitar que aconteça um erro quando &ndash; e se &ndash; algum script tentar mostrar a classe MyClass como uma string, existe outro método mágico, chamado  <code>__toString()</code>.</p>

<p>Sem o método <code>__toString()</code>, <em>tentar mostrar um objeto como uma string resulta em um erro fatal</em>. Tente mostrar um objeto, usando <code>echo</code>, sem o método mágico:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou uma propriedade de classe!";

  public function __construct()
  {
      echo 'A classe "', __CLASS__, '" foi isntanciada!&lt;br /&gt;';
  }

  public function __destruct()
  {
      echo 'A classe "', __CLASS__, '" foi destruída.&lt;br /&gt;';
  }

  public function setProperty($newval)
  {
      $this-&gt;prop1 = $newval;
  }

  public function getProperty()
  {
      return $this-&gt;prop1 . "&lt;br /&gt;";
  }
}

// Cria um novo objeto
$obj = new MyClass;

// Mostra o objeto como uma string
echo $obj;

// Destrói o objeto
unset($obj);

// Mostra uma mensagem ao final do arquivo
echo "Fim do arquivo.&lt;br /&gt;";

?&gt;</pre>

<p>O resultado é esse:</p>

<pre class="brush: php">
A classe "MyClass" foi instanciada!

Catchable fatal error: Object of class MyClass could not be converted to string in /Applications/XAMPP/xamppfiles/htdocs/testing/test.php on line 40</pre>

<p>Para evitar esse erro, adicione o método <code>__toString()</code> method:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou uma propriedade de classe!";

  public function __construct()
  {
      echo 'A classe "', __CLASS__, '" foi isntanciada!&lt;br /&gt;';
  }

  public function __destruct()
  {
      echo 'A classe "', __CLASS__, '" foi destruída.&lt;br /&gt;';
  }

  public function __toString()
  {
      echo "Usando o método toString: ";
      return $this-&gt;getProperty();
  }

  public function setProperty($newval)
  {
      $this-&gt;prop1 = $newval;
  }

  public function getProperty()
  {
      return $this-&gt;prop1 . "&lt;br /&gt;";
  }
}

// Cria um novo objeto
$obj = new MyClass;

// Mostra o objeto como uma string
echo $obj;

// Destrói o objeto
unset($obj);

// Mostra uma mensagem ao final do arquivo
echo "Fim do arquivo.&lt;br /&gt;";

?&gt;</pre>

<p>Nesse caso, tentar converter o objeto em string resulta numa chamada ao método <code>getProperty()</code>. Execute o código, recarregando a página no seu navegador, e veja o resultado:</p>

<pre class="brush: php">
A classe "MyClass" foi iniciada!
Usando o método toString: Sou uma propriedade de classe!
A classe "MyClass" foi destruída.
Fim do arquivo.</pre>

<p><strong>Dica</strong> — Além dos métodos mágicos discutidos nessa seção, inúmeros outros estão disponíveis. Para uma lista compelta com todos os métodos mágicos, veja a <a href="http://us2.php.net/manual/en/language.oop5.magic.php">respectiva página do manual do PHP</a>.</p>

<h2>Usando Herança de Classe</h2>

<p><strong>Classes podem herdar métodos e propriedades de outra classe</strong> usando a palavra chave <code>extends</code>. Por exemplo, para criar uma segunda classe que estenda <code>MyClass</code> e adicione um método, você faria dessa forma:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou uma propriedade de classe!";

  public function __construct()
  {
      echo 'A classe "', __CLASS__, '" foi iniciada!&lt;br /&gt;';
  }

  public function __destruct()
  {
      echo 'A classe "', __CLASS__, '" foi destruída.&lt;br /&gt;';
  }

  public function __toString()
  {
      echo "Usando o método toString: ";
      return $this-&gt;getProperty();
  }

  public function setProperty($newval)
  {
      $this-&gt;prop1 = $newval;
  }

  public function getProperty()
  {
      return $this-&gt;prop1 . "&lt;br /&gt;";
  }
}

class MyOtherClass extends MyClass
{
  public function newMethod()
  {
      echo "De um novo método na classe " . __CLASS__ . ".&lt;br /&gt;";
  }
}

// Cria um novo objeto
$newobj = new MyOtherClass;

// Usa o método da nova classe
echo $newobj-&gt;newMethod();

// Usa um método da classe pai
echo $newobj-&gt;getProperty();

?&gt;</pre>

<p>Após atualizar a página no seu navegador, você terá o seguinte resultado:</p>

<pre class="brush: php">
A classe "MyClass" foi iniciada!
De um novo método na classe MyOtherClass.
Sou uma propriedade de classe!
A classe "MyClass" foi destruída.</pre>

<h3>Sobrescrevendo Métodos e Propriedades Herdadas</h3>

<p>Para alterar uma propriedade ou o comportamento de um método existente na nova classe, você pode, simplesmente, sobrescreve-los, bastando redeclará-los na nova classe:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou uma propriedade de classe!";

  public function __construct()
  {
      echo 'A classe "', __CLASS__, '" foi iniciada!&lt;br /&gt;';
  }

  public function __destruct()
  {
      echo 'A classe "', __CLASS__, '" foi destruída.&lt;br /&gt;';
  }

  public function __toString()
  {
      echo "Usando o método toString: ";
      return $this-&gt;getProperty();
  }

  public function setProperty($newval)
  {
      $this-&gt;prop1 = $newval;
  }

  public function getProperty()
  {
      return $this-&gt;prop1 . "&lt;br /&gt;";
  }
}

class MyOtherClass extends MyClass
{
  public function __construct()
  {
      echo "Um novo construtor em " . __CLASS__ . ".&lt;br /&gt;";
  }

  public function newMethod()
  {
      echo "De um novo método na classe " . __CLASS__ . ".&lt;br /&gt;";
  }
}

// Cria um novo objeto
$newobj = new MyOtherClass;

// Usa o método da nova classe
echo $newobj-&gt;newMethod();

// Usa um método da classe pai
echo $newobj-&gt;getProperty();

?&gt;</pre>

<p>As mudanças no resultado serão:</p>

<pre class="brush: php">
Um novo construtor em MyOtherClass.
De um novo método na classe MyOtherClass.
Sou uma propriedade de classe!
A classe "MyClass" foi destruída.</pre>

<h3>Preservando Funcionalidades Originais de um Método Enquanto Sobrescreve o Mesmo</h3>

<p>Para adicionar uma nova funcionalidade a um método e, ao mesmo tempo, manter a funcionalidade do método original intacta, use a palavra chave <code>parent</code> juntamente ao <strong>operador de resolução de escopo</strong> (<code>::</code>):</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou uma propriedade de classe!";

  public function __construct()
  {
      echo 'A classe "', __CLASS__, '" foi iniciada!&lt;br /&gt;';
  }

  public function __destruct()
  {
      echo 'A classe "', __CLASS__, '" foi destruída.&lt;br /&gt;';
  }

  public function __toString()
  {
      echo "Usando o método toString: ";
      return $this-&gt;getProperty();
  }

  public function setProperty($newval)
  {
      $this-&gt;prop1 = $newval;
  }

  public function getProperty()
  {
      return $this-&gt;prop1 . "&lt;br /&gt;";
  }
}

class MyOtherClass extends MyClass
{
  public function __construct()
  {
      parent::__construct(); // Invoca o construtor da classe pai
      echo "Um novo construtor em " . __CLASS__ . ".&lt;br /&gt;";
  }

  public function newMethod()
  {
      echo "De um novo método na classe " . __CLASS__ . ".&lt;br /&gt;";
  }
}

// Cria um novo objeto
$newobj = new MyOtherClass;

// Usa o método da nova classe
echo $newobj-&gt;newMethod();

// Usa um método da classe pai
echo $newobj-&gt;getProperty();

?&gt;</pre>

<p>Dessa forma, será retornado tanto o que foi codificado no construtor pai quando no construtor da nova classe:</p>

<pre class="brush: php">
A classe "MyClass" foi iniciada!
Um novo construtor em MyOtherClass.
De um novo método na classe MyOtherClass.
Sou uma propriedade de classe!
A classe "MyClass" foi destruída.</pre>

<h2>Atribuindo Visbilidade a Propriedades e Métodos</h2>

<p>Para controle adicional sobre objetos, métodos e propriedades, atribuímos visibilidades a eles. Essa visibilidade controla como e de onde as propriedades podem ser acessadas. Há três palavras chaves para visibilidade: <code>public</code>, <code>protected</code>, e <code>private</code>. Em adição à sua visibilidade, um método ou propriedade pode ser declarado como <code>static</code>, o que permite que sejam acessados sem uma instanciação da classe.</p>

<blockquote class="pullquote pqRight"><p>"Para controle adicional sobre objetos, métodos e propriedades, atribuímos visibilidades a eles."</p>

</blockquote>

<p><strong>Nota</strong> — Visibilidade é um novo recurso presente a partir do PHP 5. Para maiores informações sobre <a href="http://us2.php.net/manual/en/language.oop5.php">compatibilidade da POO com o PHP 4</a>, veja a respectiva página do manual do PHP.</p>

<h3>Métodos e Propriedades Públicas</h3>

<p>Todos os métodos e propriedades que usamos, até agora, eram públicos. Isso significa que eles podem ser acessados de qualquer lugar, tanto dentro quanto fora da classe.</p>

<h3>Métodos e Propriedades Protegidas</h3>

<p>Quando uma propriedades ou método é declarada com <code>protected</code>, <strong>ela só pode ser acessada dentro dela própria ou por uma classe descendente</strong> (classes que estendem a classe que contem o método protegido).</p>

<p>Declare o método <code>getProperty()</code> como protegido, na classe <code>MyClass</code>, e tente acessá-lo diretamente fora da classe:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou uma propriedade de classe!";

  public function __construct()
  {
      echo 'A classe "', __CLASS__, '" foi iniciada!&lt;br /&gt;';
  }

  public function __destruct()
  {
      echo 'A classe "', __CLASS__, '" foi destruída.&lt;br /&gt;';
  }

  public function __toString()
  {
      echo "Usando o método toString: ";
      return $this-&gt;getProperty();
  }

  public function setProperty($newval)
  {
      $this-&gt;prop1 = $newval;
  }

  protected function getProperty()
  {
      return $this-&gt;prop1 . "&lt;br /&gt;";
  }
}

class MyOtherClass extends MyClass
{
  public function __construct()
  {
      parent::__construct();
      echo "Um novo construtor em " . __CLASS__ . ".&lt;br /&gt;";
  }

  public function newMethod()
  {
      echo "De um novo método na classe " . __CLASS__ . ".&lt;br /&gt;";
  }
}

// Cria um novo objeto
$newobj = new MyOtherClass;

// Tentativa de invocar um método protegido fora da classe
echo $newobj-&gt;getProperty();

?&gt;</pre>

<p>Quando tentar executar esse código, o erro a seguir aparece:</p>

<pre class="brush: php">
A classe "MyClass" foi iniciada!
Um novo construtor em MyOtherClass.

Fatal error: Call to protected method MyClass::getProperty() from context '' in /Applications/XAMPP/xamppfiles/htdocs/testing/test.php on line 55</pre>

<p>Agora, crie um método em <code>MyOtherClass</code> que invoque o método <code>getProperty()</code>:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou uma propriedade de classe!";

  public function __construct()
  {
      echo 'A classe "', __CLASS__, '" foi iniciada!&lt;br /&gt;';
  }

  public function __destruct()
  {
      echo 'A classe "', __CLASS__, '" foi destruída.&lt;br /&gt;';
  }

  public function __toString()
  {
      echo "Usando o método toString: ";
      return $this-&gt;getProperty();
  }

  public function setProperty($newval)
  {
      $this-&gt;prop1 = $newval;
  }

  protected function getProperty()
  {
      return $this-&gt;prop1 . "&lt;br /&gt;";
  }
}

class MyOtherClass extends MyClass
{
  public function __construct()
  {
      parent::__construct();
      echo "Um novo construtor em " . __CLASS__ . ".&lt;br /&gt;";
  }

  public function newMethod()
  {
      echo "De um novo método na classe " . __CLASS__ . ".&lt;br /&gt;";
  }

  public function callProtected()
  {
      return $this-&gt;getProperty();
  }
}

// Cria um novo objeto
$newobj = new MyOtherClass;

// Invoca o método protegido a partir de um método público
echo $newobj-&gt;callProtected();

?&gt;</pre>

<p>E, assim, temos o resultado desejado:</p>

<pre class="brush: php">
A classe "MyClass" foi iniciada!
Um novo construtor em MyOtherClass.
Sou uma propriedade de classe!
A classe "MyClass" foi destruída.</pre>

<h3>Métodos e Propriedades Privadas</h3>

<p>Uma propriedade ou método declarado com <code>private</code> é acessível <strong>somente dentro da classe que os define</strong>. Isso significa que <em>mesmo que se uma classe estender a classe que define uma propriedade privada,</em> aquela propriedade (ou método) não será acessível na classe filha.</p>

<p>Para demonstrar isso, declare <code>getProperty()</code> como privada dentro da classe <code>MyClass</code>, e tente invocar <code>callProtected()</code> da classe<br /><code>MyOtherClass</code>:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou uma propriedade de classe!";

  public function __construct()
  {
      echo 'A classe "', __CLASS__, '" foi iniciada!&lt;br /&gt;';
  }

  public function __destruct()
  {
      echo 'A classe "', __CLASS__, '" foi destruída.&lt;br /&gt;';
  }

  public function __toString()
  {
      echo "Usando o método toString: ";
      return $this-&gt;getProperty();
  }

  public function setProperty($newval)
  {
      $this-&gt;prop1 = $newval;
  }

  private function getProperty()
  {
      return $this-&gt;prop1 . "&lt;br /&gt;";
  }
}

class MyOtherClass extends MyClass
{
  public function __construct()
  {
      parent::__construct();
      echo "Um novo construtor em " . __CLASS__ . ".&lt;br /&gt;";
  }

  public function newMethod()
  {
      echo "De um novo método na classe " . __CLASS__ . ".&lt;br /&gt;";
  }

  public function callProtected()
  {
      return $this-&gt;getProperty();
  }
}

// Cria um novo objeto
$newobj = new MyOtherClass;

// Usa um método da classe pai
echo $newobj-&gt;callProtected();

?&gt;</pre>

<p>Atualize a página no seu navegador e verá o erro a seguir aparecer:</p>

<pre class="brush: php">
A classe "MyClass" foi iniciada!
Um novo construtor em MyOtherClass.

Fatal error: Call to private method MyClass::getProperty() from context 'MyOtherClass' in /Applications/XAMPP/xamppfiles/htdocs/testing/test.php on line 49</pre>

<h3>Métodos e Propriedades Estáticas</h3>

<p>Um método ou propriedade declarada com <code>static</code> podem ser acessados sem, primeiro, instanciar a classe; você pode, simplesmente, usar o nome da classe, o operador de resolução de escopo e o nome da propriedade ou do método.</p>

<blockquote>
<p>"Um dos maiores benefícios de se usar propriedades estáticas é que elas são capazes de manter os valores guardados dentro dela enquanto o arquivo for executado."</p>

</blockquote>

<p>Para demonstrar isso, adicione uma propriedade estática chamada <code>$count</code> e um método estático chamado <code>plusOne()</code> à classe <code>MyClass</code>. Depois, prepare um laço de repetição <code>do...while</code>para mostrar o valor incrementado da proprieade <code>$count</code> enquanto o valor dela for menor que 10:</p>

<pre class="brush: php">
&lt;?php

class MyClass
{
  public $prop1 = "Sou uma propriedade de classe!";

  public static $count = 0;

  public function __construct()
  {
      echo 'A classe "', __CLASS__, '" foi iniciada!&lt;br /&gt;';
  }

  public function __destruct()
  {
      echo 'A classe "', __CLASS__, '" foi destruída.&lt;br /&gt;';
  }

  public function __toString()
  {
      echo "Usando o método toString: ";
      return $this-&gt;getProperty();
  }

  public function setProperty($newval)
  {
      $this-&gt;prop1 = $newval;
  }

  private function getProperty()
  {
      return $this-&gt;prop1 . "&lt;br /&gt;";
  }

  public static function plusOne()
  {
      return "O valor é " . ++self::$count . ".&lt;br /&gt;";
  }
}

class MyOtherClass extends MyClass
{
  public function __construct()
  {
      parent::__construct();
      echo "Um novo construtor em " . __CLASS__ . ".&lt;br /&gt;";
  }

  public function newMethod()
  {
      echo "De um novo método na classe " . __CLASS__ . ".&lt;br /&gt;";
  }

  public function callProtected()
  {
      return $this-&gt;getProperty();
  }
}

do
{
  // Invoca o método plusOne sem instanciar a classe MyClass
  echo MyClass::plusOne();
} while ( MyClass::$count &lt; 10 );

?&gt;</pre>

<p><strong>Nota</strong> — Quando acessar propriedades estáticas, o símbolo de dólar<br />
(<code>$</code>) vem <em>depois do operador de resolução de escopo.</em></p>

<p>Quando atualizar a página do seu navegador, o resultado será:</p>

<pre class="brush: php">
O valor é 1.
O valor é 2.
O valor é 3.
O valor é 4.
O valor é 5.
O valor é 6.
O valor é 7.
O valor é 8.
O valor é 9.
O valor é 10.</pre>

<h2>Comentários com DocBlocks</h2>

<blockquote class="pullquote pqRight">
<p>"O estilo de comentários DocBlock é um<br />
método altamente aceito para documentar classes."</p>

</blockquote>

<p>Enquanto não é uma parte oficial da POO, os comentários <a href="http://en.wikipedia.org/wiki/PHPDoc">DocBlock</a> são um método altamente aceito para documentar classes. Além de prover um padrão para os<br />
desenvolvedores ao escreverem seus códigos, ele também foi adotado pela maioria dos kits de desenvolvimento de software (do inglês, <em>software development kits</em> - SDKs) populares, como o <a href="http://eclipse.org">Eclipse</a> e <a href="http://netbeans.org">NetBeans</a>, e serão usados para gerar dicas de códigos.</p>

<p>Um DocBlock é definido como um bloco de comentário que começa com um asterisco adicional:</p>

<pre class="brush: php">
/**
 * Esse é um DocBlock bem básico
 */</pre>

<p>O verdadeiro poder do DocBlocks vem com a possibilidade de usarmos as <strong>tags</strong>, que começam com o símbolo (<code>@</code>) e são, imediatamente, seguidos dos nome e valor da tag. <strong>As tags do DocBlock permitem aos desenvolvedores definirem os autores de um arquivo, a licença que a classe usa, informações das propriedades e métodos e outras informações úteis.</strong></p>

<p>As tags mais usadas são:</p>

<ul><li><strong>@author</strong>: Os autores do elemento atual (o qual pode ser uma classe, arquivo, método ou qualquer trecho de código) são listados usando essa tag. Múltiplas tags para autores podem ser usadas no mesmo  DocBlock se precisar creditar mais de um autor. O formato para o nome do autor é <code>Erick Patrick &lt;erick.patrick@email.com&gt;</code>.</li>
<li><strong>@copyright</strong>: Isso indica o ano e o nome de quem tem os direitos sobre o elemento atual. O formato é <code>2010 Nome da pessoa</code>.</li>
<li><strong>@license</strong>: Ligamos à licença usada no elemento atual. O formato para a informação da licença é<br /><code>http://www.example.com/path/to/license.txt Nome da licença</code>.</li>
<li><strong>@var</strong>: Isso indica o tipo e a descrição de uma variável ou de uma propriedade de classse. O formato é <code>tipo do elemento descrição</code>.</li>
<li><strong>@param</strong>: Essa tag mostra o tipo e descrição de um parâmetro de uma função ou método. O formato é <code>tipo $nome_do_elemento descrição do elemento</code>.</li>
<li><strong>@return</strong>: O tipo e descrição do valor retornado por uma função ou método. O formato é <code>tipo descrição do valor retornado</code>.</li>
</ul>

<p>Uma classe exemplo, comentada com DocBlocks parece-se com isso:</p>

<pre class="brush: php">
&lt;?php

/**
 * A classe simples
 *
 * Essa é uma descrição longa para essa classe,
 * que pode tomar quantoas linhas quanto precisar. Ela não
 * é necessária, enquanto a versão curta é necessária.
 *
 * Essa descrição também pode tomar vários parágrafos, se a
 * descrição precisar ser tão verbosa.
 *
 * @author Erick Patrick &lt;tutsplus@erickpatrick.net&gt;
 * @copyright 2014 Erick Patrick
 * @license http://www.php.net/license/3_01.txt PHP License 3.01
 */
class SimpleClass
{
  /**
   * Uma variável pública
   *
   * @var string guarda dados para a classe
   */
  public $foo;

  /**
   * Atribui um novo valor a $foo durante a instanciação da classe
   *
   * @param string $val é o valor requerido pela classe
   * @return void
   */
  public function __construct($val)
  {
      $this-&gt;foo = $val;
  }

  /**
   * Multiplica dois inteiros
   *
   * Aceita um par de números inteiros e retorna
   * o produto dos dois.
   *
   * @param int $bat um número a ser multiplicado
   * @param int $baz um número a ser multiplicado
   * @return int o produto dos dois parâmetros
   */
  public function bar($bat, $baz)
  {
      return $bat * $baz;
  }
}

?&gt;</pre>

<p>Uma vez que você dá uma rápida olha na classe acima, os benefícios do  DocBlock tornam-se visíveis: tudo está claramente definido, de forma que o próximo desenvolvedor pode pegar esse código e <em>nunca precisará imagina o que uma certa parte de código faz ou deveria receber.</em></p>

<h2>Comparando Código Orientado a Objetos e Código Procedural</h2>

<p>Não maneira certo ou errada de programar. Isso dito, <strong>essa seção mostrar bons argumentos para adotar a abordagem orientada a objetos no desenvolvimento de software, especialmente em aplicações de grande porte.</strong></p>

<h2>Razão 1: Facilidade de Implementação</h2>

<blockquote class="pullquote pqRight">
<p>"Embora, inicialmente, pareça complicada, POO prover uma abordagem mais fácil para lidar com dados."</p>

</blockquote>

<p>Embora, inicialmente, pareça complicada, POO prover uma abordagem mais fácil para lidar com dados. Uma vez que objetos podem guardar dados internamento, variáveis não precisam ser passadas para funções para que elas funcionem corretamente.</p>

<p>E como <em>várias instâncias de uma mesma classe podem existir simultanemanete</em>, lidar com conjuntos de dados grandes se torna infinitamente mais fácil. Por exemplo, imagine que há informações de duas pessoas sendo processadas ao mesmo tempo em um arquivo. Elas precisam de nomes, ocupações e idades.</p>

<h3>A Abordagem Procedural</h3>

<p>Eis a abordagem procedural para nosso exemplo:</p>

<pre class="brush: php">
&lt;?php

function changeJob($person, $newjob)
{
  $person['job'] = $newjob; // Muda o emprego da pessoa
  return $person;
}

function happyBirthday($person)
{
  ++$person['age']; // Adiciona 1 à idade da pessoa
  return $person;
}

$person1 = array(
  'name' =&gt; 'Tom',
  'job' =&gt; 'Button-Pusher',
  'age' =&gt; 34
);

$person2 = array(
  'name' =&gt; 'John',
  'job' =&gt; 'Lever-Puller',
  'age' =&gt; 41
);

// Mostra os valores iniciais das pessoas
echo "&lt;pre&gt;Person 1: ", print_r($person1, TRUE), "&lt;/pre&gt;";
echo "&lt;pre&gt;Person 2: ", print_r($person2, TRUE), "&lt;/pre&gt;";

// Tom foi promovido e fez aniversário
$person1 = changeJob($person1, 'Box-Mover');
$person1 = happyBirthday($person1);

// John fez aniversário também
$person2 = happyBirthday($person2);

// Mostra os novos valores das pessoas
echo "&lt;pre&gt;Person 1: ", print_r($person1, TRUE), "&lt;/pre&gt;";
echo "&lt;pre&gt;Person 2: ", print_r($person2, TRUE), "&lt;/pre&gt;";

?&gt;</pre>

<p>Quando executado, o código mostrará o seguinte:</p>

<pre class="brush: php">
Person 1: Array
(
  [name] =&gt; Tom
  [job] =&gt; Button-Pusher
  [age] =&gt; 34
)
Person 2: Array
(
  [name] =&gt; John
  [job] =&gt; Lever-Puller
  [age] =&gt; 41
)
Person 1: Array
(
  [name] =&gt; Tom
  [job] =&gt; Box-Mover
  [age] =&gt; 35
)
Person 2: Array
(
  [name] =&gt; John
  [job] =&gt; Lever-Puller
  [age] =&gt; 42
)</pre>

<p>Apesar disso não estar tão ruim, tem muita coisa a ser lembrada de uma só vez. <strong>O conjunto de atributos da pessoa que foi afetado tem de ser passado e retornado de cada invocação de função</strong>, e isso possibilita o aparecimento de erros.</p>

<p>Para limpar esse exemplo, seria desejável <strong>deixe o mínimo com o programador quanto possível.</strong> Só a informação extremamente essencial para a operação atual é necessária ser passada para as funções.</p>

<p><strong>É aqui que a POO entra e ajuda você a ajustar as coisas.</strong></p>

<h3>A Abordagem POO</h3>

<p>Here's the OOP approach to our example:</p>

<pre class="brush: php">
&lt;?php

class Person
{
  private $_name;
  private $_job;
  private $_age;

  public function __construct($name, $job, $age)
  {
      $this-&gt;_name = $name;
      $this-&gt;_job = $job;
      $this-&gt;_age = $age;
  }

  public function changeJob($newjob)
  {
      $this-&gt;_job = $newjob;
  }

  public function happyBirthday()
  {
      ++$this-&gt;_age;
  }
}

// Create two new people
$person1 = new Person("Tom", "Button-Pusher", 34);
$person2 = new Person("John", "Lever Puller", 41);

// Output their starting point
echo "&lt;pre&gt;Person 1: ", print_r($person1, TRUE), "&lt;/pre&gt;";
echo "&lt;pre&gt;Person 2: ", print_r($person2, TRUE), "&lt;/pre&gt;";

// Give Tom a promotion and a birthday
$person1-&gt;changeJob("Box-Mover");
$person1-&gt;happyBirthday();

// John just gets a year older
$person2-&gt;happyBirthday();

// Output the ending values
echo "&lt;pre&gt;Person 1: ", print_r($person1, TRUE), "&lt;/pre&gt;";
echo "&lt;pre&gt;Person 2: ", print_r($person2, TRUE), "&lt;/pre&gt;";

?&gt;</pre>

<p>This outputs the following in the browser:</p>

<pre class="brush: php">
Person 1: Person Object
(
  [_name:private] =&gt; Tom
  [_job:private] =&gt; Button-Pusher
  [_age:private] =&gt; 34
)

Person 2: Person Object
(
  [_name:private] =&gt; John
  [_job:private] =&gt; Lever Puller
  [_age:private] =&gt; 41
)

Person 1: Person Object
(
  [_name:private] =&gt; Tom
  [_job:private] =&gt; Box-Mover
  [_age:private] =&gt; 35
)

Person 2: Person Object
(
  [_name:private] =&gt; John
  [_job:private] =&gt; Lever Puller
  [_age:private] =&gt; 42
)</pre>

<p>There's a little bit more setup involved to make the approach object oriented, but after the class is defined, creating and modifying people is a breeze; <strong>a person's information does not need to be passed or returned from methods, and only absolutely essential information is passed to each method.</strong></p>

<blockquote class="pullquote pqRight">
<p>"OOP will significantly reduce your workload if implemented properly."</p>

</blockquote>

<p>On the small scale, this difference may not seem like much, but as your applications grow in size, OOP will significantly reduce your workload if implemented properly.</p>

<p><strong>Tip</strong> — <em>Not everything needs to be object oriented.</em> A quick function that handles something small in one place inside the application does not necessarily need to be wrapped in a class. Use your best judgment when deciding between object-oriented and procedural approaches.</p>

<h2>Reason 2: Better Organization</h2>

<p>Another benefit of OOP is how well it lends itself to being <strong>easily packaged and cataloged.</strong> Each class can generally be kept in its own separate file, and if a uniform naming convention is used, accessing the classes is extremely simple.</p>

<p>Assume you've got an application with 150 classes that are called dynamically through a controller file at the root of your application filesystem. All 150 classes follow the naming convention <code>class.classname.inc.php</code> and reside in the <code>inc</code> folder of your application.</p>

<p>The controller can implement PHP's <code>__autoload()</code> function to dynamically pull in only the classes it needs as they are called, rather than including all 150 in the controller file just in case or coming up with some clever way of including the files in your own code:</p>

<pre class="brush: php">
&lt;?php
  function __autoload($class_name)
  {
      include_once 'inc/class.' . $class_name . '.inc.php';
  }
?&gt;</pre>

<p>Having each class in a separate file also makes code more portable and easier to reuse in new applications without a bunch of copying and pasting.</p>

<h2>Reason 3: Easier Maintenance</h2>

<p>Due to the more compact nature of OOP when done correctly, <strong>changes in the code are usually much easier to spot</strong> and make than in a long spaghetti code procedural implementation.</p>

<p>If a particular array of information gains a new attribute, a procedural piece of software may require (in a worst-case scenario) that the new attribute be added to each function that uses the array.</p>

<p>An OOP application could potentially be updated as easily adding the new property and then adding the methods that deal with said property.</p>

<p>A lot of the benefits covered in this section are the product of <strong>OOP in combination with DRY programming practices.</strong> It is definitely possible to create easy-to-maintain procedural code that doesn't cause nightmares, and it is equally possible to create awful object-oriented code. [<em>Pro PHP and  jQuery</em>] will attempt to demonstrate a combination of good coding habits in conjunction with OOP to generate clean code that's easy to read and maintain.</p>

<h2>Summary</h2>

<p>At this point, you should feel comfortable with the object-oriented programming style. Learning OOP is a great way to take your programming to that next level. When implemented properly, OOP will help you produce easy-to-read, easy-to-maintain, portable code that will save you (and the developers who work with you) hours of extra work. Are you stuck on something that wasn't covered in this article? Are you already using OOP and have some tips for beginners? Share them in the comments!</p>

<p><strong>Author's Note</strong> — This tutorial was an excerpt from <a href="http://www.amazon.com/gp/product/1430228474?ie=UTF8&amp;tag=ennudesi-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=1430228474">Pro PHP and jQuery</a> (Apress, 2010).</p>
