<h1>SOLID: Part 2 - The Open/Closed Principle</h1>

<p><a href="http://code.tutsplus.com/pt/tutorials/solid-part-1-the-single-responsibility-principle--net-36074">Responsabilidade Única (SRP - Single Responsability)</a>, Aberto para Expansão, Fechado para Modificações (Open/Close); Substituição de Liskov (Liskov's Substitution); Segregação de Interface (Interface Segregation); e Inversão de Dependência (Dependency Inversion). Cinco princípios ágeis que deveriam guiar você todas as vezes que fosse programar.</p>

<h2>Definição</h2>

<blockquote>
	<p>Entidades de software (classes, módulos, funções, etc) devem ser abertas para expansão, porém, fechadas para modificações.</p>
</blockquote>

<p>O princípior do Aberto para Expansão, fechado para Modificação (The Open/Closed Principle - OCP), é creditado a <a href="http://en.wikipedia.org/wiki/Bertrand_Meyer">Bertrand Mayer</a>, programador francês, publicando, primeiramente, em seu livro <a href="http://www.amazon.com/Object-Oriented-Software-Construction-CD-ROM-Edition/dp/0136291554">Object-Oriented Software Construction</a>, de 1988.</p>

<p>Esse princípio cresceu em popularidade no começo dos anos 2000 quando ele passou a integrar os princípios SOLID, definido por <a href="http://www.8thlight.com/our-team/robert-martin">Robert C. Martin</a> em seu livro <a href="http://www.amazon.com/Software-Development-Principles-Patterns-Practices/dp/0135974445/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1378755964&amp;sr=1-1&amp;keywords=robert+c+martin">Agile Software Development, Principles, Patterns, and Practices</a> e, mais tarde, republicado na versão em C# do mesmo livro <a href="http://www.amazon.com/Agile-Principles-Patterns-Practices-C/dp/0131857258">Agile Principles, Patterns, and Practices in C#</a>.</p>

<p>Basicamente, o que estamos falando aqui é sobre projetar nossos módulos, classes e funções, de forma que, quando uma nova funcionalidade for necessária, nós não deveríamos modificar o código existente, mas criar novo código que será usado pelo código atual. Isso parece um pouco estranho, especialmente se você vem de linguagens como o Java, C, C++ ou C# onde isso se aplica, não só ao código fonte em si, mas, também, ao código compilado. Nós queremos criar novas funcionalidades de forma que não seja necessário reimplantar nossos binários, executáveis ou DLLs existentes.</p>

<h2>OCP no contexto dos Princípios SOLID</h2>

<p>De acordo com que avançamos com esses tutoriais, podemos trabalhar os novos princípios nos contextos daqueles já discutidos. Nós já discutimos sobre o <a href="http://code.tutsplus.com/pt/tutorials/solid-part-1-the-single-responsibility-principle--net-36074">Princípio da Responsabilidade Única (SRP)</a>, que afirmou que um módulo deve ter, apenas, um único motivo para mudar. Se pensarmos no COP e no SRP, podemos observar que eles são complementares. Códigos projetados com o SRP em mente estarão bem próximos de seguir o OCP ou será bem fácil fazê-los respeitar esse princípio. Quando tempos código que tem, somente, uma razao para mudar, introduzir uma nova funcionalidade gerará uma segunda razão para mudança. Então, tanto o SRP quanto o OCP seriam violados. Da mesma forma, se tivermos código que só será alterado quando sua função principal muda e mantem-se inalterado quando novas funcionalidades são adicionadas, ele respeita o OCP e, muito provavelmente, respeitará o SRP também.</p>

<p>Isso não quer dizer que um código que segue o SRP sempre permitirá seguir o OCP ou vice e versa, mas, na maioria dos casos, se um deles é respeitado, conseguir respeitar o outro se torna bem simples.</p>

<h2>O Exemplo Óbvio de Violação do OCP</h2>

<p>De um ponto de vista, puramente, técnico, o princípio do Aberto para Extensão, Fechado para Modificação, é bem simples. Um relacionamento entre duas classes, como o que vemos logo abaixo, viola o OCP.</p>

<figure>
<img width="600" alt="violate1" src="http://cdn.tutsplus.com/net/uploads/2014/01/violate1.png" height="109"><br>
</figure>

<p>A classe <code>User</code> usa a classe <code>Logic</code> diretamente. Se precisarmos implementar uma segunda classe <code>Logic</code>, de forma que permita usar ambas as classes, atual e nova, a classe <code>Logic</code> já existente precisará mudar. <code>User</code> é diretamente ligado à implementação de <code>Logic</code>, não há outra maneira de prover uma nova classe <code>Logic</code> sem afetar a atual. E, quando falamos de linguagens fortemente tipadas, é bem possível que a classe <code>User</code> também necessite de mudanças. Se estamos falando de linguagens compiladas, é quase certo que tanto o executável, ou biblioteca dinâmica, de <code>User</code> quanto de <code>Logic</code> precisarão ser recompilados e reimplantados em nossos clientes. Um processo que queremos evitar a todo custo.</p>

<h2>Mostre-me o Código</h2>

<p>Baseado somente no esquema acima, alguém pode deduzir que qualquer classe usando diretamente outra, na verdade, viola o OCP. E isso é verdade, estrutamente falando. Percebi que é bem interessante encontrar os limites, o momento que você cria a linha e decide que é mais difícil respeitar o OCP que modificar o código existente, ou que o custo arquitetural não justifica o custo da mudança do código existente.</p>

<p>Vamos criar uma classe que provê o progresso de download de um arquivo, na forma de percentual, dentro de nossa aplicação. Nós termos duas classes principais, a classe <code>Progress</code> e a <code>File</code>, e, creio eu, que queiramos usá-las de acordo com o teste abaixo.</p>

<pre class="brush: php">function testItCanGetTheProgressOfAFileAsAPercent() {
	$file = new File();
	$file-&gt;length = 200;
	$file-&gt;sent = 100;

	$progress = new Progress($file);

	$this-&gt;assertEquals(50, $progress-&gt;getAsPercent());
}</pre>

<p>Nesse teste, somos um usuário da classe <code>Progress</code>. Queremos obter o valor como percentual, independente do tamanho real do arquivo. Usamos a classe <code>File</code> como fonte de informação para a classe <code>Progress</code>. Um arquivo tem um tamanho em bytes e um campo chamado <code>sent</code>, representando a quantidade de dados que já foi enviada para download. Não precisamos nos preocupar sobre como esses valores são atualizados na aplicação. Nós só precisamos acreditar que há uma mágica que faça essa lógica por nós, para que, em um teste, possamos atribuí-los manualmente.</p>

<pre class="brush: php">class File {
	public $length;
	public $sent;
}</pre>

<p>A classe <code>File</code> é só um objeto de dados com duas propriedades. Claramente, na vida real, ela conteria outras informações e comportamentos, como o nome do arquivo, os caminhos real e relativo, diretório atual, tipo, permissões e por aí vai.</p>

<pre class="brush: php">class Progress {

	private $file;

	function __construct(File $file) {
		$this-&gt;file = $file;
	}

	function getAsPercent() {
		return $this-&gt;file-&gt;sent * 100 / $this-&gt;file-&gt;length;
	}

}</pre>

<p>A classe <code>Progress</code> é bem simples e injeta uma classe <code>File</code> através de seu construtor. Para ficar claro, nós especificamos o tipo da variável nos parâmetros do construtor (injetamos uma variável daquele tipo em específico). Há um único método útil na classe <code>Progress</code>, o <code>getAsPercent()</code>, que pegará os valores que foram enviados e o tamanho do arquivo, contidos nas propriedades da classe <code>File</code>, e os transformará em percentual. Simples e funciona.</p>

<pre class="brush: bash">Testing started at 5:39 PM ...
PHPUnit 3.7.28 by Sebastian Bergmann.
.
Time: 15 ms, Memory: 2.50Mb
OK (1 test, 1 assertion)</pre>

<p>O código parece correto, porém, ele viola o OCP. Mas, por que? E como?</p>

<h2>Mudança de Requerimentos</h2>

<p>Toda aplicação a qual se esperar crescer, com o tempo será adicionada novas funcionalidades. Uma das novas funcionalidades da nossa aplicação poderia ser o *streaming* de músicas, ao invés do download dos arquivos. O tamanho de um arquivo, sendo visto através da classe <code>File</code>, é representado em bytes e a duração da música em segundos. Nós queremos oferecer uma barra de progresso bem bacana, mas, será que podemos reusar aquela que já tempos?</p>

<p>Não, não podemos. Nossa barra de progresso está atrelada à classe <code>File</code>. Ela só entende arquivos, embora ela pudesse ser usada com conteúdo musical também. Mas, para tornar isso possível, precisamos modificá-la, precisamos fazer com que a classe <code>Progress</code> tenha conhecimento tanto da classe <code>Music</code> quanto da <code>File</code>. Se nosso projeto respeitasse o OCP, não precisaríamos tocar na classe <code>File</code> ou na <code>Progress</code>. Nós, simplesmente, reusaríamos a classe <code>Progress</code> existente e a aplicaríamos para a classe <code>Music</code>.</p>

<h2>Solução 1: Lançar Mão da Natureza Dinâmica do PHP</h2>

<p>Linguagens fracamente tipadas tem a vantagem de descobrir os tipos dos objetos em tempo de execução. Isso permite que removamos a dica do tipo de objeto que esperamos receber no construtor da classe <code>Progress</code> e ainda permitir que o código funcione.</p>

<pre class="brush: php">class Progress {

	private $file;

	function __construct($file) {
		$this-&gt;file = $file;
	}

	function getAsPercent() {
		return $this-&gt;file-&gt;sent * 100 / $this-&gt;file-&gt;length;
	}

}</pre>

<p>Agora, podemos enviar qualquer coisa para a classe <code>Progress</code>. E, por qualquer coisa, quero dizer qualquer coisa, mesmo:</p>

<pre class="brush: php">class Music {

	public $length;
	public $sent;

	public $artist;
	public $album;
	public $releaseDate;

	function getAlbumCoverFile() {
		return 'Images/Covers/' . $this-&gt;artist . '/' . $this-&gt;album . '.png';
	}
}</pre>

<p>E uma classe <code>Music</code> como a que vemos acima, funcionará como esperado. Podemos testá-la, criando um teste bem parecido ao teste que criamos para a classe <code>File</code>.</p>

<pre class="brush: php">function testItCanGetTheProgressOfAMusicStreamAsAPercent() {
	$music = new Music();
	$music-&gt;length = 200;
	$music-&gt;sent = 100;

	$progress = new Progress($music);

	$this-&gt;assertEquals(50, $progress-&gt;getAsPercent());
}</pre>

<p>Então, basicamente, qualquer conteúdo mensurável pode ser usado com a classe <code>Progress</code>. Talvez devessemos demonstrar isso no código, alterando o nome da variável em nossa classe:</p>

<pre class="brush: php">class Progress {

	private $measurableContent;

	function __construct($measurableContent) {
		$this-&gt;measurableContent = $measurableContent;
	}

	function getAsPercent() {
		return $this-&gt;measurableContent-&gt;sent * 100 / $this-&gt;measurableContent-&gt;length;
	}

}</pre>

<p>Certo, mas temos um problema enorme com essa abordagem. Quando especificamos (induzimos o tipo) a classe <code>File</code> nos parâmetros do construtor, nós sabiamos com o que nossa classe era capaz de lidar. Era tudo explícito e se qualquer outra coisa surgisse, um erro nos avisaria.</p>

<pre class="brush: bash">Argument 1 passed to Progress::__construct()
must be an instance of File,
instance of Music given.</pre>

<p>Mas, sem a indução de tipo, nós dependemos no fato de que, qualquer coisa que vier, deverá ter duas variáveis públicas, chamadas de "<code>length</code>" e "<code>sent</code>". De outro modo, nós teremos uma quebra de contrato.</p>

<blockquote><p>Quebra de contrato: uma classe que sobrescreve um método da classe mãe, de forma que o contrato da classe mãe não é honrado pela classe filha. ~Source Wikipedia.</p>
</blockquote>
<p>Esse é um dos <em>sintomas</em> apresentados em mais detalhes no curso premium <a href="https://tutsplus.com/course/detecting-code-smells/">Detecting Code Smells</a>. Resumindo, nós não queremos acabar invocando métodos ou acessando atributos em objetos que não obedece nosso contrato. Quando tínhamos uma indução de tipos, o contrato era especificado por ele. Os campos emetodos da classe <code>File</code>. Agora, que temos nada, nós podemos enviar qualquer coisa, até mesmo uma cadeia de caracteres (<em>string</em>) e resultaria num erro grotesco.</p>

<pre class="brush: php">function testItFailsWithAParameterThatDoesNotRespectTheImplicitContract() {
	$progress = new Progress('some string');
	$this-&gt;assertEquals(50, $progress-&gt;getAsPercent());
}</pre>

<p>Um teste como esses, onde enviamos uma simples cadeia de caracteres, será uma quebra de contrato:</p>

<pre class="brush: bash">Tentando obter uma propriedade de um não-objeto.</pre>

<p>Enquanto o resultado final é igual em ambos os casos, significando uma falha no código, o primeiro produz uma mensagem legal. Esse, por outro lado, é bem obscuro. Não há como saber o que a variável é - uma cadeia de caracteres, em nosso caso - e quais propriedades não foram encontradas. É difícil de depurar e resolver o problema. Um programador precisa abrir a classe <code>Progress</code>, lê-la e entendê-la. O contrato, nesse caso, quando não especificamos explícitamente a indução de tipo, é definida pelo comportamento da classe <code>Progress</code>. É um contrato implícito, sabido somente pela classe <code>Progress</code>. Em nosso exemplo, ele é definido pelo acesso aos dois atributos, <code>sent</code> e <code>length</code>, no método <code>getAsPercent()</code>. Na vidade real, o contrato implícito pode ser bem complexo e difícil de descobrir só dando uma olhada na classe em questão.</p>

<p>Essa solução só é recomendada se nenhuma das outras sugestões abaixo forem fáceis de implementar ou se elas causarem mudanças arquiteturais muito grandes, que não justificassem o esforço.</p>

<h2>Solução 2: Use o Padrão de Design <em>Strategy</em></h2>

<p>Essa é a solução mais comum e, provavelmente, a solução mais apropriada para respeitar a OCP. É simples e efetiva.</p>

<figure>
<img width="600" alt="strategy" src="http://cdn.tutsplus.com/net/uploads/2014/01/strategy.png" height="294"><br>
</figure>

<p>O padrão <em>Strategy</em>, simplesmente, introduz o uso de uma interface. Uma interface é um tipo especial de entidade da Programação Orientada a Objetos (POO), que define um contrato entre uma classe cliente e uma classe servidora. Ambas as classes aderirão ao contrato para garantir o comportamento esperado. Pode haver inúmeras classes servidoras não relacionadas que respeitam o mesmo contrato e, assim, sendo capazes de servir à mesma classe cliente.</p>

<pre class="brush: php">interface Measurable {
	function getLength();
	function getSent();
}</pre>

<p>In an interface we can define only behavior. That is why instead of directly using public variables we will have to think about using getters and setters. Adapting the other classes will not be difficult at this point. Our IDE can do most of the job.</p>

<pre class="brush: php">function testItCanGetTheProgressOfAFileAsAPercent() {
	$file = new File();
	$file-&gt;setLength(200);
	$file-&gt;setSent(100);

	$progress = new Progress($file);

	$this-&gt;assertEquals(50, $progress-&gt;getAsPercent());
}</pre>

<p>As usual, we start with our tests. We will need to use setters to set the values. If considered mandatory, these setters may also be defined in the <code>Measurable</code> interface. However, be careful what you put there. The interface is to define the contract between the client class <code>Progress</code> and the different server classes like <code>File</code> and <code>Music</code>. Does <code>Progress</code> need to set the values? Probably not. So the setters are highly unlikely to be needed to be defined in the interface. Also, if you would define the setters there, you would force all of the server classes to implement setters. For some of them, it may be logical to have setters, but others may behave totally differently. What if we want to use our <code>Progress</code> class to show the temperature of our oven? The <code>OvenTemperature</code> class may be initialized with the values in the constructor, or obtain the information from a third class. Who knows? To have setters on that class would be odd.</p>

<pre class="brush: php">class File implements Measurable {

	private $length;
	private $sent;

	public $filename;
	public $owner;

	function setLength($length) {
		$this-&gt;length = $length;
	}

	function getLength() {
		return $this-&gt;length;
	}

	function setSent($sent) {
		$this-&gt;sent = $sent;
	}

	function getSent() {
		return $this-&gt;sent;
	}

	function getRelativePath() {
		return dirname($this-&gt;filename);
	}

	function getFullPath() {
		return realpath($this-&gt;getRelativePath());
	}

}</pre>

<p>The <code>File</code> class is modified slightly to accommodate the requirements above. It now implements the <code>Measurable</code> interface and has setters and getters for the fields we are interested in. <code>Music</code> is very similar, you can check its content in the attached source code. We are almost done.</p>

<pre class="brush: php">class Progress {

	private $measurableContent;

	function __construct(Measurable $measurableContent) {
		$this-&gt;measurableContent = $measurableContent;
	}

	function getAsPercent() {
		return $this-&gt;measurableContent-&gt;getSent() * 100 / $this-&gt;measurableContent-&gt;getLength();
	}

}</pre>

<p><code>Progress</code> also needed a small update. We can now specify a type, using typehinting, in the constructor. The expected type is <code>Measurable</code>. Now we have an explicit contract. <code>Progress</code> can be sure the accessed methods will be always present because they are defined in the <code>Measurable</code> interface. <code>File</code> and <code>Music</code> can also be sure they can provide all that is needed for <code>Progress</code> by simply implementing all the methods on the interface, a requirement when a class implements an interface.</p>

<p>This design pattern is explained in greater detail in the <a href="https://tutsplus.com/course/agile-design-patterns/">Agile Design Patterns</a> course.</p>

<h3>A Note on Interface Naming</h3>
<p>People tend to name interfaces with a capital <code>I</code> in front of them, or with the word "<code>Interface</code>" attached at the end, like <code>IFile</code> or <code>FileInterface</code>. This is an old-style notation imposed by some outdated standards. We are so much past the Hungarian notations or the need to specify the type of a variable or object in its name in order to easier identify it. IDEs identify anything in a split second for us. This allows us to concentrate on what we actually want to abstract.</p>

<p>Interfaces belong to their clients. Yes. When you want to name an interface you must think of the client and forget about the implementation. When we named our interface Measurable we did so thinking about Progress. If I would be a progress, what would I need to be able to provide the percent? The answer is simple, something we can measure. Thus the name Measurable. </p>

<p>Another reason is that the implementation can be from various domains. In our case, there are files and music. But we may very well reuse our <code>Progress</code> in a racing simulator. In that case, the measured classes would be Speed, Fuel, etc. Nice, isn't it?</p>

<h2>Solution 3: Use the Template Method Design Pattern</h2>

<p>The Template Method design pattern is very similar to the strategy, but instead of an interface it uses an abstract class. It is recommended to use a Template Method pattern when we have a client very specific to our application, with reduced reusability and when the server classes have common behavior.</p>

<figure>
<img width="600" alt="template_method" src="http://cdn.tutsplus.com/net/uploads/2014/01/template_method.png" height="294"><br>
</figure>

<p>This design pattern is explained in greater detail in the <a href="https://tutsplus.com/course/agile-design-patterns/">Agile Design Patterns</a> course.</p>

<h2>A Higher Level View</h2>

<p>So, how is all of this affecting our high level architecture?</p>

<figure>
<img width="600" alt="HighLevelDesign" src="http://cdn.tutsplus.com/net/uploads/2014/01/HighLevelDesign.png" height="388"><br>
</figure>

<p>If the image above represents the current architecture of our application, adding a new module with five new classes (the blue ones) should affect our design in a moderate way (red class).</p>

<figure>
<img width="600" alt="HighLevelDesignWithNewClasses" src="http://cdn.tutsplus.com/net/uploads/2014/01/HighLevelDesignWithNewClasses.png" height="410"><br>
</figure>

<p>In most systems you can't expect absolutely no effect on the existing code when new classes are introduced. However, respecting the Open/Closed Principle will considerably reduce the classes and modules that require constant change. </p>

<p>As with any other principle, try not to think about everything from before. If you do so, you will end up with an interface for each of your classes. Such a design will be hard to maintain and understand. Usually the safest way to go is to think about the possibilities and if you can determine whether there will be other types of server classes. Many times you can easily imagine a new feature or you can find one on the project's backlog that will produce another server class. In those cases, add the interface from the beginning. If you can not determine, or if you are unsure - most of the time - simply omit it. Let the next programmer, or maybe even yourself, to add the interface when you need a second implementation.</p>

<h2>Final Thoughts</h2>

<p>If you follow your discipline and add interfaces as soon as a second server is needed, modifications will be few and easy. Remember, if code required changes once, there is a high possibility it will require change again. When that possibility turns into reality, OCP will save you a lot of time and effort.</p>

<p>Thank you for reading.</p>
