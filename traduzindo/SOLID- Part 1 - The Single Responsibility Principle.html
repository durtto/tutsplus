<h1>Princípios SOLID Parte 1 - O Princípio da Responsabilidade Única</h1>

<p>Responsabilidade Única (SRP - Single Responsability), Aberto/Fechado (Open/Close), Substituição de Liskov (Liskov's Substitution), Segredação de Interface (Interface Segregation), e Inversão de Dependência (Dependency Inversion). Cinco princípios ágeis que deveriam guiar você todas as vezes que fosse programar.</p>

<h2>A Definição</h2>

<blockquote>
<p>Uma classe só deveria ter um único motivo para mudar.</p>
</blockquote>

<p>Definido por <a href="http://www.8thlight.com/our-team/robert-martin">Robert C. Martin</a> em seu livro <a href="http://www.amazon.com/Software-Development-Principles-Patterns-Practices/dp/0135974445/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1378755964&amp;sr=1-1&amp;keywords=robert+c+martin">Agile Software Development, Principles, Patterns, and Practices</a> e, depois, republicado na versão com C# do mesmo livro, <a href="http://www.amazon.com/Agile-Principles-Patterns-Practices-C/dp/0131857258">Agile Principles, Patterns, and Practices in C#</a>, é um dos princípios ágeis de programação, conhecidos como princípios SOLID. O que ele afirma é bem simples, porém, alcançar essa simplicidade pode ser bem problemático. Uma classe só deveria ter um único motivo para mudar.</p>

<p>Mas, por que? Por que é tão importante ter apenas um único motivo para mudar?</p>

<p>Em linguagens compiladas e fortemente tipadas, há muitos motivos que podem levar a muitas reimplantações indesejadas. Se há dois motivos diferentes para uma mudança, é aceitável que duas equipes diferentes possam trabalhar no mesmo código por motivos diferentes. Cada uma terá de implantar sua solução, o que, no caso de linguagens compiladas (como C++, C# ou Java), pode causar imcompatibilidade de módulos com módulos criados por outras equipes ou de outras partes da aplicação.</p>

<p>Mesmo que você não use uma linguagem compilada, talvez tenha de retestar uma mesma classe ou módulo por diferentes motivos. Isso implica em mais tempo, esforço, recursos e trabalho.</p>


<h2>A Audiêcia</h2>

<p>Determinar a única responsabilidade de uma classe ou módulo, é muito mais complexo que, simplesmente, verificar uma lista pré-determianda. Por exemplo, uma dica para encontrarmos as razões para mudanças é verificar o audiência da nossa classe. Os usuários da aplicação ou sistema que desenvolvemos é que requisitarão mudanças para ela. Aqueles que usam que pedirão mudanças. Eis alguns módulos e suas possíveis audiências.</p>

<ul>
<li><strong>Módulo de Persistência</strong> - Pode incluir os DBAs e arquitetos de software;</li>
<li><strong>Módulo de Relatório</strong> - Pode incluir os contadores, secretários e operadores;</li>
<li><strong>Módulo de Computação de Pagamento para um Sistema de Pagamento</strong> - pode incluir os advogados, administradores e contadores;</li>
<li><strong>Módulo de Busca de Livros para um Sistema de Administração de Biblioteca</strong> - Pode incluir os bibliotecários e/ou os próprios clientes.</li>
</ul>

<h2>Atores e Papéis</h2>

<p>Associar pessoas reais a todas os papéis pode ser difícil. Em uma pequena empresa, uma única pessoa pode ter de satisfazer vários papéis, enquanto em uma empresa maior, pode ter várias pessoas alocadas para um mesmo papel. Assim, faz bastante sentido pensar sobre esses papéis. Mas os papéis em si são um pouco difíceis de definir. O que é um papel? Como o encontramos? É muito mais fácil pensar em pessoas realizando determinados papéis e associa-los à nossa audiência.</p>

<p>Assim, se nossa audiência define os motivos para as mudanças, os atores definem a audiência. Isso nos ajuda a reduzir os conceitos de pessoas como "John o arquiteto" em Arquitetura, ou "Maria a Diretora" em Gerência.</p>

<blockquote>
<p>Então, uma responsabilidade é um conjunto de funções que serve um ator em particular. (Robert C. Martin)</p>
</blockquote>

<h2>Fonte da Mudança</h2>

<p>Seguindo esse raciocínio, os atores tornam-se a fonte da mudança para a família de funções que os servem. De acordo que suas necessidades mudam, aquela família de funções também deve mudar para adaptar-se às suas necessidades.</p>

<blockquote>
<p>O ator de uma responsabilidade é a única fonte de mudança para aquela responsabilidade. (Robert C. Martin)</p>
</blockquote>

<h2>Exemplos Clássicos</h2>

<h3>Objetos que Podem "Imprimir" a Si Mesmos</h3>

<p>Digamos que temos uma classe <code>Book</code> encapsulando o coneito de um livro e suas funcionalidades.</p>

<pre class="brush: php">class Book {

	function getTitle() {
		return "Um ótimo livro";
	}

	function getAuthor() {
		return "John Doe";
	}

	function turnPage() {
		// ponteiro para a próxima página
	}

	function printCurrentPage() {
		echo "conteúdo da página atual";
	}
}</pre>

<p>Essa classe parece bem razoável. Nós temos um livro, ele tem o seu título, autor e também pode passar as páginas. Finalmente, ele também é capaz de imprimir o conteúdo da página atual na tela. Mas, há um pequeno problema. Se pensarmos um pouco nos atores envolvidos na operação de um objeto do tipo <code>Book</code>, quem eles seriam? Nós podemos pensar, facilmente, em dois atores diferentes: Administração de Livros (como o bibliotecário) e o Mecanismo de Apresentação de Dados (como o método que desejamos enviar o conteúdo para o usuário - tela, interface gráfica, interface textual, talvez impressão). Eles são dois atores bem diferentes.</p>

<p>Misturar lógica de negócios com apresentação é ruim porque é contra O Princío da Responsabilidade Única. Veja o código a seguir:</p>

<pre class="brush: php">class Book {

	function getTitle() {
		return "Um ótimo livro";
	}

	function getAuthor() {
		return "John Doe";
	}

	function turnPage() {
		// ponteiro para a próxima página
	}

	function getCurrentPage() {
		return "conteúdo da página atual";
	}

}

interface Printer {

	function printPage($page);
}

class PlainTextPrinter implements Printer {

	function printPage($page) {
		echo $page;
	}

}

class HtmlPrinter implements Printer {

	function printPage($page) {
		echo '&lt;div style="single-page"&gt;' . $page . '&lt;/div&gt;';
	}

}</pre>

<p>Even this very basic example shows how separating presentation from business logic, and respecting SRP, gives great advantages in our design's flexibility.</p>

<h3>Objects That Can "Save" Themselves</h3>

<p>A similar example to the one above is when an object can save and retrieve itself from presentation.</p>

<pre class="brush: php">class Book {

	function getTitle() {
		return "Um ótimo livro";
	}

	function getAuthor() {
		return "John Doe";
	}

	function turnPage() {
		// ponteiro para a próxima página
	}

	function getCurrentPage() {
		return "conteúdo da página atual";
	}

	function save() {
		$filename = '/documents/'. $this-&gt;getTitle(). ' - ' . $this-&gt;getAuthor();
		file_put_contents($filename, serialize($this));
	}

}</pre>

<p>Nós podemos, novamente, identificar vários atores, como o Sistema de Administração de Livros e a Persitência de Dados. Toda vez que precisamos mudar a persistência, precisaremos mudar essa classe. Toda vez que precisamos mudar de página, precisaremos mudar essa classe. Há vários focos que permitem mudança.</p>

<pre class="brush: php">class Book {

	function getTitle() {
		return "Um ótimo livro";
	}

	function getAuthor() {
		return "John Doe";
	}

	function turnPage() {
		// ponteiro para a próxima página
	}

	function getCurrentPage() {
		return "conteúdo da página atual";
	}

}

class SimpleFilePersistence {

	function save(Book $book) {
		$filename = '/documents/' . $book-&gt;getTitle() . ' - ' . $book-&gt;getAuthor();
		file_put_contents($filename, serialize($book));
	}

}</pre>

<p>Movendo a operação de persistência para outra classe, irá, claramente, separar as responsabilidades e estaremos livres para alterar os métodos de persistência sem afetar o código da nossa classe <code>Book</code>. Por exemplo, implementar uma classe <code>DatabasePersistence</code> seria bem simples e a nossa lógica de negócios, criada em relação às operações com os livros, não mudaria.</p>

<h2>Uma Visão de Alto Nível</h2>

<p>Em meus artigos anteriores, mencionei e apresentei, frequentemente, o esquema arquitetural de alta nível que pode ser visto abaixo.</p>

<figure>
<img width="600" alt="HighLevelDesign" src="http://cdn.tutsplus.com/net/uploads/2013/12/HighLevelDesign.png" height="388"><br>
</figure>

<p>Se analizarmos esse esquema, você pode ver como o Princípio da Responsabilidade Única é respeitado. A criação de objetos está separada na direta, em Fábricas (Factories) e no ponto de entrada principal (Main) de nossa aplicação, um ator uma responsabilidade. A persistência também é levada em conta, na parte de baixo. Um módulo separado para um responsabilidade diferente. Finalmente, na esqueda, nós temos a apresentação ou o mecanismo de entrega, se preferir, na padrão MVC ou qualquer outro tipo de interface de usuário. A SRP foi respeitada novamente. Só nos resta descobrir o que fazer na nossa lógica de negócio.</p>

<h2>Considerações de Projeto de Software</h2>

<p>Quando pensamos sobre o aplicativo que precisamos codificar, podemos analizar diversos aspectos diferentes. Por exemplo, vários requerimentos que afetam uma mesma classe podem ser um foco de mudança. Esses focos de mudanças são dicas para a responsabilidade única. Há uma alta probabilidade que grupos de requerimentos que estão afetando o mesmo grupo de funções serão responsáveis por outras mudanças ou serem separados em um grupo próprio.</p>

<p>O valor primário de um aplicativo é a facilidade de alteração, o secundário é a funcionalidade, no sentido de satisfazer tantos requerimentos quanto possível, atendendo as necessidades dos usuários. Entretanto, para alcançar um valor secundário bem positivo, o valor primário é obrigatório. Para mantermos nosso valor primário alto, devemos ter um projeto que seja fácil de alterar, estender e adicionar novas funcionalidades, além de garantir que a SRP seja respeitada.</p>

<p>Nós podemos pensar em um passo-a-passo:</p>

<ol>
<li>Alto valor primário leva a um alto valor secundário.</li>
<li>O valor secundário equivale às necessidades dos usuários.</li>
<li>Necessidades dos usuários equivale às necessidades dos atores.</li>
<li>Necessidades dos atores determina as necessidades de mudança desses atores.</li>
<li>Necessidades de mudanças dos atores definem nossas responsabilidades.</li>
</ol>

<p>Então, quando projetarmos nossos aplicativos, deveríamos:</p>

<ol>
<li>Buscar e definir atores.</li>
<li>Identificar a responsabilidade própria a esses atores.</li>
<li>Agrupar nossas funções em classes para que cada uma tenha uma única responsabilidade.</li>
</ol>

<h2>A Less Obvious Example</h2>

<pre class="brush: php">class Book {

	function getTitle() {
		return "Um ótimo livro";
	}

	function getAuthor() {
		return "John Doe";
	}

	function turnPage() {
		// ponteiro para a próxima página
	}

	function getCurrentPage() {
		return "conteúdo da página atual";
	}

	function getLocation() {
		// returns the position in the library
		// ie. shelf number &amp; room number
	}

}</pre>

<p>Now this may appear perfectly reasonable. We have no method dealing with persistence, or presentation. We have our <code>turnPage()</code> functionality and a few methods to provide different information about the book. However, we may have a problem. To find out, we might want to analyze our application. The function <code>getLocation()</code> may be the problem.</p>

<p>All of the methods of the <code>Book</code> class are about business logic. So our perspective must be from the business's point of view. If our application is written to be used by real librarians who are searching for books and giving us a physical book, then SRP might be violated.</p>

<p>We can reason that the actor operations are the ones interested in the methods <code>getTitle()</code>, <code>getAuthor()</code> and <code>getLocation()</code>. The clients may also have access to the application to select a book and read the first few pages to get an idea about the book and decide if they want it or not. So the actor readers may be interested in all the methods except <code>getLocations()</code>. An ordinary client doesn't care where the book is kept in the library. The book will be handed over to the client by the librarian. So, we do indeed have a violation of SRP.</p>

<pre class="brush: php">class Book {

	function getTitle() {
		return "Um ótimo livro";
	}

	function getAuthor() {
		return "John Doe";
	}

	function turnPage() {
		// ponteiro para a próxima página
	}

	function getCurrentPage() {
		return "conteúdo da página atual";
	}

}

class BookLocator {

	function locate(Book $book) {
		// returns the position in the library
		// ie. shelf number &amp; room number
		$libraryMap-&gt;findBookBy($book-&gt;getTitle(), $book-&gt;getAuthor());
	}

}</pre>

<p>Introducing the <code>BookLocator</code>, the librarian will be interested in the <code>BookLocator</code>. The client will be interested in the <code>Book</code> only. Of course, there are several ways to implement a <code>BookLocator</code>. It can use the author and title or a book object and get the required information from the <code>Book</code>. It always depends on our business. What is important is that if the library is changed, and the librarian will have to find books in a differently organized library, the <code>Book</code> object will not be affected. In the same way, if we decide to provide a pre-compiled summary to the readers instead of letting them browse the pages, that will not affect the librarian nor the process of finding the shelf the books sits on.</p>

<p>However, if our business is to eliminate the librarian and create a self-service mechanism in our library, then we may consider that SRP is respected in our first example. The readers are our librarians also, they need to go and find the book themselves and then check it out at the automated system. This is also a possibility. What is important to remember here is that you must always consider your business carefully.</p>

<h2>Final Thoughts</h2>

<p>The Single Responsibility Principle should always be considered when we write code. Class and module design is highly affected by it and it leads to a low coupled design with less and lighter dependencies. But as any coin, it has two faces. It is tempting to design from the beginning of our application with SRP in mind. It is also tempting to identify as many actors as we want or need. But this is actually dangerous - from a design point of view - to try and think of all the parties from the very beginning. Excessive SRP consideration can easily lead to premature optimization and instead of a better design, it may lead to a scattered one where the clear responsibilities of classes or modules may be hard to understand. </p>

<p>So, whenever you observe that a class or module starts to change for different reasons, don't hesitate, take the necessary steps to respect SRP, however don't overdue it because premature optimization can easily trick you.</p>
