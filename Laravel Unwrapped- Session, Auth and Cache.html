<h1>Desconstruindo Laravel: Session, Auth e Cache</h1>

<p>Nos últimos anos, <a href="http://laravel.com/" target="_self">Laravel</a> tornou-se uma das frameworks mais importantes e utilizadas por engenheiros de software na hora de construir suas aplicações web. Com popularidade semelhante à do <a href="http://ellislab.com/codeigniter" target="_self">CodeIgniter</a> em seus dias de glória, Laravel tem sido louvado pela sua simplicidade, facilidade de uso por parte dos iniciantes e aderência aos padrões da indústria.</p>

<h2>Introdução</h2>

<p>Algo que muitos programadores deixam de aproveitar do Laravel é a sua componentização. Desde sua conversão à utilização de componentes que lançam utilizam o Composer, Laravel 4 tornou-se um sistema bastante modular, semelhante às frameworks mais maduras, como a Symfony. Ela usa o grupo de componentes chamado de <code class="inline">Illuminate</code>, que, na minha opinião, não é a framework em si, mas uma compilação de bibliotecas que uma framework pode chegar a usar. A framework Laravel, de verdade, é representada pela aplicação base do Laravel (encontrada no <a href="https://github.com/laravel/laravel" target="_self">repositório do GitHub</a> chamado <code>laravel/laravel</code>), que faz uso desses componente para construir uma aplicação web.</p>

<p>Nesse tutorial, nós nos aprofundaremos em alguns dos componentes desse grupo, aprendendo como eles funcionam, como eles são utilizados pela framework e como estender a funcionalidade deles.</p>

<h2>O Componente Session</h2>

<p>O componente Session do Laravel lida com as sessões das aplicações web. Ele faz uso de um sistema de drivers chamado Laravel Manager, que age tanto como uma fábrica (do padrão de programação Factory) quanto um envólucro para qualquer driver atribuído no arquivo de configuração. Até o momento da escrita desse post, o componente Session tem os seguintes drivers:</p>

<ul><li><code class="inline">file </code>- driver baseado em arquivo, onde os dados da sessão são salvos em um arquivo criptografado.</li>
<li><code class="inline">cookie </code>- driver baseados em cookies, onde os dados da sessão são salvos de forma criptografada nos cookies (do navegador) do usuário.</li>
<li><code class="inline">database </code>- os dados da sessão são salvos na base de dados configurada para a aplicação.</li>
<li><code class="inline">apc </code>- os dados da sessão são salvos no APC (Alternative PHP Cache).</li>
<li><code class="inline">memcached </code>- os dados da sessão são salvas no Memcached.</li>
<li><code class="inline">redis </code>- os dados da sessão são salvo no Redis.</li>
<li><code class="inline">array </code>- os dados da sessão são salvos em uma array do PHP. Atente que o driver de sessão baseado em array não dá suporte a persistência de dados e, geralmente, é usado somente em linha de comando.</li>
</ul><h3>Provedores de Serviço</h3>

<p>A maioria dos usuários de Laravel não percebem mas, grande parte de como o Laravel funciona se deve aos seus provedores de serviço. Os provedores de serviços são, em essência, arquivos inicializadores de cada componente e eles são tão abstraídos que os usuários podem utilizá-los para inicializar qualquer componente, de qualquer forma.</p>

<p>Uma explicação grosseira de como isso funciona segue abaixo:</p>

<ol><li>O componente Application do Laravel é inicializado. Esse é o driver principal de toda a framework, responsável por lidar com as Requisições HTTP, executar os provedores de serviços, e agir como recipiente de dependências para a framework.</li>
<li>Uma vez que um provedor de serviço é executado, o método <code>register</code> dele é chamado. Isso permite instanciar qualquer componente que quisermos.

<ul><li>Tenha em mente que todos os provedores de serviço tem acesso à aplicação principal do Laravel (via <code>$this-&gt;app</code>), o que permite que os provedores de serviços tenham acesso a instâncias de classes criadas de dentro do recipiente de depedência.</li></ul></li>
<li>Uma vez que essas dependências são carregadas, nós estamos livres para chamar o recipiente, por exemplo, pelo sistema Facade do Laravel, através do <code>App::make</code>.</li>
</ol><p>Voltando ao componente Sessions, daremos uma rápida olhada no <code class="inline">SessionServiceProivider</code>:</p>

<pre class="brush: php"> /**
   * Register the session manager instance.
*
* @return void
*/
	protected function registerSessionManager()
	{
$this-&gt;app-&gt;bindShared('session', function($app)
{
	return new SessionManager($app);
});
	}

	/**
* Register the session driver instance.
*
* @return void
*/
	protected function registerSessionDriver()
	{
$this-&gt;app-&gt;bindShared('session.store', function($app)
{
	// First, we will create the session manager which is responsible for the
	// creation of the various session drivers when they are needed by the
	// application instance, and will resolve them on a lazy load basis.
	$manager = $app['session'];

	return $manager-&gt;driver();
});
	}</pre>

<p>Esses dois métodos são chamados pela função <code>register()</code>. O primeiro, <code>registerSessionManager()</code>, é chamado para registrar inicialmente o <code>SessionManager</code>. Essa classe estende a classe <code>Manager</code> que mencionei mais acima. O segundo, <code>registerSessionDriver()</code>, registrar um manipulador de registros para o manager, baseado nas configurações que instituimos no início. Isso, eventualmente, invoca esse método da classe <code>Illuminate\Support\Manager</code>:</p>

<pre class="brush: php">/**
   * Create a new driver instance.
*
* @param  string  $driver
* @return mixed
*
* @throws \InvalidArgumentException
*/
	protected function createDriver($driver)
	{
$method = 'create'.ucfirst($driver).'Driver';

// We'll check to see if a creator method exists for the given driver. If not we
// will check for a custom driver creator, which allows developers to create
// drivers using their own customized driver creator Closure to create it.
if (isset($this-&gt;customCreators[$driver]))
{
	return $this-&gt;callCustomCreator($driver);
}
elseif (method_exists($this, $method))
{
	return $this-&gt;$method();
}

throw new \InvalidArgumentException("Driver [$driver] not supported.");
	}</pre>

<p>Aqui, podemos ver que, baseado no nome do driver, escolhido no arquivo de configuração, um método específico é chamado. Então, se tivermos configurados o sistema para usar o manipulador de sessão do tipo <code>file</code>, ele invocará esse método na classe <code>SessionManager</code>:</p>

<pre class="brush: php">/**
   * Create an instance of the file session driver.
*
* @return \Illuminate\Session\Store
*/
	protected function createFileDriver()
	{
return $this-&gt;createNativeDriver();
	}

	/**
* Create an instance of the file session driver.
*
* @return \Illuminate\Session\Store
*/
	protected function createNativeDriver()
	{
$path = $this-&gt;app['config']['session.files'];

return $this-&gt;buildSession(new FileSessionHandler($this-&gt;app['files'], $path));
	}</pre>

<p>A classe correta do driver é, então, injetada na classe <code>Store</code>, que é responsável por invocar os métodos verdadeiros para manipulação da sessão. Isso permite que separemos a implementação da classe <code>SessionHandlerInterface</code> da SPL (Standard PHP Library), a classe <code>Store</code> facilita isso.</p>

<h3>Criando Nossa Própria Manipuladora de Sessão</h3>

<p>Vamos criar nossa própria classe manipuladora de sessão, usando MongoDB. Primeiro, precisaremos criar a classe <code>MongoSessionHandler</code> em uma instalação recém criada do Laravel (Nós pegaremos muitos códigos emprestados da classe <code>Symfony\Component\HttpFoundation\Session\Storage\Handler\MongoDbSessionHandler</code>):</p>

<pre class="brush: php">&lt;?php namespace Illuminate\Session;

  use Mongo;
  use MongoDate;
  use MongoBinData;

  class MongoSessionHandler implements \SessionHandlerInterface
  {
      /**
       * Configuração do Mongo DB
       *
       * @var array
       */
      protected $config;

      /**
       * Conexão do Mongo DB
       * 
       * @var \Mongo
       */
      protected $connection;

      /**
       * Coleção do Mongo DB
       * 
       * @var \MongoCollection
       */
      protected $collection;
      /**
       * Cria uma nova instância do Manipulador do driver do Mongo DB.
       *
       * @param  array $config
       *  - $config['host']       Mongodb host
       *  - $config['username']   Mongodb username
       *  - $config['password']   Mongodb password
       *  - $config['database']     Mongodb database
       *  - $config['collection'] Mongodb collection
       * @return void
       */
      public function __construct(array $config)
      {
          $this-&gt;config = $config;

          $connection_string = 'mongodb://';

          if (!empty($this-&gt;config['username']) &amp;&amp; !empty($this-&gt;config['password'])) {
              $connection_string .= "{$this-&gt;config['user']}:{$this-&gt;config['password']}@";
          }

          $connection_string .= "{$this-&gt;config['host']}";

          $this-&gt;connection = new Mongo($connection_string);

          $this-&gt;collection = $this-&gt;connection-&gt;selectCollection($this-&gt;config['database'], $this-&gt;config['collection']);
      }

      /**
       * {@inheritDoc}
       */
      public function open($savePath, $sessionName)
      {
          return true;
      }

      /**
       * {@inheritDoc}
       */
      public function close()
      {
          return true;
      }

      /**
       * {@inheritDoc}
       */
      public function read($sessionId)
      {
          $session_data = $this-&gt;collection-&gt;findOne(array(
              '_id' =&gt; $sessionId,
          ));

          if (is_null($session_data)) {
              return '';
          } else {
              return $session_data['session_data']-&gt;bin;
          }
      }

      /**
       * {@inheritDoc}
       */
      public function write($sessionId, $data)
      {
          $this-&gt;collection-&gt;update(
              array(
                  '_id' =&gt; $sessionId
              ),
              array(
                  '$set' =&gt; array(
                      'session_data' =&gt; new MongoBinData($data, MongoBinData::BYTE_ARRAY),
                      'timestamp' =&gt; new MongoDate(),
                  )
              ),
              array(
                  'upsert' =&gt; true,
                  'multiple' =&gt; false
              )
          );
      }

      /**
       * {@inheritDoc}
       */
      public function destroy($sessionId)
      {
          $this-&gt;collection-&gt;remove(array(
              '_id' =&gt; $sessionId
          ));

          return true;
      }

      /**
       * {@inheritDoc}
       */
      public function gc($lifetime)
      {
          $time = new MongoDate(time() - $lifetime);

          $this-&gt;collection-&gt;remove(array(
              'timestamp' =&gt; array('$lt' =&gt; $time),
          ));

          return true;
      }
  }
</pre>

<p>Você deve salvar esse arquivo no diretório <code>vendor/laravel/framework/src/Illuminate/Session</code>. Para os propósitos desse projeto, nós colocaremos nesse diretório, porém, idealmente, ele deve ficar localizado dentro de um diretório usando seu próprio namespace. </p>

<p>Feito isso, precisamos garantir que a classe <code>Manager</code> pode invocar o driver. Nós podemos fazer isso utilizando o método <code>Manager::extend</code>. Abra o arquivo <code>vendor/laravel/framework/src/Illuminate/Session/SessionServiceProvider.php</code> e adicione o código a seguir. Idealmente, deveríamos estender o provedor de serviços, porém, essa parte está além do escopo desse tutorial.</p>

<pre class="brush: php">/**
   * Prepara a callback do Mongo Driver
*
* @return  void
*/
	public function setupMongoDriver()
	{
$manager = $this-&gt;app['session'];

$manager-&gt;extend('mongo', function($app) {
    return new MongoSessionHandler(array(
        'host'       =&gt; $app['config']-&gt;get('session.mongo.host'),
        'username'   =&gt; $app['config']-&gt;get('session.mongo.username'),
        'password'   =&gt; $app['config']-&gt;get('session.mongo.password'),
        'database'   =&gt; $app['config']-&gt;get('session.mongo.database'),
        'collection' =&gt; $app['config']-&gt;get('session.mongo.collection')
    ));
});
	}</pre>

<p>Atualize o método <code>register()</code> para que ele invoce esse método:</p>

<pre class="brush: php">/**
   * Register the service provider.
*
* @return void
*/
	public function register()
	{
$this-&gt;setupDefaultDriver();

$this-&gt;registerSessionManager();

$this-&gt;setupMongoDriver();

$this-&gt;registerSessionDriver();
	}</pre>

<p>Depois disso, precisamos definir a configuração do Mongo DB. Abra o arquivo <code>app/config/session.php</code> e defina as seguintes configurações:</p>

<pre class="brush: php">/**
   * Configurações do Mongo DB
*/
	'mongo' =&gt; array(
'host' =&gt; '127.0.0.1',
'username' =&gt; '',
'password' =&gt; '',
'database' =&gt; 'laravel',
'collection' =&gt; 'laravel_session_collection'
	)</pre>

<p>Já que estamos nesse arquivo, também devemos atualizar a configuração do driver na parte superior <code class="inline">driver </code>:</p>

<pre class="brush: php">'driver' =&gt; 'mongo'</pre>

<p>Agora, tente acessar a página inicial (geralmente, <code>localhost/diretorio_instalacao_laravel/public</code>). Se a página carregar sem mostrar a página <code class="inline">WHOOPS</code> (página de erros), então, parabéns, nós fomos bem sucedidos em criar um driver de sessão novinho em folha! Teste-o, adicionando alguns dados fictícios na sessão, através do método <code>Session::set()</code> e, então, recupere-o através do <code>Session::get()</code> para mostrá-lo na página.</p>

<h2>O Componente Auth</h2>

<p>O componente Auth do Laravel é responsável por manipular a autenticação dos usuários na framework e, também, é responsável por administrar as senhas. O que o componente do Laravel fez, foi criar uma abstração de um típico sistema de administração de usuários, usavél na maioria das aplicações web, o que ajuda aos programadores a, facilmente, implementar um sistemade login. Da mesma forma que o componente Session, ele também faz uso do Laravel Manager. Atualmente, o componente Auth tem drivers para:</p>

<ul><li><code class="inline">eloquent</code> - esse driver faz uso do ORM embutido no Laravel, o <code class="inline">Eloquent</code>. Ele também lança mão de uma classe <code>User.php</code> pré-existente, que fica no diretório <code>models</code>.</li>
<li><code class="inline">database</code> - Essa daqui usa qualquer conexão de base de dados que estiver configurada por padrão. Ela faz uso da classe <code>GenericUser</code> para acessar os dados dos usuários.</li>
</ul><p>Já que aqui também seguiremos a mesma implementação do componente <code>Session</code>, o provedor de serviços é bem semelhante ao que vimos mais acima:</p>

<pre class="brush: php">/**
   * Register the service provider.
*
* @return void
*/
	public function register()
	{
$this-&gt;app-&gt;bindShared('auth', function($app)
{
	// Once the authentication service has actually been requested by the developer
	// we will set a variable in the application indicating such. This helps us
	// know that we need to set any queued cookies in the after event later.
	$app['auth.loaded'] = true;

	return new AuthManager($app);
});
	}</pre>

<p>Nós podemos ver que, basicamente, ele cria uma classe <code>AuthManager</code> que envolve qualquer driver que estamos usando, além de agir como uma fábrica para esse driver. Dentro da classe <code>AuthManager</code>, ela, novamente, cria o driver apropriado, envolta na classe <code>Guard</code>, que age da mesma forma que a classe <code>Store</code> para a <code>Session</code>.</p>

<h3>Criando Nosso Próprio Manipulador de Autenticação</h3>

<p>Da mesma forma que antes, vamos criar uma classe <code>MongoUserProvider</code>:</p>

<pre class="brush: php">&lt;?php namespace Illuminate\Auth;

  use Mongo;
  use Illuminate\Hashing\HasherInterface;

  class MongoUserProvider implements UserProviderInterface {

      /**
       * Uma instância do MongoDB
       *
       * @param  \Mongo
       */
      protected $connection;

      /**
       * A instância da conexão com o MongoDB
       *
       * @param  \MongoConnection
       */
      protected $collection;

      /**
       * A array de configuração do Mongo
       *
       * @var array
       */
      protected $config;

      /**
       * Create a new Mongo user provider.
       *
       * @param  array $config
       *     - $config['host']       Mongodb host
       *     - $config['username']   Mongodb username
       *     - $config['password']   Mongodb password
       *     - $config['database']   Mongodb database
       *     - $config['collection'] Mongodb collection
       * @return void
       */
      public function __construct(array $config)
      {
          $this-&gt;config = $config;

          $connection_string = 'mongodb://';

          if (!empty($this-&gt;config['username']) &amp;&amp; !empty($this-&gt;config['password'])) {
              $connection_string .= "{$this-&gt;config['user']}:{$this-&gt;config['password']}@";
          }

          $connection_string .= "{$this-&gt;config['host']}";

          $this-&gt;connection = new Mongo($connection_string);

          $this-&gt;collection = $this-&gt;connection-&gt;selectCollection($this-&gt;config['database'], $this-&gt;config['collection']);
      }

      /**
       * Retorna um usuário a partir do seu identificador único.
       *
       * @param  mixed  $identifier
       * @return \Illuminate\Auth\UserInterface|null
       */
      public function retrieveById($identifier)
      {
          $user_data = $this-&gt;collection-&gt;findOne(array(
              '_id' =&gt; $identifier,
          ));

          if (!is_null($user_data)) {
              return new GenericUser((array) $user_data);
          }
      }

      /**
       * Retorna um usuário a partir de credenciais apresentadas.
       *
       * @param  array  $credentials
       * @return \Illuminate\Auth\UserInterface|null
       */
      public function retrieveByCredentials(array $credentials)
      {
          // Attempt to look for the user first regardless of password
          // We'll do that in the validateCredentials method
          if (isset($credentials['password'])) {
              unset($credentials['password']);
          }

          $user_data = $this-&gt;collection-&gt;findOne($credentials);

          if (!is_null($user_data)) {
              return new GenericUser((array) $user_data);
          }
      }

      /**
       * Valida um usuário em relação credenciais apresentadas.
       *
       * @param  \Illuminate\Auth\UserInterface  $user
       * @param  array  $credentials
       * @return bool
       */
      public function validateCredentials(UserInterface $user, array $credentials)
      {
          if (!isset($credentials['password'])) {
              return false;
          }
          
          return ($credentials['password'] === $user-&gt;getAuthPassword());
      }
  }</pre>

<p>É importante atentar que não estamos temos métodos de comparação com senhas criptografadas, uma vez que esse código foi criado para facilitar a criação de dados fictícios e poder testá-la depois. No código de produção, você precisará criptgrafar as senhas. Verifique a classe <code>Illuminate\Auth\DatabaseUserProvider</code> para um ótimo exemplo de como fazer isso.</p>

<p>Depois, precisamos registrar a callback do nosso driver customizado junto ao <code>AuthManager</code>. Para fazer isso, precisamos atualizar o método <code class="inline">register</code> do provedor de serviços:</p>

<pre class="brush: php">/**
   * Register the service provider.
*
* @return void
*/
	public function register()
	{
$this-&gt;app-&gt;bindShared('auth', function($app)
{
	// Once the authentication service has actually been requested by the developer
	// we will set a variable in the application indicating such. This helps us
	// know that we need to set any queued cookies in the after event later.
	$app['auth.loaded'] = true;

	$auth_manager = new AuthManager($app);

	$auth_manager-&gt;extend('mongo', function($app) {
		return new MongoUserProvider(
			array(
				'host'       =&gt; $app['config']-&gt;get('auth.mongo.host'),
		        'username'   =&gt; $app['config']-&gt;get('auth.mongo.username'),
		        'password'   =&gt; $app['config']-&gt;get('auth.mongo.password'),
		        'database'   =&gt; $app['config']-&gt;get('auth.mongo.database'),
		        'collection' =&gt; $app['config']-&gt;get('auth.mongo.collection')
			)
		);
	});

	return $auth_manager;
});
	}</pre>

<p>Por último, também precisamos atualizar o arquivo de configuração <code>auth.php</code> para usar o driver do Mongo, assim como prover os valores de configuração do Mongo:</p>

<pre class="brush: php">'driver' =&gt; 'mongo',
  ...
  ...
  ...
  /**
   * Configurações do Mongo DB
*/
	'mongo' =&gt; array(
'host' =&gt; '127.0.0.1',
'username' =&gt; '',
'password' =&gt; '',
'database' =&gt; 'laravel',
'collection' =&gt; 'laravel_auth_collection'
	)</pre>

<p>Testar isso é um pouco complicado, mas, para fazê-lo, lançaremos mão da linha de comando do Mongo DB para inserir um novo usuário na coleção:</p>

<pre class="brush: bash">mongo

  &gt; use laravel_auth
  switched to db laravel_auth
  &gt; db.laravel_auth_collection.insert({id: 1, email:"nikko@nikkobautista.com", password:"test_password"})
  &gt; db.laravel_auth_collection.find()
  &gt; { "_id" : ObjectId("530c609f2caac8c3a8e4814f"), "id" 1, "email" : "nikko@emailtest.com", "password" : "test_password" }</pre>

<p>Agora, testaremos o método <code>Auth::validate</code>:</p>

<pre class="brush: php">var_dump(Auth::validate(array('email' =&gt; 'nikko@emailtest.com', 'password' =&gt; 'test_password')));</pre>

<p>Isso deveria retornar um <code>bool(true)</code>. Se ele retornar, então acabamos de criar nosso próprio driver de auntenticação!</p>

<h2>O Componente Cache</h2>

<p>O componente de Cache do Laravel manipula o mecanismo de cache para usarmos na framework. Da mesma forma que discutimos para os outros componentes, ele também faz uso do Laravel Manager (você percebeu algum padrão?). O componente Cache tem drivers para:</p>

<ul><li><code class="inline">apc</code></li>
<li><code class="inline">memcached</code></li>
<li><code class="inline">redis</code></li>
<li><code class="inline">file</code> - cache baseado em arquivos. Os dados são salvos no diretórios <code>app/storage/cache</code>.</li>
<li><code class="inline">database</code> - cache salvos na base de dados. Os dados são salvos em registros na base de dados. O <em>schema</em> da base de dados para isso é descrito na <a href="http://laravel.com/docs/cache" target="_self">Documentação do Laravel</a>.</li>
<li><code class="inline">array</code> - dados são "guardados" em um array. Lembre-se que o cache baseado em <code>array</code> não persiste os dados e é apagado a cada carregamento.</li>
</ul><p>Como, novamente, segue a mesma implementação dos componente anteriores, você pode assumir que o processo de criar o provedor de serviços é bem semelhante:</p>

<pre class="brush: php">/**
   * Register the service provider.
*
* @return void
*/
	public function register()
	{
$this-&gt;app-&gt;bindShared('cache', function($app)
{
	return new CacheManager($app);
});

$this-&gt;app-&gt;bindShared('cache.store', function($app)
{
	return $app['cache']-&gt;driver();
});

$this-&gt;app-&gt;bindShared('memcached.connector', function()
{
	return new MemcachedConnector;
});

$this-&gt;registerCommands();
	}</pre>

<p>O método <code>register()</code> cria um <code>CacheManager</code>, que serve como envólucro e fábrica para os drivers. Dentro do <em>manager</em>, ele envolve o driver em relação à classe <code>Repository</code>, de forma semelhante às classes <code>Store</code> e <code>Guard</code>.</p>

<h3>Criando Nosso Próprio Manipulador de Cache</h3>

<p>Crie a classe <code>MongoStore</code>, que estenderá a classe <code>Illuminate\Cache\StoreInterface</code>:</p>

<pre class="brush: php">&lt;?php namespace Illuminate\Cache;

  use Mongo;

  class MongoStore implements StoreInterface
  {
      /**
       * A instância do Mongo DB
       *
       * @param  \Mongo
       */
      protected $connection;

      /**
       * A instância da conexão com o MongoDB
       *
       * @param  \MongoConnection
       */
      protected $collection;

      /**
       * A array de configuração do Mongo DB
       *
       * @var array
       */
      protected $config;

      /**
       * Criar a nova "loja" de cache com Mongo.
       *
       * @param  array $config
       *     - $config['host']       Mongodb host
       *     - $config['username']   Mongodb username
       *     - $config['password']   Mongodb password
       *     - $config['database']   Mongodb database
       *     - $config['collection'] Mongodb collection
       * @return void
       */
      public function __construct(array $config)
      {
          $this-&gt;config = $config;

          $connection_string = 'mongodb://';

          if (!empty($this-&gt;config['username']) &amp;&amp; !empty($this-&gt;config['password'])) {
              $connection_string .= "{$this-&gt;config['user']}:{$this-&gt;config['password']}@";
          }

          $connection_string .= "{$this-&gt;config['host']}";

          $this-&gt;connection = new Mongo($connection_string);

          $this-&gt;collection = $this-&gt;connection-&gt;selectCollection($this-&gt;config['database'], $this-&gt;config['collection']);
      }

      /**
       * Retorna um item do cache usando uma chave.
       *
       * @param  string  $key
       * @return mixed
       */
      public function get($key)
      {
          $cache_data = $this-&gt;getObject($key);

          if (!$cache_data) {
              return null;
          }

          return unserialize($cache_data['cache_data']);
      }

      /**
       * Retorna todo o objeto, ao invés de retorna somente os dados
       * 
       * @param  string  $key
       * @return array|null
       */
      protected function getObject($key)
      {
          $cache_data = $this-&gt;collection-&gt;findOne(array(
              'key' =&gt; $key,
          ));

          if (is_null($cache_data)) {
              return null;
          }

          if (isset($cache_data['expire']) &amp;&amp; time() &gt;= $cache_data['expire']) {
              $this-&gt;forget($key);
              return null;
          }

          return $cache_data;
      }

      /**
       * Salva um item na loja por um dado número de minutos.
       *
       * @param  string  $key
       * @param  mixed   $value
       * @param  int     $minutes
       * @return void
       */
      public function put($key, $value, $minutes)
      {
          $expiry = $this-&gt;expiration($minutes);

          $this-&gt;collection-&gt;update(
              array(
                  'key' =&gt; $key
              ),
              array(
                  '$set' =&gt; array(
                      'cache_data' =&gt; serialize($value),
                      'expiry' =&gt; $expiry,
                      'ttl' =&gt; ($minutes * 60)
                  )
              ),
              array(
                  'upsert' =&gt; true,
                  'multiple' =&gt; false
              )
          );
      }

      /**
       * Incrementa o valor de um item no cache.
       *
       * @param  string  $key
       * @param  mixed   $value
       * @return void
       *
       * @throws \LogicException
       */
      public function increment($key, $value = 1)
      {
          $cache_data = $this-&gt;getObject($key);

          if (!$cache_data) {
              $new_data = array(
                  'cache_data' =&gt; serialize($value),
                  'expiry' =&gt; $this-&gt;expiration(0),
                  'ttl' =&gt; $this-&gt;expiration(0)
              );
          } else {
              $new_data = array(
                  'cache_data' =&gt; serialize(unserialize($cache_data['cache_data']) + $value),
                  'expiry' =&gt; $this-&gt;expiration((int) ($cache_data['ttl']/60)),
                  'ttl' =&gt; $cache_data['ttl']
              );
          }

          $this-&gt;collection-&gt;update(
              array(
                  'key' =&gt; $key
              ),
              array(
                  '$set' =&gt; $new_data
              ),
              array(
                  'upsert' =&gt; true,
                  'multiple' =&gt; false
              )
          );
      }

      /**
       * Decrementa o valor de um item no cache.
       *
       * @param  string  $key
       * @param  mixed   $value
       * @return void
       *
       * @throws \LogicException
       */
      public function decrement($key, $value = 1)
      {
          $cache_data = $this-&gt;getObject($key);

          if (!$cache_data) {
              $new_data = array(
                  'cache_data' =&gt; serialize((0 - $value)),
                  'expiry' =&gt; $this-&gt;expiration(0),
                  'ttl' =&gt; $this-&gt;expiration(0)
              );
          } else {
              $new_data = array(
                  'cache_data' =&gt; serialize(unserialize($cache_data['cache_data']) - $value),
                  'expiry' =&gt; $this-&gt;expiration((int) ($cache_data['ttl']/60)),
                  'ttl' =&gt; $cache_data['ttl']
              );
          }

          $this-&gt;collection-&gt;update(
              array(
                  'key' =&gt; $key
              ),
              array(
                  '$set' =&gt; $new_data
              ),
              array(
                  'upsert' =&gt; true,
                  'multiple' =&gt; false
              )
          );
      }

      /**
       * Salva um item no cache, indefinidamente.
       *
       * @param  string  $key
       * @param  mixed   $value
       * @return void
       */
      public function forever($key, $value)
      {
          return $this-&gt;put($key, $value, 0);
      }

      /**
       * Apaga um item do cache.
       *
       * @param  string  $key
       * @return void
       */
      public function forget($key)
      {
          $this-&gt;collection-&gt;remove(array(
              'key' =&gt; $key
          ));
      }

      /**
       * Apaga todos os itens do cache.
       *
       * @return void
       */
      public function flush()
      {
          $this-&gt;collection-&gt;remove();
      }

      /**
       * Retorna o tempo de expiração de um item.
       *
       * @param  int  $minutes
       * @return int
       */
      protected function expiration($minutes)
      {
          if ($minutes === 0) return 9999999999;

          return time() + ($minutes * 60);
      }

      /**
       * Get the cache key prefix.
       *
       * @return string
       */
      public function getPrefix()
      {
          return '';
      }
  }</pre>

<p>Nós também adicionaremos a callback do Mongo, novamente, no <em>manager</em>:</p>

<pre class="brush: php">/**
   * Register the service provider.
*
* @return void
*/
	public function register()
	{
$this-&gt;app-&gt;bindShared('cache', function($app)
{
	$cache_manager = new CacheManager($app);

	$cache_manager-&gt;extend('mongo', function($app) {
		return new MongoStore(
			array(
				'host'       =&gt; $app['config']-&gt;get('cache.mongo.host'),
		        'username'   =&gt; $app['config']-&gt;get('cache.mongo.username'),
		        'password'   =&gt; $app['config']-&gt;get('cache.mongo.password'),
		        'database'   =&gt; $app['config']-&gt;get('cache.mongo.database'),
		        'collection' =&gt; $app['config']-&gt;get('cache.mongo.collection')
			)
		);
	});

	return $cache_manager;
});

$this-&gt;app-&gt;bindShared('cache.store', function($app)
{
	return $app['cache']-&gt;driver();
});

$this-&gt;app-&gt;bindShared('memcached.connector', function()
{
	return new MemcachedConnector;
});

$this-&gt;registerCommands();
	}</pre>

<p>Por último, precisamos atualizar o arquivo de configuração <code>cache.php</code>:</p>

<pre class="brush: php">'driver' =&gt; 'mongo',
  ...
  ...
  ...
  /**
* Configuração do MongoDB
*/
	'mongo' =&gt; array(
'host' =&gt; '127.0.0.1',
'username' =&gt; '',
'password' =&gt; '',
'database' =&gt; 'laravel',
'collection' =&gt; 'laravel_cache_collection'
	)</pre>

<p>Agora, tente usar os métodos <code>Cache::put()</code> e <code>Cache::get()</code>. Se tiver feito tudo certo, você foi capaz de guardar e recuperar dados de um sistema de cache que usa MongoDB!</p>

<h2>Conclusão</h2>

<p>Nesse tutorial aprendemos:</p>

<ul><li>Sobre o sistema de componentes do Laravel, chamado <code>Illuminate</code>, que é usado pela framework Laravel.</li>
<li>Sobre os provedores de serviços do Laravel e um pouco sobre como eles funcionam.</li>
<li>Sobre o sistema Manager do Laravel, que age tanto como envólucro quanto uma fábrica para os drivers.</li>
<li>Sobre os componentes Session, Auth e Cache e como criar novos drivers para cada um deles.</li>
<li>As bibliotecas Store, Guard e Repository que utilizam esses drivers.</li>
</ul>

<p>Espero que esse artigo possa ajudar os programadores a criarem seus próprios drivers para que possam estender as funcionalidades do Laravel.</p>