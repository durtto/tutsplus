<h1>Laravel Unwrapped: Session, Auth and Cache</h1>

<p>In recent years, <a href="http://laravel.com/" target="_self">Laravel</a> has become one of the most prominent frameworks software engineers use for building their web applications. Similar to the popularity thatÂ <a href="http://ellislab.com/codeigniter" target="_self">CodeIgniter</a> enjoyed in its heyday, Laravel has been lauded for its ease-of-use, friendliness to beginners and its adherence to industry standards.</p>

<h2>Introduction</h2>

<p>One thing though that not a lot of programmers take advantage of is Laravel's component-based system. Since its conversion to composer-powered components, Laravel 4 has become a very modular system, similar to the verbosity of more mature frameworks like Symfony. This is called the <code class="inline">Illuminate</code> group of components, which in my opinion, is not the actual framework itself, but is a compilation of libraries that a framework can potentially use. Laravel's actual framework is represented by the Laravel skeleton application (found on the <code>laravel/laravel</code> <a href="https://github.com/laravel/laravel" target="_self">GitHub repository</a>) that makes use of these components to build a web application.</p>

<p>In this tutorial, we'll be diving into a group of these components, learning how they work, how they're used by the framework, and how we can extend their functionality.</p>

<h2>The Session Component</h2>

<p>The Laravel Session component handles sessions for the web application. It makes use of a driver-based system called the Laravel Manager, which acts as both a factory and a wrapper for whichever driver is set in the configuration file. As of this writing, the Session component has drivers for:</p>

<ul><li><code class="inline">file </code>- a file-based session driver where session data is saved in an encrypted file.</li>
<li><code class="inline">cookie </code>- a cookie-based session driver where session data is encrypted in the user's cookies.</li>
<li><code class="inline">database </code>- session data is saved in whichever database is configured for the application.</li>
<li><code class="inline">apc </code>- session data is saved in APC.</li>
<li><code class="inline">memcached </code>- session data is saved in Memcached.</li>
<li><code class="inline">redis </code>- session data is saved in Redis.</li>
<li><code class="inline">array </code>- session data is saved in a PHP array. Take note that the array session driver does not support persistence and is usually only used in console commands.</li>
</ul><h3>Service Providers</h3>

<p>Most Laravel users don't realize but a big part of how Laravel works, is within its service providers. They are essentially bootstrap files for each component and they are abstracted enough so users can bootstrap any components, in any way.</p>

<p>A rough explanation of how this works is below:</p>

<ol><li>The Laravel Application component is initiated. This is the main driver of the whole framework, responsible for handling the HTTP Request, running the service providers, as well as acting as a dependency container for the framework.</li>
<li>Once a service provider is ran, its <code>register</code> method is called. This allows us to instantiate whichever component we want.

<ul><li>Keep in mind that all service providers have access to the main Laravel application (via <code>$this-&gt;app</code>), which would let service providers push instances of the resolved classes into the dependency container.</li></ul></li>
<li>Once these dependencies are loaded, we should be free to use them by calling on the container, for example, via Laravel's Facade system, <code>App::make</code>.</li>
</ol><p>Going back to Sessions, let's take a quick look at the <code class="inline">SessionServiceProivider</code>:</p>

<pre class="brush: php"> /**
   * Register the session manager instance.
*
* @return void
*/
	protected function registerSessionManager()
	{
$this-&gt;app-&gt;bindShared('session', function($app)
{
	return new SessionManager($app);
});
	}

	/**
* Register the session driver instance.
*
* @return void
*/
	protected function registerSessionDriver()
	{
$this-&gt;app-&gt;bindShared('session.store', function($app)
{
	// First, we will create the session manager which is responsible for the
	// creation of the various session drivers when they are needed by the
	// application instance, and will resolve them on a lazy load basis.
	$manager = $app['session'];

	return $manager-&gt;driver();
});
	}</pre>

<p>These two methods are called by the <code>register()</code> function. The first one, <code>registerSessionManager()</code>, is called to initially register the <code>SessionManager</code>. This class extends the <code>Manager</code> that I mentioned on top. The second one, <code>registerSessionDriver()</code> registers a session handler for the manager, based on what we have configured. This eventually calls this method in the <code>Illuminate\Support\Manager</code> class:</p>

<pre class="brush: php">/**
   * Create a new driver instance.
*
* @param  string  $driver
* @return mixed
*
* @throws \InvalidArgumentException
*/
	protected function createDriver($driver)
	{
$method = 'create'.ucfirst($driver).'Driver';

// We'll check to see if a creator method exists for the given driver. If not we
// will check for a custom driver creator, which allows developers to create
// drivers using their own customized driver creator Closure to create it.
if (isset($this-&gt;customCreators[$driver]))
{
	return $this-&gt;callCustomCreator($driver);
}
elseif (method_exists($this, $method))
{
	return $this-&gt;$method();
}

throw new \InvalidArgumentException("Driver [$driver] not supported.");
	}</pre>

<p>From here, we can see that based on the name of the driver, from the configuration file, a specific method is called. So, if we have it configured to use the <code>file</code> session handler, it will call this method in the <code>SessionManager</code> class:</p>

<pre class="brush: php">/**
   * Create an instance of the file session driver.
*
* @return \Illuminate\Session\Store
*/
	protected function createFileDriver()
	{
return $this-&gt;createNativeDriver();
	}

	/**
* Create an instance of the file session driver.
*
* @return \Illuminate\Session\Store
*/
	protected function createNativeDriver()
	{
$path = $this-&gt;app['config']['session.files'];

return $this-&gt;buildSession(new FileSessionHandler($this-&gt;app['files'], $path));
	}</pre>

<p>The driver class is then injected into a <code>Store</code> class, which is responsible for calling the actual session methods. This lets us actually separate the implementation of the <code>SessionHandlerInterface</code> from the SPL into the drivers, the <code>Store</code> class facilitates it.</p>

<h3>Creating Our Own Session Handler</h3>

<p>Let's create our own Session Handler, a MongoDB Session handler. First off, we'll need to create a <code>MongoSessionHandler</code> inside a newly installed Laravel project instance. (We'll be borrowing heavily from <code>Symfony\Component\HttpFoundation\Session\Storage\Handler\MongoDbSessionHandler</code>).:</p>

<pre class="brush: php">&lt;?php namespace Illuminate\Session;

  use Mongo;
  use MongoDate;
  use MongoBinData;

  class MongoSessionHandler implements \SessionHandlerInterface
  {
      /**
       * Mongo db config
       *
       * @var array
       */
      protected $config;

      /**
       * Mongo db connection
       * 
       * @var \Mongo
       */
      protected $connection;

      /**
       * Mongodb collection
       * 
       * @var \MongoCollection
       */
      protected $collection;
      /**
       * Create a new Mongo driven handler instance.
       *
       * @param  array $config
       *  - $config['host']       Mongodb host
       *  - $config['username']   Mongodb username
       *  - $config['password']   Mongodb password
       *  - $config['database']     Mongodb database
       *  - $config['collection'] Mongodb collection
       * @return void
       */
      public function __construct(array $config)
      {
          $this-&gt;config = $config;

          $connection_string = 'mongodb://';

          if (!empty($this-&gt;config['username']) &amp;&amp; !empty($this-&gt;config['password'])) {
              $connection_string .= "{$this-&gt;config['user']}:{$this-&gt;config['password']}@";
          }

          $connection_string .= "{$this-&gt;config['host']}";

          $this-&gt;connection = new Mongo($connection_string);

          $this-&gt;collection = $this-&gt;connection-&gt;selectCollection($this-&gt;config['database'], $this-&gt;config['collection']);
      }

      /**
       * {@inheritDoc}
       */
      public function open($savePath, $sessionName)
      {
          return true;
      }

      /**
       * {@inheritDoc}
       */
      public function close()
      {
          return true;
      }

      /**
       * {@inheritDoc}
       */
      public function read($sessionId)
      {
          $session_data = $this-&gt;collection-&gt;findOne(array(
              '_id' =&gt; $sessionId,
          ));

          if (is_null($session_data)) {
              return '';
          } else {
              return $session_data['session_data']-&gt;bin;
          }
      }

      /**
       * {@inheritDoc}
       */
      public function write($sessionId, $data)
      {
          $this-&gt;collection-&gt;update(
              array(
                  '_id' =&gt; $sessionId
              ),
              array(
                  '$set' =&gt; array(
                      'session_data' =&gt; new MongoBinData($data, MongoBinData::BYTE_ARRAY),
                      'timestamp' =&gt; new MongoDate(),
                  )
              ),
              array(
                  'upsert' =&gt; true,
                  'multiple' =&gt; false
              )
          );
      }

      /**
       * {@inheritDoc}
       */
      public function destroy($sessionId)
      {
          $this-&gt;collection-&gt;remove(array(
              '_id' =&gt; $sessionId
          ));

          return true;
      }

      /**
       * {@inheritDoc}
       */
      public function gc($lifetime)
      {
          $time = new MongoDate(time() - $lifetime);

          $this-&gt;collection-&gt;remove(array(
              'timestamp' =&gt; array('$lt' =&gt; $time),
          ));

          return true;
      }
  }
</pre>

<p>You should save this in the <code>vendor/laravel/framework/src/Illuminate/Session</code> folder. For the purposes of this project, we'll put it here, but ideally this file should be within its own library namespace. </p>

<p>Next, we need to make sure that the <code>Manager</code> class can call this driver. We can do this by utilizing the <code>Manager::extend</code> method. Open <code>vendor/laravel/framework/src/Illuminate/Session/SessionServiceProvider.php</code> and add the following code. Ideally, we should be extending the service provider, but that is outside the scope of this tutorial.</p>

<pre class="brush: php">/**
   * Setup the Mongo Driver callback
*
* @return  void
*/
	public function setupMongoDriver()
	{
$manager = $this-&gt;app['session'];

$manager-&gt;extend('mongo', function($app) {
    return new MongoSessionHandler(array(
        'host'       =&gt; $app['config']-&gt;get('session.mongo.host'),
        'username'   =&gt; $app['config']-&gt;get('session.mongo.username'),
        'password'   =&gt; $app['config']-&gt;get('session.mongo.password'),
        'database'   =&gt; $app['config']-&gt;get('session.mongo.database'),
        'collection' =&gt; $app['config']-&gt;get('session.mongo.collection')
    ));
});
	}</pre>

<p>Make sure to update the <code>register()</code> method to call this method:</p>

<pre class="brush: php">/**
   * Register the service provider.
*
* @return void
*/
	public function register()
	{
$this-&gt;setupDefaultDriver();

$this-&gt;registerSessionManager();

$this-&gt;setupMongoDriver();

$this-&gt;registerSessionDriver();
	}</pre>

<p>Next, we need to define the Mongo DB configuration. Open <code>app/config/session.php</code> and define the following configuration settings:</p>

<pre class="brush: php">/**
   * Mongo DB settings
*/
	'mongo' =&gt; array(
'host' =&gt; '127.0.0.1',
'username' =&gt; '',
'password' =&gt; '',
'database' =&gt; 'laravel',
'collection' =&gt; 'laravel_session_collection'
	)</pre>

<p>While we're on this file, we should also update the <code class="inline">driver </code>configuration up top:</p>

<pre class="brush: php">'driver' =&gt; 'mongo'</pre>

<p>Now, try and access the main page (usually, <code>localhost/somefolder/public</code>). If this page loads without showing the <code class="inline">WHOOPS</code> page, then congratulations, we've successfully created a brand new session driver! Test it out by setting some dummy data on the session, via <code>Session::set()</code> and then echoing it back via <code>Session::get()</code>.</p>

<h2>The Auth Component</h2>

<p>The Laravel Auth component handles user authentication for the framework, as well as password management. What the Laravel component has done here is to create an abstract interpretation of the typical user-management system which is usable in most web applications, which in turn helps the programmer easily implement a login system. Like the Session component, it also makes use of the Laravel Manager. Currently, the Auth component has drivers for:</p>

<ul><li><code class="inline">eloquent</code> - this makes use of Laravel's built-in ORM called <code class="inline">Eloquent</code>. It also utilizes the pre-made <code>User.php</code> class inside the <code>models</code> folder.</li>
<li><code class="inline">database</code> - this uses whichever database connection is configured by default. It makes use of a <code>GenericUser</code> class for accessing the user data.</li>
</ul><p>Since this follows the same implementation as the <code>Session</code> component, the service provider is very similar to what we've seen on top:</p>

<pre class="brush: php">/**
   * Register the service provider.
*
* @return void
*/
	public function register()
	{
$this-&gt;app-&gt;bindShared('auth', function($app)
{
	// Once the authentication service has actually been requested by the developer
	// we will set a variable in the application indicating such. This helps us
	// know that we need to set any queued cookies in the after event later.
	$app['auth.loaded'] = true;

	return new AuthManager($app);
});
	}</pre>

<p>Here, we can see that it basically creates an <code>AuthManager</code> class that wraps around whichever driver we're using, as well as acting as a factory for it. Inside the <code>AuthManager</code>, it again creates the appropriate driver, wrapped around a <code>Guard</code> class, which acts the same way as the <code>Store</code> class from <code>Session</code>.</p>

<h3>Creating Our Own Auth Handler</h3>

<p>Like before, let's start by creating a <code>MongoUserProvider</code>:</p>

<pre class="brush: php">&lt;?php namespace Illuminate\Auth;

  use Mongo;
  use Illuminate\Hashing\HasherInterface;

  class MongoUserProvider implements UserProviderInterface {

      /**
       * The mongo instance
       *
       * @param  \Mongo
       */
      protected $connection;

      /**
       * The mongo connection instance
       *
       * @param  \MongoConnection
       */
      protected $collection;

      /**
       * The Mongo config array
       *
       * @var array
       */
      protected $config;

      /**
       * Create a new Mongo user provider.
       *
       * @param  array $config
       *     - $config['host']       Mongodb host
       *     - $config['username']   Mongodb username
       *     - $config['password']   Mongodb password
       *     - $config['database']   Mongodb database
       *     - $config['collection'] Mongodb collection
       * @return void
       */
      public function __construct(array $config)
      {
          $this-&gt;config = $config;

          $connection_string = 'mongodb://';

          if (!empty($this-&gt;config['username']) &amp;&amp; !empty($this-&gt;config['password'])) {
              $connection_string .= "{$this-&gt;config['user']}:{$this-&gt;config['password']}@";
          }

          $connection_string .= "{$this-&gt;config['host']}";

          $this-&gt;connection = new Mongo($connection_string);

          $this-&gt;collection = $this-&gt;connection-&gt;selectCollection($this-&gt;config['database'], $this-&gt;config['collection']);
      }

      /**
       * Retrieve a user by their unique identifier.
       *
       * @param  mixed  $identifier
       * @return \Illuminate\Auth\UserInterface|null
       */
      public function retrieveById($identifier)
      {
          $user_data = $this-&gt;collection-&gt;findOne(array(
              '_id' =&gt; $identifier,
          ));

          if (!is_null($user_data)) {
              return new GenericUser((array) $user_data);
          }
      }

      /**
       * Retrieve a user by the given credentials.
       *
       * @param  array  $credentials
       * @return \Illuminate\Auth\UserInterface|null
       */
      public function retrieveByCredentials(array $credentials)
      {
          // Attempt to look for the user first regardless of password
          // We'll do that in the validateCredentials method
          if (isset($credentials['password'])) {
              unset($credentials['password']);
          }

          $user_data = $this-&gt;collection-&gt;findOne($credentials);

          if (!is_null($user_data)) {
              return new GenericUser((array) $user_data);
          }
      }

      /**
       * Validate a user against the given credentials.
       *
       * @param  \Illuminate\Auth\UserInterface  $user
       * @param  array  $credentials
       * @return bool
       */
      public function validateCredentials(UserInterface $user, array $credentials)
      {
          if (!isset($credentials['password'])) {
              return false;
          }
          
          return ($credentials['password'] === $user-&gt;getAuthPassword());
      }
  }</pre>

<p>It's important to take note here that I'm not checking against a hashed password, this was done for simplicity's sake to make it easier on our part to create dummy data and test this later. In production code, you need to make sure to hash the password. Check out theÂ <code>Illuminate\Auth\DatabaseUserProvider</code> class for a great example on how to do this.</p>

<p>Afterwards, we need to register our custom driver callback on the <code>AuthManager</code>. To do so, we need to update the service provider's <code class="inline">register</code> method:</p>

<pre class="brush: php">/**
   * Register the service provider.
*
* @return void
*/
	public function register()
	{
$this-&gt;app-&gt;bindShared('auth', function($app)
{
	// Once the authentication service has actually been requested by the developer
	// we will set a variable in the application indicating such. This helps us
	// know that we need to set any queued cookies in the after event later.
	$app['auth.loaded'] = true;

	$auth_manager = new AuthManager($app);

	$auth_manager-&gt;extend('mongo', function($app) {
		return new MongoUserProvider(
			array(
				'host'       =&gt; $app['config']-&gt;get('auth.mongo.host'),
		        'username'   =&gt; $app['config']-&gt;get('auth.mongo.username'),
		        'password'   =&gt; $app['config']-&gt;get('auth.mongo.password'),
		        'database'   =&gt; $app['config']-&gt;get('auth.mongo.database'),
		        'collection' =&gt; $app['config']-&gt;get('auth.mongo.collection')
			)
		);
	});

	return $auth_manager;
});
	}</pre>

<p>Lastly, we also need to update the <code>auth.php</code> configuration file to make use of the Mongo driver, as well as provide it the proper Mongo configuration values:</p>

<pre class="brush: php">'driver' =&gt; 'mongo',
  ...
  ...
  ...
  /**
   * Mongo DB settings
*/
	'mongo' =&gt; array(
'host' =&gt; '127.0.0.1',
'username' =&gt; '',
'password' =&gt; '',
'database' =&gt; 'laravel',
'collection' =&gt; 'laravel_auth_collection'
	)</pre>

<p>Testing this is a little trickier, to do so, use the Mongo DB CLI to insert a new user into the collection:</p>

<pre class="brush: bash">mongo

  &gt; use laravel_auth
  switched to db laravel_auth
  &gt; db.laravel_auth_collection.insert({id: 1, email:"nikko@nikkobautista.com", password:"test_password"})
  &gt; db.laravel_auth_collection.find()
  &gt; { "_id" : ObjectId("530c609f2caac8c3a8e4814f"), "id" 1, "email" : "nikko@emailtest.com", "password" : "test_password" }</pre>

<p>Now, test it out by trying an <code>Auth::validate</code> method call:</p>

<pre class="brush: php">var_dump(Auth::validate(array('email' =&gt; 'nikko@emailtest.com', 'password' =&gt; 'test_password')));</pre>

<p>This should dump a <code>bool(true)</code>. If it does, then we've successfully created our own Auth driver!</p>

<h2>The Cache Component</h2>

<p>The Laravel Cache component handles caching mechanisms for use in the framework. Like both of theÂ components that we've discussed, it also makes use of the Laravel Manager (Are you noticing a pattern?). The Cache component has drivers for:</p>

<ul><li><code class="inline">apc</code></li>
<li><code class="inline">memcached</code></li>
<li><code class="inline">redis</code></li>
<li><code class="inline">file</code> - a file-based cache. Data is saved into the <code>app/storage/cache</code> path.</li>
<li><code class="inline">database</code> - database-based cache. Data is saved into rows into the database. The database schema is described in the <a href="http://laravel.com/docs/cache" target="_self">Laravel Documentation</a>.</li>
<li><code class="inline">array</code> - data is "cached" in an array. Keep in mind that the <code>array</code> cache is not persistent and is cleared on every page load.</li>
</ul><p>Since this follows the same implementation as both components that we've discussed, you can safely assume that the service provider is fairly similar:</p>

<pre class="brush: php">/**
   * Register the service provider.
*
* @return void
*/
	public function register()
	{
$this-&gt;app-&gt;bindShared('cache', function($app)
{
	return new CacheManager($app);
});

$this-&gt;app-&gt;bindShared('cache.store', function($app)
{
	return $app['cache']-&gt;driver();
});

$this-&gt;app-&gt;bindShared('memcached.connector', function()
{
	return new MemcachedConnector;
});

$this-&gt;registerCommands();
	}</pre>

<p>The <code>register()</code> method here creates a <code>CacheManager</code>, that again acts as a wrapper and factory for the drivers. Within the manager, it wraps the driver around a <code>Repository</code> class, similar to the <code>Store</code> and <code>Guard</code> classes.</p>

<h3>Creating Our Own Cache Handler</h3>

<p>Create the <code>MongoStore</code>, which should extend the <code>Illuminate\Cache\StoreInterface</code>:</p>

<pre class="brush: php">&lt;?php namespace Illuminate\Cache;

  use Mongo;

  class MongoStore implements StoreInterface
  {
      /**
       * The mongo instance
       *
       * @param  \Mongo
       */
      protected $connection;

      /**
       * The mongo connection instance
       *
       * @param  \MongoConnection
       */
      protected $collection;

      /**
       * The Mongo config array
       *
       * @var array
       */
      protected $config;

      /**
       * Create a new Mongo cache store.
       *
       * @param  array $config
       *     - $config['host']       Mongodb host
       *     - $config['username']   Mongodb username
       *     - $config['password']   Mongodb password
       *     - $config['database']   Mongodb database
       *     - $config['collection'] Mongodb collection
       * @return void
       */
      public function __construct(array $config)
      {
          $this-&gt;config = $config;

          $connection_string = 'mongodb://';

          if (!empty($this-&gt;config['username']) &amp;&amp; !empty($this-&gt;config['password'])) {
              $connection_string .= "{$this-&gt;config['user']}:{$this-&gt;config['password']}@";
          }

          $connection_string .= "{$this-&gt;config['host']}";

          $this-&gt;connection = new Mongo($connection_string);

          $this-&gt;collection = $this-&gt;connection-&gt;selectCollection($this-&gt;config['database'], $this-&gt;config['collection']);
      }

      /**
       * Retrieve an item from the cache by key.
       *
       * @param  string  $key
       * @return mixed
       */
      public function get($key)
      {
          $cache_data = $this-&gt;getObject($key);

          if (!$cache_data) {
              return null;
          }

          return unserialize($cache_data['cache_data']);
      }

      /**
       * Return the whole object instead of just the cache_data
       * 
       * @param  string  $key
       * @return array|null
       */
      protected function getObject($key)
      {
          $cache_data = $this-&gt;collection-&gt;findOne(array(
              'key' =&gt; $key,
          ));

          if (is_null($cache_data)) {
              return null;
          }

          if (isset($cache_data['expire']) &amp;&amp; time() &gt;= $cache_data['expire']) {
              $this-&gt;forget($key);
              return null;
          }

          return $cache_data;
      }

      /**
       * Store an item in the cache for a given number of minutes.
       *
       * @param  string  $key
       * @param  mixed   $value
       * @param  int     $minutes
       * @return void
       */
      public function put($key, $value, $minutes)
      {
          $expiry = $this-&gt;expiration($minutes);

          $this-&gt;collection-&gt;update(
              array(
                  'key' =&gt; $key
              ),
              array(
                  '$set' =&gt; array(
                      'cache_data' =&gt; serialize($value),
                      'expiry' =&gt; $expiry,
                      'ttl' =&gt; ($minutes * 60)
                  )
              ),
              array(
                  'upsert' =&gt; true,
                  'multiple' =&gt; false
              )
          );
      }

      /**
       * Increment the value of an item in the cache.
       *
       * @param  string  $key
       * @param  mixed   $value
       * @return void
       *
       * @throws \LogicException
       */
      public function increment($key, $value = 1)
      {
          $cache_data = $this-&gt;getObject($key);

          if (!$cache_data) {
              $new_data = array(
                  'cache_data' =&gt; serialize($value),
                  'expiry' =&gt; $this-&gt;expiration(0),
                  'ttl' =&gt; $this-&gt;expiration(0)
              );
          } else {
              $new_data = array(
                  'cache_data' =&gt; serialize(unserialize($cache_data['cache_data']) + $value),
                  'expiry' =&gt; $this-&gt;expiration((int) ($cache_data['ttl']/60)),
                  'ttl' =&gt; $cache_data['ttl']
              );
          }

          $this-&gt;collection-&gt;update(
              array(
                  'key' =&gt; $key
              ),
              array(
                  '$set' =&gt; $new_data
              ),
              array(
                  'upsert' =&gt; true,
                  'multiple' =&gt; false
              )
          );
      }

      /**
       * Decrement the value of an item in the cache.
       *
       * @param  string  $key
       * @param  mixed   $value
       * @return void
       *
       * @throws \LogicException
       */
      public function decrement($key, $value = 1)
      {
          $cache_data = $this-&gt;getObject($key);

          if (!$cache_data) {
              $new_data = array(
                  'cache_data' =&gt; serialize((0 - $value)),
                  'expiry' =&gt; $this-&gt;expiration(0),
                  'ttl' =&gt; $this-&gt;expiration(0)
              );
          } else {
              $new_data = array(
                  'cache_data' =&gt; serialize(unserialize($cache_data['cache_data']) - $value),
                  'expiry' =&gt; $this-&gt;expiration((int) ($cache_data['ttl']/60)),
                  'ttl' =&gt; $cache_data['ttl']
              );
          }

          $this-&gt;collection-&gt;update(
              array(
                  'key' =&gt; $key
              ),
              array(
                  '$set' =&gt; $new_data
              ),
              array(
                  'upsert' =&gt; true,
                  'multiple' =&gt; false
              )
          );
      }

      /**
       * Store an item in the cache indefinitely.
       *
       * @param  string  $key
       * @param  mixed   $value
       * @return void
       */
      public function forever($key, $value)
      {
          return $this-&gt;put($key, $value, 0);
      }

      /**
       * Remove an item from the cache.
       *
       * @param  string  $key
       * @return void
       */
      public function forget($key)
      {
          $this-&gt;collection-&gt;remove(array(
              'key' =&gt; $key
          ));
      }

      /**
       * Remove all items from the cache.
       *
       * @return void
       */
      public function flush()
      {
          $this-&gt;collection-&gt;remove();
      }

      /**
       * Get the expiration time based on the given minutes.
       *
       * @param  int  $minutes
       * @return int
       */
      protected function expiration($minutes)
      {
          if ($minutes === 0) return 9999999999;

          return time() + ($minutes * 60);
      }

      /**
       * Get the cache key prefix.
       *
       * @return string
       */
      public function getPrefix()
      {
          return '';
      }
  }</pre>

<p>We'll also need to add the Mongo callback again to the manager:</p>

<pre class="brush: php">/**
   * Register the service provider.
*
* @return void
*/
	public function register()
	{
$this-&gt;app-&gt;bindShared('cache', function($app)
{
	$cache_manager = new CacheManager($app);

	$cache_manager-&gt;extend('mongo', function($app) {
		return new MongoStore(
			array(
				'host'       =&gt; $app['config']-&gt;get('cache.mongo.host'),
		        'username'   =&gt; $app['config']-&gt;get('cache.mongo.username'),
		        'password'   =&gt; $app['config']-&gt;get('cache.mongo.password'),
		        'database'   =&gt; $app['config']-&gt;get('cache.mongo.database'),
		        'collection' =&gt; $app['config']-&gt;get('cache.mongo.collection')
			)
		);
	});

	return $cache_manager;
});

$this-&gt;app-&gt;bindShared('cache.store', function($app)
{
	return $app['cache']-&gt;driver();
});

$this-&gt;app-&gt;bindShared('memcached.connector', function()
{
	return new MemcachedConnector;
});

$this-&gt;registerCommands();
	}</pre>

<p>Lastly, we'll need to update the <code>cache.php</code> config file:</p>

<pre class="brush: php">'driver' =&gt; 'mongo',
  ...
  ...
  ...
  /**
* Mongo DB settings
*/
	'mongo' =&gt; array(
'host' =&gt; '127.0.0.1',
'username' =&gt; '',
'password' =&gt; '',
'database' =&gt; 'laravel',
'collection' =&gt; 'laravel_cache_collection'
	)</pre>

<p>Now, attempt to use the <code>Cache::put()</code> and <code>Cache::get()</code> methods. If done correctly, we should be able to use MongoDB to cache the data!</p>

<h2>Conclusion</h2>

<p>In this tutorial, we learned about the following:</p>

<ul><li>Laravel's component-based system called <code>Illuminate</code>, which is used by the Laravel framework.</li>
<li>Laravel Service Providers and a little bit about how they work.</li>
<li>Laravel's Manager system, which acts as both a wrapper and factory for the drivers.</li>
<li>Session, Auth and Cache components and how to create new drivers for each.</li>
<li>Store, Guard and Repository libraries which utilize these drivers.</li>
</ul>

<p>Hopefully this helps programmers create their own drivers and extend the current functionality of the Laravel framework.</p>