<h1>28 Recursos, Dicas e Técnicas Sobre HTML5 Que Você Deve Saber</h1>

<p>
Essa indústria evolui rápido &ndash; muito rápido! Se não tomar cuidado, você ficará para trás, comendo poeira. Então, se você está se sentido sobrecarregado pelas mudanças/atualizações que vieram com o HTML5, use esse artigo como um ponta-pé inicial para o que você precisa saber.</p>

<h2><span class="sectionnum">1.</span> Novo Doctype </h2>

<p>
Você ainda usa aquele doctype complicado e de difícil memorização do XHTML??</p>

<pre class="brush: html">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</pre>

<p>Se sim, por que? Mude para o novo doctype do HTML5. Você viverá mais &ndash; como o Douglas Quaid diria. </p>

<pre class="brush: html">&lt;!DOCTYPE html&gt;</pre>

<p>Na verdade, você sabia que ele não é necessário para um documento HTML5? Entretanto, ele é usado pelos navegadores atuais e antigos que requerem que seja especificado um <code>doctype</code>. Os navegadores que não entendem esse doctype, simplesmente, renderizarão o código no modo padrão. Assim, não se preocupe, sinta-se livre para mandar o medo embora e adote o novo doctype do HTML5. </p>


<h2><span class="sectionnum">2.</span> O Elemento Figure </h2>

<p>
Considere o seguinte código para uma imagem:</p>

<pre class="brush: html">&lt;img src="path/to/image" alt="Sobre a Imagem" /&gt;
&lt;p&gt;Imagem de Marte. &lt;/p&gt;</pre>

<p>Não há, infelizmente, uma maneira fácil ou semântica de associar a legenda, dentro da tag <code>&lt;p&gt;</code>, com o elemento <code>&lt;img&gt;</code> em si. O HTML5 corrige isso, introduzindo o elemento <code>&lt;figure&gt;</code>. Quando combinada com o elemento <code>&lt;figcaption&gt;</code>, nós podemos, agora, associar a legenda com sua respectiva imagem. </p>

<pre class="brush: html">&lt;figure&gt;
	&lt;img src="path/to/image" alt="Sobre a Imagem" /&gt;
	&lt;figcaption&gt;
&lt;p&gt;Isso é uma imagem de algo interessante. &lt;/p&gt;
	&lt;/figcaption&gt;
&lt;/figure&gt;</pre>


<h2><span class="sectionnum">3.</span> &lt;small&gt; Redefinido </h2>

<p>Há não muito tempo atrás, eu usava o elemento <code>&lt;small&gt;</code> para criar subtítulos que estavam relativamente relacionados à logo. É um elemento de apresentação bastante útil, porém, esse é um usso errôneo, agora. O elemento <code>small</code> foi redefinido, para referir-se, de maneira mais apropriada, às "letras miúdas". Imagine uma afirmação de direitos autorais (<em>copyright</em>) no rodapé do seu site. De acordo com a nova definição desse elemento no HTML5, utilizar o elemento <code>&lt;small&gt;</code> seria a escolha correta para esse tipo de informação. </p>

<blockquote><p>O elemento <code>small</code>, agora, refere-se às "letras miúdas". </p>
</blockquote>


<h2>4. Sem Mais <code>Types</code> Para Scripts e Links</h2>

<p>Você, possívelmente, ainda adiciona o atributo <code>type</code> às suas tags <code>link</code> e <code>script</code>. </p>

<pre class="brush: html">&lt;link rel="stylesheet" href="path/to/stylesheet.css" type="text/css" /&gt;
&lt;script type="text/javascript" src="path/to/script.js"&gt;&lt;/script&gt;</pre>

<p>Isso não é mais necessário. Está implícito que ambas as tags referem-se a folhas de estilo e scripts, respectivamente. Assim, podemos remover o atributo <code>type</code> por completo. </p>

<pre class="brush: html">&lt;link rel="stylesheet" href="path/to/stylesheet.css" /&gt;
&lt;script src="path/to/script.js"&gt;&lt;/script&gt;</pre>


<h2><span class="sectionnum">5.</span> Com Ou Sem Aspas  </h2>

<p>...Eis a questão. Lembre-se, HTML5 não é XHTML. Você não precisa envolver os valores de seus atributos em aspas, se não quiser. Você também não precisa fechar seus elemento. Tendo dito, não há nada errado se o fizer, caso se sinta mais confortável fazendo. Eu estou nesse último grupo. </p>

<pre class="brush: html">&lt;p class=myClass id=someId&gt; Iniciar o reator.</pre>

<p>Faça sua escolha com relação a esse ponto. Se você preferir um documento mais estruturado, você pode continuar com as aspas. </p>


<h2><span class="sectionnum">6.</span> Torne Seu Conteúdo Editável</h2>

<figure class="post_image"><img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/30/posts/12357/image/contenteditable.png" /></figure><p>Os novos navegadores tem um novo atributos interessante que pode ser adicionado aos elementos, chamado de <code>contenteditable</code>. Como o nome implica, isso permite que o usuário edite qualquer texto contido dentro do elemento, incluindo seus filhos. Há inúmeros usos para algo assim, incluindo as simples listas de tarefas, que também podem lançar mão do armazenamento local. </p>

<pre class="brush: html">&lt;!DOCTYPE html&gt;

&lt;html lang="en"&gt;
&lt;head&gt;
	&lt;meta charset="utf-8"&gt;
	&lt;title&gt;untitled&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;h2&gt; Lista de Tarefas &lt;/h2&gt;
   &lt;ul contenteditable="true"&gt;
&lt;li&gt; Quebrar um motorista robô. &lt;/li&gt;
&lt;li&gt; Dirigir até uma fábrica abandonada
&lt;li&gt; Ver vídeos de mim mesmo &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

<p>Ou, como aprendemos na dica anterior, poderíamos ter escrito como: </p>

<pre class="brush: html">&lt;ul contenteditable=true&gt;</pre>


<h2><span class="sectionnum">7.</span> Campos de E-mail </h2>

<p>Se aplicarmos o valor "email" ao atributo <code>type</code> de algum campo de formulário, podemos instruir o navegador a <em>só</em> permitir cadeias de caracteres que sigam as regras de estrutura de um endereço de e-mail válido. É verdade. Validação de formulários logo-logo nos navegadores! Não podemos depender 100% dessa validação, ainda, por questões óbvias. Em navegadores antigos, que não entendem esse valor "email", eles simplesmente criaram um campo de texto padrão. </p>

<pre class="brush: html">&lt;!DOCTYPE html&gt;

&lt;html lang="en"&gt;
&lt;head&gt;
	&lt;meta charset="utf-8"&gt;
	&lt;title&gt;untitled&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;form action="" method="get"&gt;
&lt;label for="email"&gt;Email:&lt;/label&gt;
&lt;input id="email" name="email" type="email" /&gt;

&lt;button type="submit"&gt; Enviar Formulário &lt;/button&gt;
	&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

<figure class="post_image"><img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/30/posts/12357/image/email_validation.png" /></figure>

<blockquote><p>Nesse momento, não podemos depender de validação dos navegadores. Soluções tanto no cliente quando no servidor devem ser implementadas.  </p>
</blockquote>

<p>Deve-se perceber que todos os navegadores atuais são um pouco instável quanto aos elementos e atributos que eles suportam ou não. Por exemplo, o Opera parece que dá suporte a validação de e-mails, desde que o atributo <code>name</code> seja especificado. Entretanto, ele não dá suporte ao atributo <code>placeholder</code>, sobre o qual aprenderemos na próxima dica. No fim das contas, não dependa desse tipo de validação de formulário, ainda... Mas, você já pode utilizá-lo!</p>


<h2><span class="sectionnum">8.</span> Placeholders </h2>

<p>
Antes de utilizar um pouco de JavaScript para criar textos indicativos (placeholder), utilize o atributo placeholder para os campos de texto de seus formulários. Claro, você pode atribuir valor inicial através de <code>value</code> e isso funciona, mas, tão logo o usuário apaga o texto e clica/seleciona outra coisa, o campo continua em branco. O atributo <code>placeholder</code> remedia essa situação.</p>

<pre class="brush: html">&lt;input name="email" type="email" placeholder="doug@givethesepeopleair.com" /&gt;</pre>

<p>DE novo, o suporte é impreciso entre os navegadore, porém, a situação melhorará a cada nova versão dos navegadores. Além disso, se os navegadores, como o Firefox ou Opera, não dão suporte, atualmente, ao atributo <code>placeholder</code>, não há perigo algum. </p>

<figure class="post_image"><img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/30/posts/12357/image/validation.png" /></figure>

<h2><span class="sectionnum">9.</span> Armazenamento Local</h2>

<p>
 Graças ao armazenamento local (não faz parte, oficialmente, do HTML5, mas foi agrupado por conveniência), podemos fazer com que navegadores avançados "lembre-se" do que digitamos, mesmo depois que o nosso navegador é fechado ou recarregado.</p>

<figure data-video-embed="true" data-original-url="https://www.youtube.com/watch?v=h0uZIljjElo" class="embedded-video"><iframe src="//www.youtube.com/embed/h0uZIljjElo?rel=0" frameborder="0" webkitallowfullscreen="webkitallowfullscreen" mozallowfullscreen="mozallowfullscreen" allowfullscreen="allowfullscreen"></iframe>
</figure>

<blockquote>
<p>"<code>localStorage</code> guarda os campos com relação ao domínio. Mesmo que você feche a janela do seu navegador, reabra e volte ao site, ele lembrará de todos os campos na <code>localStorage</code>."<br />-<a href="http://www.quirksmode.org/blog/archives/2009/06/html5_storage_t.html">QuirksBlog</a></p>
</blockquote>

<p>Uma vez que, obviamente, não é suportado por todos os navegadores, podemos esperar que esse método funcione, mais notavelmente, no Internet Explorer 8, Safari 4 e Firefox 3.5. Note que, para compensar os navegadores antigos que não reconhecem armazenamento local, você deveria, primeiro, verificar se <code>window.localStorage</code> existe. </p><figure class="post_image"><img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/30/posts/12357/image/macwin.png" /><figcaption>via <a href="http://www.findmebyip.com/litmus/">http://www.findmebyip.com/litmus/</a></figcaption></figure>

<h2><span class="sectionnum">10. </span>Os <code>Header</code> e <code>Footer</code> Semânticos</h2>

<p>
Já se foram os dias de:</p>

<pre class="brush: html">&lt;div id="header"&gt;
	...
&lt;/div&gt;

&lt;div id="footer"&gt;
	...
&lt;/div&gt;</pre>

<p><code>Div</code>s, por natureza, não tem estrutura semântica &ndash; mesmo após que atributos <code>id</code> são aplicados. Agora, com o HTML5, temos acesso aos elementos <code>&lt;header&gt;</code> e <code>&lt;footer&gt;</code>. O código acima pode ser substituido pelo de logo abaixo:</p>

<pre class="brush: html">&lt;header&gt;
	...
&lt;/header&gt;

&lt;footer&gt;
	...
&lt;/footer&gt;</pre>

<blockquote><p>É totalmente aceitável possuir vários <code>header</code>s e <code>footer</code>s em seus projetos. </p>
</blockquote>

<p>Tente não confundir esses elementos com os "cabeçalho" e "rodapé" do seu site. Eles referem-se, somente, ao receptáculo. Assim, faz todo sentido, posicionar, por exemplo, meta-informações na prte de baixo de um artigo de um blog, dentro de um elemento <code>footer</code>. O mesmo é verdadeiro para o elemento <code>header</code>. </p>


<h2><span class="sectionnum">11.</span> Mais Recuros de Formulários no HTML5 </h2>

<p>Aprenda mais sobre os recursos úteis de formulários do HTML5 nessa dica rápida em video.</p>

<figure data-video-embed="true" data-original-url="https://www.youtube.com/watch?v=spjOAFGxOP0" class="embedded-video"><iframe src="//www.youtube.com/embed/spjOAFGxOP0?rel=0" frameborder="0" webkitallowfullscreen="webkitallowfullscreen" mozallowfullscreen="mozallowfullscreen" allowfullscreen="allowfullscreen"></iframe></figure>

<h2><span class="sectionnum">12.</span> Internet Explorer e HTML5</h2>

<p>
Infelizmente, o tal do Internet Explorer precisa dar uma volta danada para entender esses elementos HTML5 novos.</p>

<blockquote><p>Todos os elementos, por padrão, possuem o valor <code>inline</code> para a propriedade <code>display</code>. </p>
</blockquote>

<p>Para garantir que esses novos elementos HTML5 renderizem corretamente como elementos de tipo bloco, é necessário, por enquanto, estilizados como tal. </p>

<pre class="brush: css">header, footer, article, section, nav, menu {
 display: block;
}</pre>

<p>Infelizmente, o Internet Explorer ignorará esses estilos, porque elee não tem a menor ideia do que o elemento <code>header</code> é, por exemplo. Felizmente, há uma maneira fácil de corrigir isso: </p>

<pre class="brush: javascript">document.createElement("article");
document.createElement("footer");
document.createElement("header");
document.createElement("nav");
document.createElement("menu");</pre>

<p>Por mais estranho que seja, esse código ativa o Internet Explorer. Para simplificar esse processo para cada nova aplicação, Remy Sharp <a href="http://remysharp.com/2009/01/07/html5-enabling-script/">criou um script</a>, comumente chamado de <em>HTML5 shiv</em>. Esse script também ajusta alguns problems de impressão também. </p>

<pre class="brush: html">&lt;!--[if IE]&gt;
&lt;script src="http://html5shim.googlecode.com/svn/trunk/html5.js"&gt;&lt;/script&gt;
&lt;![endif]--&gt;</pre>


<h2><span class="sectionnum">13.</span> hgroup*</h2>

<p>*Desde a primeira publicação desse artigo, o <a href="http://www.w3.org/html/wg/drafts/html/master/obsolete.html#non-conforming-features" target="_self">elemento <code>hgroup</code> tornou-se obsoleto</a> e não deve mais ser usado.</p>


<h2><span class="sectionnum">14.</span> Atributo Required </h2>

<p>Campos de formulários permitem um novo atributo, o <code>required</code>, que especifica, logicamente, se um campo em particular é obrigatório. Dependendo da sua preferência de codificação, você pode declarar esse atributo de duas maneiras: </p>

<pre class="brush: html">&lt;input type="text" name="someInput" required&gt;</pre>

<p>Ou, de forma mais estruturada. </p>

<pre class="brush: html">&lt;input type="text" name="someInput" required="required"&gt;</pre>

<p>Ambas as formas funcionarão. Com esse código, dentro dos navegadores que dão suporte ao atributo, um formulário não pode ser enviado com o campo "someInput" em branco. Eis um exemplo simples: Também adicionaremos o atributo <code>placeholder</code>, já que não há razão para não fazê-lo.</p>

<pre class="brush: html">&lt;form method="post" action=""&gt;
	&lt;label for="someInput"&gt; Your Name: &lt;/label&gt;
	&lt;input type="text" id="someInput" name="someInput" placeholder="Douglas Quaid" required&gt;
	&lt;button type="submit"&gt;Go&lt;/button&gt;
&lt;/form&gt;</pre>

<figure class="post_image"><img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/30/posts/12357/image/placeholder_required.png" /></figure><p>Se o campo for deixado em branco e o formulário for enviado, o campo em questão ficará em destaque. </p>


<h2><span class="sectionnum">15.</span> Atributo Autofocus </h2>

<p>
Novamente, o HTML5 acaba com a necessidade de soluções em JavaScript. Se um campo em particular deveria estar "selecionado", ou em foco, por padrão, nós podemos utilizar, agora, o atributo <code>autofocus</code>.</p>

<pre class="brush: html">&lt;input type="text" name="someInput" placeholder="Douglas Quaid" required autofocus&gt;</pre>

<p>De forma interessante, enquanto eu prefiro escrever de uma forma mais parecida com a do XHTML (usando aspas, etc), escrever o atributo como <code>autofocus="autofocus"</code> fica bem estranho. Assim, usaremos o atributo sozinho. </p>


<h2><span class="sectionnum">16.</span> Suporte a Áudio </h2>

<p>Não precisamos mais depender de plugins de terceiros para renderizar áudios. O HTML5 oferece, agora, o elemento <code>&lt;audio&gt;</code>. Bem, ao menos, algum dia, não precisaremos depender desses plugins. Por enquanto, somente os navegadores mais recentes dão suporte a esse elemento. Assim, é uma boa prática oferece alguma forma de retrocompatibilidade.  </p>

<pre class="brush: html">&lt;audio autoplay="autoplay" controls="controls"&gt;
	&lt;source src="file.ogg" /&gt;
	&lt;source src="file.mp3" /&gt;
	<a>Download this file.</a>
&lt;/audio&gt;</pre>

<p>A Mozilla e o Webkit ainda não andam juntas, quando se trata dos formatos de áudio suportados. O Firefox quer que o tipo .ogg prevaleça, enquanto o Webkit trabalham, sem problemas, com o formato mp3. Isso significa, pelo menos por hora, você deve criar duas versões do seu áudio.</p>

<p>Quando o Safari carregar a página, ele não reconhecerá o formato .ogg e pulará, seguindo em busca do formato mp3. Note que o IE, como sempre, não dá suporte, e o Opera 10 ou anterior só trabalham com arquivos do tipo .wav. </p>


<h2><span class="sectionnum">17.</span>  Suporte a Vídeo</h2>

<p>Assim como com o elemento <code>&lt;audio&gt;</code>, nós também temos, claro, o elemento <code>video</code> do HTML5 nos navegadores! Na verdade, recentemente, <a href="http://apiblog.youtube.com/2010/07/new-way-to-embed-youtube-videos.html">o YouTube anunciou o HTML5 como uma nova opção de formato para seus vídeos embutidos</a>, para aqueles navegadores que o suportam. Infelizmente, novamente, o especificação HTML5 não especifica um decodificador de vídeo padrão, deixando para que os criadores dos navegadores decidam. Enquanto o Safari e o Internet Explorer 9 dão suporte ao formato H.264 (o qual os reprodutores em Flash podem executar), o Firefox e o Opera escolheram os formatos de código aberto, Theora e Vorbis. Dessa forma, quando precisar apresentar algum vídeo com o HTML5, deverá apresentar ambos os formatos. </p>

<pre class="brush: html">&lt;video controls preload&gt;
	&lt;source src="cohagenPhoneCall.ogv" type="video/ogg; codecs='vorbis, theora'" /&gt;
	&lt;source src="cohagenPhoneCall.mp4" type="video/mp4; 'codecs='avc1.42E01E, mp4a.40.2'" /&gt;
	&lt;p&gt; Seu navegador é antigo. &lt;a href="cohagenPhoneCall.mp4"&gt;Ao invés disso, baixe o arquivo.&lt;/a&gt; &lt;/p&gt;
&lt;/video&gt;</pre>

<blockquote><p>O navegador Chrome pode mostrar, corretamente, videos codificados nos formatos "ogg" e "mp4". </p>
</blockquote>

<p>Há alguns pontos importantes a levantar, porém. </p>

<ol>
<li>Tecnicamente, não precisamos preencher o atritbuto <code>type</code>; entretanto, se não o fizermos, o navegador terá de descobrir o tipo por conta própria. Economize banda e declare.  </li>
<li>Nem todos os navegadores compreender a tag <code>video</code> do HTML5. Logo após os elementos <code>source</code>, podemos oferecer um link para download ou uma versão em Flash. Fica a seu critétio. </li>
<li> Os atributos <code>controls</code> e <code>preload</code> serão discutidos nas duas próximas dicas. </li>
</ol>

<h2><span class="sectionnum">18.</span> Precarregue os Vídeos </h2>

<p>O atributo <code>preload</code> faz exatamente o que você está imaginando. Embora, com isso, você tenha de decidir, primeiro, se quer ou não que o navegador precarregue o video. É necessário? Talvez, se o visitante acessar uma página própria para visualização de vídeos, você, definitivamente, deve precarregar o video e evitar que o usuário tenha de esperar muito tempo. Vídeos podem ser precarregados atribuindo <code>preload="preload"</code>, ou, simplesmente, adicionando o atributo <code>preload</code> sozinho. Prefiro a segunda solução, é bem menos redundante.</p>

<pre class="brush: html">&lt;video preload&gt;</pre>


<h2><span class="sectionnum">19.</span> Mostrar Controles </h2>

<p>Se você tem seguido cada uma dessas dicas e técnicas, talvez tenha percebido que, com o código acima, o vídeo aparece como se fosse uma imagem, sem qualquer controle. Para renderizar esses controles, devemos especificar o atributo <code>controls</code> dentro do elemento <code>video</code>. </p>

<pre class="brush: html">&lt;video preload controls&gt;</pre><figure class="post_image"><img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/30/posts/12357/image/video.jpg" /></figure><p>Atente que cada navegador renderiza seus tocadores de vídeo diferente um dos outros. </p>


<h2><span class="sectionnum">20.</span> Expressões REgulares </h2>

<p>Quantas vezes você teve de criar expressões regulares para validar algum campo? Graças ao novo atributo <code>pattern</code>, podemos inserir uma expressão regular diretamente no código HTML. </p>

<pre class="brush: html">&lt;form action="" method="post"&gt;
	&lt;label for="username"&gt;Crie um usuário: &lt;/label&gt;
 	&lt;input type="text"
  name="username"
  id="username"
  placeholder="4 &lt;&gt; 10"
  pattern="[A-Za-z]{4,10}"
  autofocus
  required&gt;
	&lt;button type="submit"&gt;Continuar &lt;/button&gt;
&lt;/form&gt;</pre>

<p>Se você tem certo conhecimento de expressões regulares, você saberá que o padrão <code>[A-Za-z]{4,10}</code> aceita, somente, letras em maiúsculo e/ou minúsculo. E essa cadeia de caracteres deve ter o mínimo de quatro caracteres e o máximo de dez. </p>

<p>Note que estamos começando a combinar todos esses atributos incríveis! </p>

<p><em>Se expressões regulares estão além do seu conhecimento, <a href="http://net.tutsplus.com/tutorials/javascript-ajax/you-dont-know-anything-about-regular-expressions/">dê uma olhada nisso</a>. </em></p>


<h2><span class="sectionnum">21.</span> Detectar Suporte a Atributos </h2>

<p>De que adianta ter esses atributos se não temos uma maneira de saber se o navegador os reconhce? Bem, esse é um ótimo ponto, mas há inúmeras maneiras de determinar isso. Discutiremos duas. A primeira opção é utilizar a excelente biblioteca <a href="http://modernizr.com">Modernizr</a>. Alternativamente, podemos criar e dissecar esses elementos para determinar do que são capazes os navegadores. Por exemplo, em nosso exemplo anterior, se quisermos descobrir se um navegador implementa o atributo <code>pattern</code>, poderíamos usar esse trecho JavaScript:</p>

<pre class="brush:">alert( 'pattern' in document.createElement('input') ) // boolean;</pre>

<p>Na verdade, esse é um método bem popular de descobrir a compatibilidade de um navegador. A bibioteca jQuery utiliza esse truque. Acima, criamos um novo elemento <code>input</code> e determinamos se o atributo <code>pattern</code> faz parte de seus atributos. Se sim, o navegador suporta a funcionalidade. Caso contrário, não suporta. </p>

<pre class="brush:">&lt;script&gt;
if (!'pattern' in document.createElement('input') ) {
	// realize validação do lado cliente e do servidor
}
&lt;/script&gt;</pre>

<p><em>Tenha em mente que essa técnica depende do JavaScript! </em></p>


<h2><span class="sectionnum">22.</span> Elemento Mark</h2>

<p>
Pense no elemento <code>&lt;mark&gt;</code> como um destacador. Uma cadeia de caracteres envolta nessa tag deveria ser relevante às ações do usuário no momento. Por exemplo, se eu pesquisa por "Open your Mind" em algum blog, eu poderia utilizar JavaSCript para envolver todas as ocorrências dessa cadeia de caracteres dentro de elementos <code>&lt;mark&gt;</code>. </p>

<pre class="brush: html">&lt;h3&gt; Resultados da Busca &lt;/h3&gt;
&lt;p&gt; They were interrupted, just after Quato said, &lt;mark&gt;"Open your Mind"&lt;/mark&gt;. &lt;/p&gt;</pre>


<h2><span class="sectionnum">23.</span> Quando Usar &lt;div&gt; </h2>

<p>Alguns de nós nos questionamos quando deveríamos usar as boas e velhas <code>div</code>s. Agora que temos acesso aos elementos <code>header</code>s, <code>article</code>s, <code>section</code>s, e <code>footer</code>s, ainda há necessidade de usarmos uma...<code>div</code>? Claro. </p>

<blockquote>
<p><code>Div</code>s deveriam ser utilizadas quando não houver outro melhor elemento em questão. </p>
</blockquote>

<p>Por exemplo, se você se encontrar na necessidade de envolver algum bloco de código dentro de um elemento recipiente, especificamente, para posicionar o conteúdo, uma <code>&lt;div&gt;</code> faz todo o sentido. Entretanto, se você estiver interessado em envolver um novo post de blog, ou, talvez, uma lista de links em seu rodapé, considere usar os elementos <code>&lt;article&gt;</code> e <code>&lt;nav&gt;</code>, respectivamente. Eles são bem mais semânticos. </p>


<h2><span class="sectionnum">24.</span> O Que Já É Possível Usar</h2>

<p>
Com toda essa discussão sobre o HTML5 <a href="http://blogs.techrepublic.com.com/programming-and-development/?p=718">nãotas pessoas o desprezam completamente &ndash; o que é um grande erro. Na verdade, há vários recursos HTML5 que podemos usar em nossos projetos desde já! Código mais simples e claro é sempre uma coisa boa. Na nossa dica rápida em vídeo de hoje, mostrarei a você várias opções.</p>

<figure data-video-embed="true" data-original-url="https://www.youtube.com/watch?v=HzCkSv3s0-k" class="embedded-video"><iframe src="//www.youtube.com/embed/HzCkSv3s0-k?rel=0" frameborder="0" webkitallowfullscreen="webkitallowfullscreen" mozallowfullscreen="mozallowfullscreen" allowfullscreen="allowfullscreen"></iframe></figure>

<h2><span class="sectionnum">25.</span>  O Que Não O HTML5 Não É</h2>

<p>
As pessoas podem ser perdoadas por acreditarem que transições incríveis, sem o uso do JavaScript, fazem parte do HTML5. Hey &ndash; até mesmo a Apple promoveu, inadvertidamente, essa ideia. Para os não desenvolvedores, isso não importa; É uma maneira fácil de se referir aos padrões web modernos. Porém, para nós, embora possa ser só semântica, é importante entender, exatamente, o que o HTML5 <strong>não é</strong>. </p>

<ol>
<li> <strong>SVG: </strong> Não é HTML5. É, no mínimo, cinco anos mais velho. </li>
<li> <strong>CSS3: </strong>Nãó é HTML5. É...CSS!. </li>
<li> <strong>Geolocalização: </strong>Não é HTML5. </li>
<li> <strong>Armazenamento no Cliente: </strong> Não é HTML5. Já foi, mas foi removido da especificação, por muitos acreditarem que eles estivesse se tornando muito complicado. Agora, tem sua própria especificação.</li>
<li><strong>Web Sockets: </strong>Não é HTML5. Novamente, foi exportado para sua própria especificação. </li>
</ol><p>Independentemente da distinção você requeira, todas essas tecnologias podem ser agrupadas no padrão web moderno. Na verdade, muitas dessas especificações ramificadas ainda são administradas pelas mesmas pessoas. </p>


<h2><span class="sectionnum">26.</span>  O Atributo Data</h2>

<p>
Agora temos, oficialmente, suporte a atributos customizados em todos os elementos HTML. Enquanto, antigamente, podiamos fazer, somente, algo assim:</p>

<pre class="brush: html">&lt;h1 id=someId customAttribute=value&gt; Obrigado, Tony. &lt;/h1&gt;</pre>

<p>...os validadores de código iriam reclamar bastante! Agora, porém, desde que prefixemos nossos atributos customizados usando <code>data</code>, podemos, oficialmente, usar esse método. Se você, alguma vez, se viu tendo de guardar dados importantes dentro do atributo <code>class</code>, provavelmente para uso com JavaScript, isso virá em um ótimo momento! </p>

<h3> Trecho HTML </h3>

<pre class="brush: html">&lt;div id="myDiv" data-custom-attr="Meu valor"&gt; Bla Bla &lt;/div&gt;</pre>

<h3> Retornar o Valor de Um Atributo Customizado </h3>

<pre>var theDiv = document.getElementById('myDiv');
var attr = theDiv.getAttribute('data-custom-attr');
alert(attr); // Meu valor
</pre>

<p>Ele pode ser usado, inclusive, em nosso CSS, como nesse exemplo básico de mudança de texto.  </p>

<pre class="brush: html">&lt;!DOCTYPE html&gt;

&lt;html lang="en"&gt;
&lt;head&gt;
 &lt;meta charset="utf-8"&gt;
 &lt;title&gt;Exemplo simples de mudança de texto&lt;/title&gt;
&lt;style&gt;

h1 { position: relative; }
h1:hover { color: transparent; }

h1:hover:after {
	content: attr(data-hover-response);
	color: black;
	position: absolute;
	left: 0;

}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 data-hover-response="Eu disse, não me toque!"&gt; Não me toque  &lt;/h1&gt;

&lt;/body&gt;
&lt;/html&gt;</pre>

<p>Você pode ver o efeito acima na demonstração hospedada <a href="http://jsbin.com/okepo4">no JSBIN</a>. </p>


<h2><span class="sectionnum">27.</span> O Elemento Output </h2>

<p>Você, provavelmente, já adivinhou, o elemento <code>output</code> é usado para apresentar algum tipo de resultado de cálculo. Por exemplo, se você quiser apresentar as coordenadas da posição do mouse ou a soma de uma série de números, esses dados deveriam ser inseridos no elemento <code>output</code>. </p>

<p>Como um exemplo simples, vamos inserir a soma de dois números em um elemento <code>output</code> vazio, usando JavaScript, quando um botão <code>submit</code> for pressionado. </p>

<pre class="brush: html">&lt;form action="" method="get"&gt;
	&lt;p&gt;
10 + 5 = &lt;output name="sum"&gt;&lt;/output&gt;
	&lt;/p&gt;
	&lt;button type="submit"&gt; Calcular &lt;/button&gt;
&lt;/form&gt;

&lt;script&gt;
(function() {
	var f = document.forms[0];

	if ( typeof f['sum'] !== 'undefined' ) {
f.addEventListener('submit', function(e) {
	f['sum'].value = 15;
	e.preventDefault();
}, false);
	}
	else { alert('Seu navegador não está pronto ainda.'); }
})();
&lt;/script&gt;</pre>

<p><em><a href="http://jsbin.com/efedu3">Veja em funcionamento.</a> </em></p>

<p>Note que o suporte ao elemento <code>output</code> ainda é bem fraco. Enquanto escrevo, somente o navegador Opera implementava-o bem. Isso é refletido no código acima. Se o navegador não reconhece o elemento, o navegador, simplesmente, alertará você sobre isso. Em qualquer outro caso, ele descobre o elemento <code>output</code> com o atributo <code>name</code> de valor "sum" e atribui o valor <code>15</code>, após o formulário ser enviado. </p>

<figure class="post_image"><img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/30/posts/12357/image/output.png" /></figure>

<p>Esse elemento também pode receber um atributo <code>for</code>, que reflete o nome do elemento o qual o elemento <code>output</code> se relaciona, de forma semelhante a que o elemento <code>label</code> trabalha. </p>


<h2><span class="sectionnum">28.</span> Criação de Sliders Com o Campo Range</h2>

<p>
O HTML5 introduz o novo tipo de campo, <code>range</code>.</p>

<pre class="brush: html">&lt;input type="range"&gt;</pre>

<p>Notavelmente, ele pode ter os atributos <code>min</code>, <code>max</code>, <code>step</code>, e <code>value</code>, além de outros. Embora apenas o Opera pareça dar suporte a esse tipo de campo, será fantástico quando nós pudermos usar isso de verdade!  </p>

<p>Para uma rápida demonstração, vamos construir um votador para que os usuários decidam o quão incrível o filme "Total Recall" é. Não construiremos uma solução de votação real, mas revisaremos como poderíamos fazer, bem rápido. </p>

<h3>Passo 1: Estrutura </h3>

<p>
Primeiro, criaremos a estrutura HTML.</p>

<pre class="brush: html">&lt;form method="post"&gt;
	&lt;h1&gt; Votador de Grandiosidade do "Total Recall" &lt;/h1&gt;
	&lt;input type="range" name="range" min="0" max="10" step="1" value=""&gt;
	&lt;output name="result"&gt;  &lt;/output&gt;
&lt;/form&gt;</pre>

<figure class="post_image"><img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/30/posts/12357/image/gaugeunstyled.png" /></figure>

<p>Note que, além de atribuir os valores de <code>min</code> e <code>max</code>, podemos especificar qual o tamanho do passo (<code>step</code>) de cada trnasição. Se o <code>step</code> tiver o valor de <code>1</code>, teremos 10 valores a escolher. Nós, também, lançamos mão do novo elemento <code>output</code>que aprendemos na dica anterior. </p>

<h3> Passo 2: CSS </h3>

<p>Next, we'll style it just a bit. We'll also utilize <code>:before</code> and <code>:after</code> to inform the user what our specified <code>min</code> and <code>max</code> values are. <em>Thanks so much to Remy and Bruce for teaching me this trick, via "<a href="http://introducinghtml5.com/">Introducing HTML5</a>." </em></p>

<pre class="brush: css">body {
	font-family: 'Myriad-Pro', 'myriad', helvetica, arial, sans-serif;
	text-align: center;
}
input { font-size: 14px; font-weight: bold;  }

input[type=range]:before { content: attr(min); padding-right: 5px; }
input[type=range]:after { content: attr(max); padding-left: 5px;}

output {
	display: block;
	font-size: 5.5em;
	font-weight: bold;
}</pre>

<p>Above, we create content before and after the range input, and make their values equal to the <code>min</code> and <code>max</code> values, respectively. </p>

<figure class="post_image"><img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/30/posts/12357/image/styledNoJS.png" /></figure>

<h3>Step 3: The JavaScript </h3>

<p>Lastly, we: </p>

<ul>
<li> Determine if the current browser knows what the range input is. If not, we alert the user that the demo won't work. </li>
<li>Update the <code>output</code> element dynamically, as the user moves the slider. </li>
<li> Listen for when the user mouses off the slider, grab the value, and save it to local storage. </li>
<li>Then, the next time the user refreshes the page, the range and output will automatically be set to what they last selected. </li>
</ul>

<pre class="brush:">(function() {
	var f = document.forms[0],
range = f['range'],
result = f['result'],
cachedRangeValue = localStorage.rangeValue ? localStorage.rangeValue : 5;

	// Determine if browser is one of the cool kids that
	// recognizes the range input.
	var o = document.createElement('input');
	o.type = 'range';
	if ( o.type === 'text' ) alert('Sorry. Your browser is not cool enough yet. Try the latest Opera.');

	// Set initial values of the input and ouput elements to
	// either what's stored locally, or the number 5.
	range.value = cachedRangeValue;
	result.value = cachedRangeValue;

	// When the user makes a selection, update local storage.
	range.addEventListener("mouseup", function() {
alert("The selected value was " + range.value + ". I am using local storage to remember the value. Refresh and check on a modern browser.");
localStorage ? (localStorage.rangeValue = range.value) : alert("Save data to database or something instead.");
	}, false);

	// Display chosen value when sliding.
	range.addEventListener("change", function() {
result.value = range.value;
	}, false);

})();</pre>

<figure class="post_image"><img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/30/posts/12357/image/gauge.png" /></figure>

<p>Ready for the real world? Probably not yet; but it's still fun to play with and prep for!</p>

<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/757_html5Tips/range.html.zip">Download the source code</a>, and try it out for yourself. But use a modern browser. </p>

<p>Thanks for reading! We've covered a lot, but have still only scratched the surface of what's possible with HTML5. I hope this served as a helpful primer!</p>
