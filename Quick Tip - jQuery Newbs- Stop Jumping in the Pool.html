<h1>Dica Rápida - Novatos em jQuery: Pare de Pula na Piscina</h1>

<p>Apesar da jQuery estar disponível há anos, continuo a ver um erro ser cometido mais que qualquer outro.</p>

<h2>Exemplo #1 </h2>

<p>Considere o seguinte trecho de código:</p>

<pre class="brush: js">$('.nav a').click(function() {&#13;
$(this).hide();&#13;
$(this).css('color', 'red');&#13;
$(this).show();&#13;
&#13;
alert('qualquer coisa');&#13;
&#13;
$(this).hide();&#13;
&#13;
return false;&#13;
});</pre>

<p>O código acima está muito complicado, por uma série de motivos. Não se preocupe com o que o código faz de verdade (não tem nexo). Ao invés disso, quero que você preste atenção às referências a <code>$(this)</code>.</p>

<blockquote class="pullquote"><p>Imagine a DOM como uma piscina. </p>
</blockquote>

<p>Imagine a DOM como uma piscina. Você lembra quando era criança e mergulhava até o fundo da piscina, procurando por moedas, enquanto seus pais agiam como se estivessem prestando atenção? Essa será nossa comparação com o mundo real.</p>

<p>Toda vez que você usa <code>$('.algumaClasse')</code>, a jQuery pula na piscina (DOM), e procura pelas moedas (ou nodos). Então, quando você a referencia múltiplas vezes em uma mesma função, acontecerão vários mergulhos na piscina. Ou, para acabar com a comparação com o mundo real, é um desperdício e desnecessário. Por que fazer chamada ao jQuery se você não precisa? Você deveria usar uma técnica que chamamos de “caching” (em português, armazenar).</p>

<pre class="brush: js">$('.nav a').click(function(e) {&#13;
 var anchor = $(this);&#13;
&#13;
 anchor&#13;
    .hide()&#13;
   .css('color', 'red')&#13;
   .show();&#13;
&#13;
 alert('qualquer coisa');&#13;
&#13;
 anchor.hide();&#13;
&#13;
 e.preventDefault();&#13;
&#13;
});</pre>

<p>Assim está muito melhor. Embora os modernos motores dos navegadores sejam incrivelmente rápidos hoje em dia, sendo capazes de compensar pela suas más práticas de programação o máximo possível, você deveria, ainda assim, buscar escrever código eficiente e evitar gastar toda esse energia pulando na piscina. Agora, tecnicamente, se você passar para o jQuery um nodo da DOM, como o <code>this</code>, ele não vai na DOM novamente. Ele, simplesmente, retorna um objeto jQuery. </p>

<blockquote><p>
Só porque a diferença de performance entre as duas será desprezível, não quer dizer que devemos escrever código de qualquer jeito.</p>
</blockquote>

<h2>Exemplo 2</h2>

<p>Consideremos um exemplo um pouco mais complicado: abas (do inglês, <em>tabs</em>).</p>

<pre class="brush: js">$('.tabs li').css('position', 'relative');&#13;
&#13;
$('.tabs li').click(function() {&#13;
 $('.tabs li').removeClass('active');&#13;
 $(this).addClass('active');&#13;
 $(this).load('someHref', function() {} ); // exemplo&#13;
 $(this).css('top', '1px');&#13;
});</pre>

<p>Encontramos esse tipo de código por todos os lugares. Ele é feio e ineficiente. O primeiro ajuste é remover esse CSS daí. Você só deve colocar estilos CSS em seu código se ele tiver de ser criado dinamicamente. Por exemplo, se você tem de calcular a localização precisa que um elemento deveria estar na página, você poderia usar <code>.css('left', valorCalculado)</code>. Nesse caso, porém, o valor pode ser colocado em um folha de estilo externa. O que nos deixaria com:</p>

<pre class="brush: js">$('.tabs li').click(function() {&#13;
 $('.tabs li').removeClass('active');&#13;
 $(this).load('someHref', function() {} ); // exemplo&#13;
 $(this).addClass('active');&#13;
});</pre>

<p>E, de novo, por que continuamos indo até a DOM, em busca de <code>.tabs li</code> e <code>$(this)</code>? Pare de pular na piscina. Vamos armazenar o nodo <code>.tabs li</code>.</p>

<pre class="brush: js">var tabs = $('.tabs li');&#13;
&#13;
tabs.click(function() {&#13;
 tabs.removeClass('active');&#13;
 $(this).load('someHref', function() {} ); // exemplo&#13;
 $(this).addClass('active');&#13;
});</pre>

<p>Bem melhor. Mas ainda estamos chamando <code>$(this)</code> duas vezes. O que não é tão problemático. Mas, pelas minhas experiências, se você não se preocupar com isso desde o começo, esse número aumenta bem rápido.</p>

<pre class="brush: js">var tabs = $('.tabs li');&#13;
&#13;
tabs.click(function() {&#13;
 var tab = $(this);&#13;
 tabs.removeClass('active');&#13;
 tab.addClass('active')&#13;
   .load('someHref', function() {} ); // exemplo&#13;
});</pre>

<h3>Filtros</h3>
<p>Outra opção (um pouco menos otimizada), seria o uso de filtros.</p>

<pre class="brush: js">&#13;
var tabs = $('.tabs li');&#13;
&#13;
tabs.click(function() {&#13;
 tabs.removeClass('active')&#13;
     .filter(this)&#13;
     .addClass('active')&#13;
     .load('someHref', function() {} ); // exemplo&#13;
});</pre>

<p>A diferença, nesse caso, é que, ao invés de referênciar a <code>$(this)</code>, estamos usando o método <code>filter()</code> para reduzir a coleção dos elementos da lista para, somente, aquele o qual foi clicado.</p>

<h2>O Que Você Deve Lembrar</h2>

<p>Sim, o mundo não vai acabar se você referenciar <code>$('.tabs)</code> várias vezes dentro de uma mesma função. Os motores JavaScript são bem rápidos, hoje em dia. Se você verificar a performance desse código depois de ser executado milhares de vezes, a diferença será só de algumas centenas de milisegundos. Mas, a pergunta que fica é: Por que você continuaria a codificar assim?</p>

<p>Algumas vezes, quando usamos abstrações gigantescas como a jQuery, é muito fácil esquecer que <code>$('.tabs')</code> é, na verdade, uma função que executa uma boa quantidade de código, por trás dos panos. Vale lembrar que esse conceito vale para o JavaScript como um todo, não só para o jQuery.</p>

<p>Use as técnicas de <code>caching</code>, descritas acima, para criar códigos melhores... para você mesmo.</p>
