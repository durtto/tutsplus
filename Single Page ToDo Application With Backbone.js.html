<h1>Um Aplicativo Lista de Tarefas de Página Única Usando Backbone.js</h1>

<p><a href="http://backbonejs.org/">Backbone.js</a> é uma <em>framework</em> JavaScript para a criação de aplicações web flexíveis. Ela vem com Modelos, Coleções, Visões, Eventos, Roteador e algumas outras ótimas funcionalidades. Nesse artigo, desenvolveremos um simples aplicativo de lista de tarefas que dará suporte a adicionar, editar e remover tarefas. Também seremos capazes de marcá-las como realizadas ou arquivá-las. Para manter esse post em um tamanho aceitável, não incluiremos nenhuma capacidade de comunicação com base de dados. Todos os dados serão mantidos no lado do cliente.</p>

<h2>Preparação</h2>

<p>Essa será a estrutura de arquivos/diretórios que usaremos:</p>

<pre class="brush: plain">css
    └── styles.css
js
    └── collections
        └── ToDos.js
    └── models
        └── ToDo.js
    └── vendor
       └── backbone.js
       └── jquery-1.10.2.min.js
       └── underscore.js
    └── views
    └── App.js
 └── index.html
</pre>

<p>Algumas coisas são bem óbvias, como o <code>/css/styles.css</code> e <code>/index.html</code>. Elas contem os estilos CSS e o código HTML da página inicial, respectivamente. No contexto do Backbone.js, o modelo é um lugar onde guardamos nossos dados. E, como teremos mais de uma tarefa, organizaremos esses modelos em uma coleção. A lógica de negócios está distribuida entre as visões e o arquivo principal da aplicação, o <code>App.js</code>. O Backbone.js só possui uma única dependência - o <a href="http://underscorejs.org/">Underscore.js</a>. O <em>framework</em> funciona bem com o <a href="http://jquery.com/">jQuery</a>, assim, ambos vão para o diretório <code>vendor</code>. Tudo que precisamos, agora, é um pouco de código HTML já preparado e estaremos prontos.</p>

<pre class="brush: html">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
        &lt;title&gt;Minhas Listas de Tarefass&lt;/title&gt;
        &lt;link rel="stylesheet" type="text/css" href="css/styles.css" /&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class="container"&gt;
            &lt;div id="menu" class="menu cf"&gt;&lt;/div&gt;
            &lt;h1&gt;&lt;/h1&gt;
            &lt;div id="content"&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;script src="js/vendor/jquery-1.10.2.min.js"&gt;&lt;/script&gt;
        &lt;script src="js/vendor/underscore.js"&gt;&lt;/script&gt;
        &lt;script src="js/vendor/backbone.js"&gt;&lt;/script&gt;
        &lt;script src="js/App.js"&gt;&lt;/script&gt;
        &lt;script src="js/models/ToDo.js"&gt;&lt;/script&gt;
        &lt;script src="js/collections/ToDos.js"&gt;&lt;/script&gt;
        &lt;script&gt;
            window.onload = function() {
                // bootstrap
            }
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>Como pode ver, incluímos todos os arquivos JavaScripts externos no final da página, logo antes da tag <code class="inline">body</code>, uma vez que isso é uma boa prática de desenvolvimento. Também preparamos a base da aplicação. Há um recipiente para o conteúdo, um menu e um título. A navegação principal é um elemento estático e não a mudaremos. Por outro lado, mudaremos o conteúdo do título e da <code>div</code> logo abaixo.</p>

<h2>Planejando a Aplicação</h2>

<p>Sempre é bom ter algum plano antes de começarmos a trabalho em algo. O Backbone.js não possui uma arquitetura super estrita, a qual devemos seguir. Esse é um de seus benefícios. Assim, antes de começarmos a implementar a lógica de negócios, falemos sobre o básico.</p>

<h3>Espaço de Nomes</h3>

<p>É uma boa prática criar um escopo próprio para seu código. Registrar variáveis ou funções globais não é uma boa ideia. Nós criaremos um modelo, uma coleção, um roteador e algumas visões do Backbone.js. Todos esses elementos devem ter um espaço próprio, privado. O arquivo <code>App.js</code> conterá a classe que agrupa tudo.</p>

<pre class="brush: javascript">// App.js
var app = (function() {

    var api = {
        views: {},
        models: {},
        collections: {},
        content: null,
        router: null,
        todos: null,
        init: function() {
            this.content = $("#content");
        },
        changeContent: function(el) {
            this.content.empty().append(el);
            return this;
        },
        title: function(str) {
            $("h1").text(str);
            return this;
        }
    };
    var ViewsFactory = {};
    var Router = Backbone.Router.extend({});
    api.router = new Router();

    return api;

})();
</pre>

<p>O que temos acima é uma implementação típica do <a href="http://addyosmani.com/resources/essentialjsdesignpatterns/book/#revealingmodulepatternjavascript">padrão do módulo revelador</a>. A variável <code>api</code> é o objeto que será retornado e representa os métodos públicos da classe. As propriedades <code>views</code>, <code>models</code> e <code>collections</code> agirão como recipientes para as classes retornadas pelo Backbone.js. A propriedade <code>content</code> é um objeto jQuery apontando para o recipiente principal da interface do usuário. Temos dois métodos auxiliares, também. O primeiro atualiza o recipiente. O segundo atribui um título à página. E então, definimos um módulo chamado <code>ViewsFactory</code>. Ele entregará nossas visões e, por fim, criamos nossa rota.</p>

<p>Talvez esteja perguntando o porque de precisarmos de uma fábrica para nossas visões, certo? Bem, existem alguns padrões comuns ao se trabalhar com o Backbone.js. Um deles é em relação à criação e uso de visões.</p>

<pre class="brush: javascript">var ViewClass = Backbone.View.extend({ /* a lógica vem aqui */ });
var view = new ViewClass();
</pre>

<p>É bom inicializar as visões somente uma vez e deixá-las existir durante o tempo de execução da aplicação. Uma vez que os dados mudem, geralmente invocamos métodos das visões e atualizamos o conteúdo do respectivo objeto <code>el</code>. Uma outra abordagem bastante popular é a de recriar toda a visão ou substituir todo o elemento DOM. Contudo, não é uma opção muito boa em relação a performance. Assim, nós temos uma classe auxiliar que cria uma instância da visão e a retorna quando precisarmos dela.</p>

<h3>Definição de Componentes</h3>

<p>Temos um espaço de nomes (<em>namespace</em>), então já podemos começar a criar componentes. É assim que o menu principal será:</p>

<pre class="brush: javascript">// views/menu.js
app.views.menu = Backbone.View.extend({
    initialize: function() {},
    render: function() {}
});
</pre>

<p>Criamos uma propriedade chamada <code>menu</code> que guardará a classe da navegação. Mais para frente, podemos adicionar algum método ao módulo da fábrica, capaz de criar uma instância dela própria.</p>

<pre class="brush: javascript">var ViewsFactory = {
    menu: function() {
        if(!this.menuView) {
            this.menuView = new api.views.menu({
                el: $("#menu")
            });
        }
        return this.menuView;
    }
};
</pre>

<p>O código acima é o responsável pela manipulação das visões e garantirá que tenhamos apenas uma única instância. Essa técnica funciona bem, na maioria dos casos.</p>

<h3>Fluxo</h3>

<p>A porta de entrada da aplicação é o arquivo <code>App.js</code> e seu método <code>init</code>. Será esse método que invocaremos no manipulador <code>onload</code> do objeto <code>window</code>.</p>

<pre class="brush: javascript">window.onload = function() {
    app.init();
}
</pre>

<p>Depois disso, o roteador que definimos tomará controle. Baseado na URL, ele decidirá qual manipulador executar. No Backbone.js, não temos uma arquitetura MVC (Model-View-Controller) padrão. Falta o controlador e a maior parte da lógica fica dentro das visões. Assim, atrelamos os modelos diretamente aos métodos, dentro das visões, e obtemos uma atualização instantânea da interface do usuário, assim que os dados mudarem.</p>

<h2>Administrando os Dados</h2>

<p>O mais importante em nosso pequeno projeto são os dados. Nossas tarefas são aquilo que devemos administrar, então, comecemos a partir daí. Eis nossa definição de modelo.</p>

<pre class="brush: javascript">// models/ToDo.js
app.models.ToDo = Backbone.Model.extend({
    defaults: {
        title: "Lista de Tarefas",
        archived: false,
        done: false
    }
});
</pre>

<p>Apenas três campos. O primeiro contem o texto da tarefa e os outros dois são marcações que definem o estado do registro.</p>

<p>Tudo dentro da <em>framework</em>, na verdade, é um emissor de eventos. E, uma vez que o modelo é modificado através de <code class="inline">setters</code>, a <em>framework</em> sabe quando o dado foi atualizado e pode notificar o resto do sistema. Assim que você atrela algo a essas notificações, sua aplicação reagirá às mudanças no modelo. Essa é uma funcionalidade muito poderosa do Backbone.js, de verdade.</p>

<p>Como disse no começo, teremos vários registros e organizaremos eles em uma coleção chamada <code>ToDos</code>.</p>

<pre class="brush: javascript">// collections/ToDos.js
app.collections.ToDos = Backbone.Collection.extend({
    initialize: function(){
        this.add({ title: "Aprenda o básico do JavaScript" });
        this.add({ title: "Visite o backbonejs.org" });
        this.add({ title: "Desenvolva uma aplicação em Backbone" });
    },
    model: app.models.ToDo
    up: function(index) {
        if(index &gt; 0) {
            var tmp = this.models[index-1];
            this.models[index-1] = this.models[index];
            this.models[index] = tmp;
            this.trigger("change");
        }
    },
    down: function(index) {
        if(index &lt; this.models.length-1) {
            var tmp = this.models[index+1];
            this.models[index+1] = this.models[index];
            this.models[index] = tmp;
            this.trigger("change");
        }
    },
    archive: function(archived, index) {
        this.models[index].set("arquivada", archived);
    },
    changeStatus: function(done, index) {
        this.models[index].set("realizada", done);
    }
});
</pre>

<p>O método <code>initialize</code> é a porta de entrada da nossa coleção. Em nosso caso, adicionamos algumas tarefas padrões. Claro, em uma aplicação de verdade, essas informações virão de uma base de dados ou de algum outro lugar. Mas, para continuarmos focados, faremos dessa forma. Uma outra coisa típica de coleções é a atribuição da propriedade <code>model</code>. Ela diz à classe qual o tipo de dados será salvo. O resto dos métodos implementam uma lógica própria do domínio de nossa aplicação. As funções <code>up</code> e <code>down</code> alteram a ordem dos itens da lista de tarefas. Para simplificar, identificaremos cada item com um simples índice no vetor da coleção. Isso significa que, se quisermos buscar algum registro em específico, devemos buscá-lo através de seu índice. Assim, a ordenação é só uma mudança de posição de elementos em um vetor. Como talvez tenha percebido no código acima, <code>this.models</code> é o vetor do qual estamos falando. Os métodos <code>archive</code> e <code>changeStatus</code> alteram as propriedades de um determinado item. Colocamos esses métodos aqui porque as visões terão acesso à coleção <code>ToDos</code>, não à tarefa diretamente.</p>

<p>Adicionalmente, não criaremos qualquer modelo a partir da classe <code>app.models.ToDo</code>, mas precisaremos criar uma instância da coleção <code>app.collections.ToDos</code>.</p>

<pre class="brush: javascript">// App.js
init: function() {
    this.content = $("#content");
    this.todos = new api.collections.ToDos();
    return this;
}
</pre>

<h2>Mostrando Nossa Primeira Visão (Navegação Principal)</h2>

<p>A primeira coisa que teremos de mostrar é a navegação principal da aplicação.</p>

<pre class="brush: javascript">// views/menu.js
app.views.menu = Backbone.View.extend({
    template: _.template($("#tpl-menu").html()),
    initialize: function() {
        this.render();
    },
    render: function(){
        this.$el.html(this.template({}));
    }
});
</pre>

<p>São somente nove linhas de código, mas muitas coisas interessantes estão acontecendo ali. A primeira, é que estamos configurando um modelo. Você lembra que adicionamos a Underscore.js ao nosso app? Usaremos o mecanismo de modelos dele, uma vez que funciona muito bem e é simples o bastante de se usar. </p>

<pre class="brush: javascript">_.template(templateString, [data], [settings])
</pre>

<p>O que temos, no fim das contas, é uma função que aceita um objeto com os pares de chave-valor das informações e o código HTML do modelo na variável <code>templateString</code>. Certo, então ela aceita uma cadeia de caracteres HTML, mas o que aquele <code>$("#tpl-menu").html()</code> está fazendo ali? Quando desenvolvemos pequenos aplicativos de página única, geralmente colocamos os modelos diretamente na página, dessa forma:</p>

<pre class="brush: html">// index.html
&lt;script type="text/template" id="tpl-menu"&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;a href="#"&gt;Lista&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href="#archive"&gt;Arquivar&lt;/a&gt;&lt;/li&gt;
        &lt;li class="right"&gt;&lt;a href="#new"&gt;+&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/script&gt;
</pre>

<p>E, uma vez que o modelo é uma tag <code class="inline">script</code>, não será mostrado ao usuário. Pensando de outra forma, ele é um elemento DOM válido e podemos obter seu conteúdo utilizando jQuery. Assim, aquele pequeno trecho de código (<code>$("#tpl-menu").html()</code>), é o encarregado de buscar o conteúdo da tag <code class="inline">script</code>. </p>

<p>O método <code>render</code> é bem importante para o Backbone.js. Essa é a função responsável por mostrar os dados. Geralmente, você atrela os eventos disparados pelo modelo, diretamente, nesse método. Contudo, para o menu principal, não precisamos de tal comportamento.</p>

<pre class="brush: javascript">this.$el.html(this.template({}));
</pre>

<p><code>this.$el</code> é um objeto criado pela <em>framework</em> e toda visão o tem por padrão (há um <code>$</code> na frente do <code>el</code> porque incluimos a jQuery). E, por padrão, esse objeto representa uma <code>&lt;div&gt;&lt;/div&gt;</code> vazia. Claro, você pode alterar isso, usando a propriedade <code>tagName</code>. Mas, o mais importante, aqui, é que não atribuamos diretamente um valor ao objeto. Não o alteraremos diretamente, alteraremos seu conteúdo. Há uma grande diferença entre a linha acima e a linha abaixo:</p>

<pre class="brush: javascript">this.$el = $(this.template({}));
</pre>

<p>O ponto é que, se você quiser ver as mudanças no navegador, você deverá chamar o método de redenrização (<code class="inline">render</code>) antes, para adicionar a visão à DOM. Caso contrário, somente a <code class="inline">div</code> vazia será adicionada. Tem outro cenário onde temos visões aninhadas. Uma vez que você modifique a propriedade, diretamente, o componente pai não é atualizado. Os eventos atribuídos talvez também não estejam funcionando e será preciso que atrele os observadores novamente. Por isso, você só deveria alterar o conteúdo de <code>this.$el</code>, não o valor da propriedade em si.</p>

<p>A visão está pronta e precisamos inicializá-la. Adicionemos nosso módulo fábrica:</p>

<pre class="brush: javascript">// App.js
var ViewsFactory = {
    menu: function() {
        if(!this.menuView) {
            this.menuView = new api.views.menu({
                el: $("#menu")
            });
        }
        return this.menuView;
    }
};
</pre>

<p>No fim, apenas invoque o método <code>menu</code> na parte de preparação da aplicação (método <code class="inline">init()</code>):</p>

<pre class="brush: javascript">// App.js
init: function() {
    this.content = $("#content");
    this.todos = new api.collections.ToDos();
    ViewsFactory.menu();
    return this;
}
</pre>

<p>Perceba que, ao criamos uma nova instância da classe de navegação, passamos um elemento DOM pré-existente, o <code>$("#menu")</code>. Assim, a propriedade <code>this.$el</code> dentro da visão estará apontando, na verdade, para <code>$("#menu")</code>.</p>

<h2>Adicionando Rotas</h2>

<p>O Backbone.js dá suporte a operações <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Manipulating_the_browser_history"><em>push state</em></a>. Em outras palavras, você pode manipular a URL atual do navegador e navegar entre as páginas a partir do histórico do navegador. Entretanto, continuaremos com as boas e velhas URLs de <em>hashes</em>, como <code>/#edit/3</code>.</p>

<pre class="brush: javascript">// App.js
var Router = Backbone.Router.extend({
    routes: {
        "archive": "archive",
        "new": "newToDo",
        "edit/:index": "editToDo",
        "delete/:index": "delteToDo",
        "": "list"
    },
    list: function(archive) {},
    archive: function() {},
    newToDo: function() {},
    editToDo: function(index) {},
    delteToDo: function(index) {}
});
</pre>

<p>Logo acima está nosso roteador. Há cinco rotas definidas em um objeto <em>hash</em>. A chave do objeto será o endereço que você digitará no navegador e o valor será a função que será chamada. Perceba que há o termo <code>:index</code> em duas das rotas. Essa é a sintaxe que você precisa usar se quiser que sua aplicação suporte URLs dinâmicas. Em nosso caso, se você digitar <code>#edit/3</code> o método <code>editToDo</code> será executado com o parâmetro <code>index=3</code>. A última linha é um cadeia de caracteres vazia, indicando que a função <code class="inline">list</code> manipulará a página inicial da nossa aplicação.</p>

<h2>Mostrando uma Lista com Todas as Tarefas</h2>

<p>Até agora, criamos a visão principal para nosso projeto. Ele retornará os dados a partir da nossa coleção e mostrará esses dados na tela. Poderíamos usar essa mesma visão para duas coisas - mostrar todas as tarefas ativas, bem como mostrar aquelas que foram arquivadas.</p>

<p>Antes de continuarmos a implementação da lista, vejamos como ela é inicializada.</p>

<pre class="brush: javascript">// in App.js views factory
list: function() {
    if(!this.listView) {
        this.listView = new api.views.list({
            model: api.todos
        });
    }
    return this.listView;
}
</pre>

<p>Perceba que passamos uma coleção. Isso é importante porque, mais para frente, usaremos <code>this.model</code> para acessar os dados guardados. A fábrica retorna nossa visão de lista, mas o roteador é o responsável por adicioná-la à página.</p>

<pre class="brush: javascript">// in App.js's router
list: function(archive) {
    var view = ViewsFactory.list();
    api
    .title(archive ? "Arquivo:" : "Sua lista de tarefas:")
    .changeContent(view.$el);
    view.setMode(archive ? "archive" : null).render();
}
</pre>

<p>Por hora, o método <code>list</code> em nosso roteador é chamado sem qualquer parâmetro. Assim, a visão não estárá no modo <code>archive</code> (que mostrará as tarefas arquivadas), mostrando apenas as tarefas ativas.</p>

<pre class="brush: javascript">// views/list.js
app.views.list = Backbone.View.extend({
    mode: null,
    events: {},
    initialize: function() {
        var handler = _.bind(this.render, this);
        this.model.bind('change', handler);
        this.model.bind('add', handler);
        this.model.bind('remove', handler);
    },
    render: function() {},
    priorityUp: function(e) {},
    priorityDown: function(e) {},
    archive: function(e) {},
    changeStatus: function(e) {},
    setMode: function(mode) {
        this.mode = mode;
        return this;
    }
});
</pre>

<p>A propriedade <code>mode</code> será usada durante a renderização. Se seu valor for <code>mode="archive"</code>, então só as tarefas arquivadas serão mostradas. <code>events</code> é um objeto que o preencheremos já-já. É o local onde mapearemos os eventos da DOM. O resto dos métodos são respostas para as interações dos usuário e eles estão diretamente ligados às funcionalidades necessárias. Por exemplo, <code>priorityUp</code> e <code>priorityDown</code> muda a ordem da tarefas dentro da lista. <code>archive</code> move o item para a área de itens arquivados. <code>changeStatus</code>, simplesmente marca a tarefa como realizada.</p>

<p>O que está acontecendo dentro do método <code>initialize</code> é interessante. Antes, dissemos que você, normalmente, atrelaria as mudanças no modelo (a coleção, no nosso caso) ao método <code>render</code> da visão. Você pode digitar <code>this.model.bind('change', this.render)</code>. Mas, logo, perceberá que a palavra-chave <code>this</code> no método <code>render</code> não corresponde à visão em si. Isso se dá porque o escopo é diferente. Como uma alternativa, criaremos um manipulador com um escopo, previamente, definido. É para isso que serve a função <code>bind</code> da Underscore.js. </p>

<p>Eis a implementação do método <code>render</code>.</p>

<pre class="brush: javascript">// views/list.js
render: function() {)
    var html = '&lt;ul class="list"&gt;',
        self = this;
    this.model.each(function(todo, index) {
        if(self.mode === "archive" ? todo.get("archived") === true : todo.get("archived") === false) {
            var template = _.template($("#tpl-list-item").html());
            html += template({
                title: todo.get("title"),
                index: index,
                archiveLink: self.mode === "archive" ? "unarchive" : "archive",
                done: todo.get("done") ? "yes" : "no",
                doneChecked: todo.get("done")  ? 'checked=="checked"' : ""
            });
        }
    });
    html += '&lt;/ul&gt;';
    this.$el.html(html);
    this.delegateEvents();
    return this;
}
</pre>

<p>Iteramos sobre todos os modelos da coleção e geramos um HTML que, posteriormente, será inserido no elemento DOM da respectiva visão. Há algumas checagens que distinguem a lista de tarefas <em>padrão</em> da lista de tarefas <em>arquivadas</em>. A tarefa é marcada como <em>done</em> com a ajuda de um campo próprio para isso. Assim, será possível indicar se precisamos passar o atributo <code>checked="checked"</code> para o elemento. Talvez tenha percebido que estamos usando o método <code>this.delegateEvents()</code>. No nosso caso, isso é necessário, porque estamos removendo e readicionando a visão da DOM. Exato! Não estamos substituindo o elemento principal, mas os manipuladores dos eventos são removidos. É por isso que temos de dizer ao Backbone.js para atrelá-los novamente. O modelo usado com o código acima é o que segue:</p>

<pre class="brush: html">// index.html
&lt;script type="text/template" id="tpl-list-item"&gt;
    &lt;li class="cf done-&lt;%= done %&gt;" data-index="&lt;%= index %&gt;"&gt;
        &lt;h2&gt;
            &lt;input type="checkbox" data-status &lt;%= doneChecked %&gt; /&gt;
            &lt;a href="javascript:void(0);" data-up&gt;&amp;#8593;&lt;/a&gt;
            &lt;a href="javascript:void(0);" data-down&gt;&amp;#8595;&lt;/a&gt;
            &lt;%= title %&gt;
        &lt;/h2&gt;
        &lt;div class="options"&gt;
            &lt;a href="#edit/&lt;%= index %&gt;"&gt;edit&lt;/a&gt;
            &lt;a href="javascript:void(0);" data-archive&gt;&lt;%= archiveLink %&gt;&lt;/a&gt;
            &lt;a href="#delete/&lt;%= index %&gt;"&gt;delete&lt;/a&gt;
        &lt;/div&gt;
    &lt;/li&gt;
&lt;/script&gt;
</pre>

<p>Note que tem uma classe CSS chamada <code>done-yes</code>, que pinta o plano de fundo da tarefa na cor verde. Além disso, há algumas âncoras que usaremos para implementar as funcionalidades necessárias. Elas todas possuem atributos de dados (atributos que começam com <code>data-</code>). O elemento do nodo principal, <code>li</code>, tem o atributo de dados <code>data-index</code>. O valor desse atributo é responsável por apresentar o índice da tarefa dentro da coleção. Note que as expressões especiais envolvidas em <code>&lt;%= ... %&gt;</code> são enviadas para a função <code>template</code>. Serão nessas expressões que os dados serão injetados no modelo.</p>

<p>É hora de adicionar alguns eventos à visão. </p>

<pre class="brush: javascript">// views/list.js
events: {
    'click a[data-up]': 'priorityUp',
    'click a[data-down]': 'priorityDown',
    'click a[data-archive]': 'archive',
    'click input[data-status]': 'changeStatus'
}
</pre>

<p>No Backbone.js a definição de eventos é um simples <em>hash</em>. Você, primeiramente, digita o nome do evento e, então, um seletor. Os valores das propriedades são, na verdade, métodos das visões.</p>

<pre class="brush: javascript">// views/list.js
priorityUp: function(e) {
    var index = parseInt(e.target.parentNode.parentNode.getAttribute("data-index"));
    this.model.up(index);
},
priorityDown: function(e) {
    var index = parseInt(e.target.parentNode.parentNode.getAttribute("data-index"));
    this.model.down(index);
},
archive: function(e) {
    var index = parseInt(e.target.parentNode.parentNode.getAttribute("data-index"));
    this.model.archive(this.mode !== "archive", index);
},
changeStatus: function(e) {
    var index = parseInt(e.target.parentNode.parentNode.getAttribute("data-index"));
    this.model.changeStatus(e.target.checked, index);
}
</pre>

<p>Aqui, usamos o <code>e.target</code> que vem do manipulador. Ele aponta para o elemento Dom que ativou o evento. Obtemos o índice da tarefa que foi clicada e atualizamos o modelo na coleção. Com essas quatro funções, finalizamos nossa classe e agora temos dados para mostrarmos na página. </p>

<p>Como mencionado acima, usaremos a mesma visão para a página <code>Arquivos</code>.</p>

<pre class="brush: javascript">list: function(archive) {
    var view = ViewsFactory.list();
    api
    .title(archive ? "Archive:" : "Your ToDos:")
    .changeContent(view.$el);
    view.setMode(archive ? "archive" : null).render();
},
archive: function() {
    this.list(true);
}
</pre>

<p>Acima temos o mesmo manipulador que antes, porém, dessa vez, passamos um parâmetro <code>true</code>.</p>

<h2>Adicionando &amp; Editando Tarefas</h2>

<p>Seguindo os princípios da visão da lista, poderíamos criar outra que mostra um formulário para adicionar e editar tarefas. Eis como essa novo classe pode ser criada:</p>

<pre class="brush: javascript">// App.js / views factory
form: function() {
    if(!this.formView) {
        this.formView = new api.views.form({
            model: api.todos
        }).on("saved", function() {
            api.router.navigate("", {trigger: true});
        })
    }
    return this.formView;
}
</pre>

<p>Praticamente a mesma coisa de antes. Entretanto, agora, precisamos realizar uma operação assim que o formulário for submetido. E, depois disso, retornar o usuário para a página inicial. Como já disse, todo objeto que estende alguma classe do Backbone.js é, na verdade, um emissor de eventos. Existem métodos como o <code>on</code> e o <code>trigger</code>, os quais podem ser usados.</p>

<p>Antes de continuarmos com o código da visão, olhemos o modelo HTML:</p>

<pre class="brush: html">&lt;script type="text/template" id="tpl-form"&gt;
    &lt;form&gt;
        &lt;textarea&gt;&lt;%= title %&gt;&lt;/textarea&gt;
        &lt;button&gt;salvar&lt;/button&gt;
    &lt;/form&gt;
&lt;/script&gt;
</pre>

<p>Temos uma elemento <code>textarea</code> e um <code>button</code>. O modelo espera por um parâmetro <code>title</code>, o qual deve ser uma cadeia de caracteres vazia, caso queiramos adicionar uma nova tarefa.</p>

<pre class="brush: javascript">// views/form.js
app.views.form = Backbone.View.extend({
    index: false,
    events: {
        'click button': 'save'
    },
    initialize: function() {
        this.render();
    },
    render: function(index) {
        var template, html = $("#tpl-form").html();
        if(typeof index == 'undefined') {
            this.index = false;
            template = _.template(html, { title: ""});
        } else {
            this.index = parseInt(index);
            this.todoForEditing = this.model.at(this.index);
            template = _.template($("#tpl-form").html(), {
                title: this.todoForEditing.get("title")
            });
        }
        this.$el.html(template);
        this.$el.find("textarea").focus();
        this.delegateEvents();
        return this;
    },
    save: function(e) {
        e.preventDefault();
        var title = this.$el.find("textarea").val();
        if(title == "") {
            alert("Tarefa vazia!!"); return;
        }
        if(this.index !== false) {
            this.todoForEditing.set("title", title);
        } else {
            this.model.add({ title: title });
        }
        this.trigger("saved");
    }
});
</pre>

<p>A visão só possui 40 linhas de código, mas é capaz de realizar a tarefa sem problemas. Existe só um evento atrelado que é o do clique do botão. O método <code>render</code> agirá diferente, dependendo do parâmetro <code>index</code> passado. Por exemplo, se formos editar alguma tarefa, passamos o índice e buscamos o modelo correspondente àquele índice. Caso contrário, o formulário estará vazio e uma nova tarefa será criada. Há várias pontos interessantes nesse trecho de códico. Primeiro, durante a renderização, usamos o método <code>.focus()</code> para focar no formulário, logo que a visão terminar de ser renderizada. E, mais uma vez, a função <code>delegateEvents</code> deve ser invocada, porque o formulário será removido e inserido novamente. O método <code>save</code> começa com <code>e.preventDefault()</code>. Isso remove o comportamento padrão do botão que, em alguns casos, pode submeter o formulário. E, ao final, uma vez que tudo está pronto, ativamos o evento <code>saved</code>, notificando o 'mundo exterior' que a tarefa foi salva na coleção.</p>

<p>Há outros dois métodos do roteador, que devemos finalizar.</p>

<pre class="brush: javascript">// App.js
newToDo: function() {
    var view = ViewsFactory.form();
    api.title("Criar nova tarefa:").changeContent(view.$el);
    view.render()
},
editToDo: function(index) {
    var view = ViewsFactory.form();
    api.title("Editar tarefa:").changeContent(view.$el);
    view.render(index);
}
</pre>

<p>A diferença entre os dois é que passamos um índice, caso a URL combine com o padrão da rota <code>edit/:index</code>. E, claro, o título da página muda de acordo, também.</p>

<h2>Removendo um Registro da Coleção</h2>

<p>Para essa funcionalidade, não precisamos de uma visão. Todo o trabalho pode ser realizado no manipulador da rota.</p>

<pre class="brush: javascript">delteToDo: function(index) {
    api.todos.remove(api.todos.at(parseInt(index)));
    api.router.navigate("", {trigger: true});
}
</pre>

<p>Sabemos o índice da tarefa que queremos remover. Há o método <code>remove</code> na classe da coleção, que aceita um objeto do modelo, como parâmetro. Depois de removido, basta redirecionar o usuário para a página inicial, que mostrará a lista atualizada.</p>

<h2>Conclusão</h2>

<p>O Backbone.js tem tudo que você precisa para construir uma aplicação de página única, totalmente funcional. Poderíamos até usá-la com um serviço REST e ela seria responsável pode sincronizar os dados entre seu aplicativo e a base de dados. A abordagem voltada a eventos encoraja uma programação modular, bem como uma boa arquitetura. Uso o Backbone.js para vários projetos e ele funciona muito bem.</p>