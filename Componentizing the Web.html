<h1>Componentizando a Web</h1>

<p>Essa é uma história sobre um dos meus projetos. Um bem grande. Uma mistura entre <a href="http://php.net/">PHP</a> e <a href="http://nodejs.org/">Node.js</a>. É uma aplicação de página única (SPA) por um lado, e um site otimizado para buscas (SEO) por outro. Milhares de JavaScipt, CSS e HTML escritos. Em uma única palavra, um pesadelo em forma de código <em>spaghetti</em> para qualquer desenvolvedor. Houve altos e baixos. Produzindo e solucionando problemas. Lutando com as mais novas tecnologias, acabamos com uma biblioteca simples e maravilhosa, que será o tópico desse artigo</p>

<h2>O Começo</h2>

<p>Como sempre acontece, o projeto não foi considerado grande. Recebemos o resumo do encontro com o cliente, discutimos sobre como o desenvolvimento seria levado, que tecnologias seria utilizadas e como as utilizaríamos. Criamos um grande plano e colocamos para funcionar. No começo, tínhamos algumas poucas páginas, que eram controladas por um CMS. Não tinha muito código JavaScript porque nosso sistema entrega grande parte do conteúdo.</p>

<p>Eis uma versão grosseira de como era a estrutura do nosso projeto:</p><figure class="post_image"><img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/20602/image/img1.png"></figure>

<p>Colocamos o código que ficaria do lado do cliente em diretórios diferentes. O código do lado servidor era só em PHP, naquele momento, então, ele foi para no diretório<code>php</code>. Tudo envolvia cerca de 30 arquivos e estava tudo certo. </p>

<h2>A Jornada</h2>

<p>Por alguns meses, tentamos alguns conceitos e mudamos os códigos do projeto várias vezes. Do que temos agora, poderia apontar quatro grande problemas pelos quais passamos.</p>

<h3>Problema #1 - Inúmeros Arquivos Mal Estruturados</h3>

<p>Parece que o cliente estava feliz com o resultado e decidiu investir um pouco mais em sua presença na Internet. Pediram para criarmos alguns novos recursos. Alguns eram somente novos lugares para conteúdo, outros eram adições a páginas existentes. Nós começamos a adicionar mais e mais arquivos em todos os diretórios listados mais acima. Isso começou a ficar um pouco bagunçado, então, decidimos criar subdiretórios para as diferentes páginas e salvar o código necessário por lá.</p><figure class="post_image"><img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/20602/image/img2.png"></figure>

<p>Por exemplo, as folhas de estilo CSS para a página <em>about</em> estavam em <code>css/about/styles.css</code>. O JavaScript estava em <code>js/about/scripts.js</code> e por aí vai. Nós usamos um script PHP que concatena os arquivos. Houve, claro, partes do site que estavam em diversas páginas. Elas colocamos no diretório <code>common</code>. Isso saiu bem por um tempo, mas não funcionou por muito tempo quando os diretórios ficaram cheios, demorava muito modificar algo. Você teria de pesquisar em três diretórios diferentes para encontrar algo que era preciso. O site ainda era escrito, principalmente, em PHP.</p>

<h3>Problema #2 - A Reviravolta ou Como Nós Bagunçamos Tudo</h3>

<p>Por esses dias, aplicações móveis ficaram popular. O cliente queria que seu site também estivesse disponível para dispositivos móveis e esse é a grande reviravolta do projeto. Tivemos de converter o site para uma aplicação de página única. E não foi só isso, era preciso várias e várias funcionalidades de tempo real. Claro, nem todo o conteúdo do site tinha de ser carregado dinâmicamente. SEO ainda era uma parte importante na visão do cliente. Nós escolhemos o <a href="http://www.mean.io/">conjunto MEAN</a> para as partes futuras. O problema estava na páginas antigas. O conteúdo delas tinha de ser servido pelo PHP, mas a lógica mudou completamente ao ponto de ser, completamente, em JavaScript. Por semanas, sentimo-nos como os passageiros do Titanic. Estávamos aperreados para lançar algo, mas encontrávamos buraco atrás de buraco e, logo o nosso navio estaria cheio de água (defeitos/bugs).  </p>

<h3>Problema #3 - Um Árduo Processo de Trabalho</h3>

<p>Nós usamos o <a href="http://gruntjs.com/">GruntJS</a> por um tempo, mas migramos para o <a href="http://gulpjs.com/">Gulp</a>. Isso ajudou bastante, porque aumentou nossa velocidade de desenvolvimento. Porém, ainda era estranho demais para adicionar ou editar componentes existentes. A arquitetura sólida que tínhamos no começo, transformou-se em uma mistura complexa de arquivos. Sim, havia conveções estritas de nomeação e localização dos arquivos, mas ainda assim era bagunçado. Por fim, colocamos nossos cérebros para funcionar e chegamos ao seguinte formato:</p><figure class="post_image"><img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/20602/image/img3.png"></figure>

<p>Nós dividimos o site em componentes diferentes, que eram quase como caixas pretas. Eles viviam em seus próprios diretórios. Tudo relacionado ao componente era salvo dentro do diretório do componente. Nós projetamos, cuidadosamente, as APIs das classes. Elas eram testáveis e comunicativas. Percebemos que esse tipo de arquitetura funcionava melhor para nós, uma vez que tínhamos inúmeros módulos independentes. Sim, estávamos misturando nossos arquivos JavaScript com os estilos CSS e modelos HTML, mas era mais fácil trabalhar em relação ao módulo que ter de navegar por vários níveis de diversos diretórios.</p>

<h3>Problema #4  - Angular vs. Código Customizado</h3>

<p>As páginas que eram velhas tínhamos de entregar através do PHP, também estavam repletas de código JavaScript. Contudo, em alguns casos, o Angular.js não lidava muito bem com isso. Tivemos de criar alguns <em>hacks</em> para fazer as coisas funcionarem perfeitamente. Nós acabamos em uma mistura de controladores do Angular e códigos customizados. A boa notícia era que o orçamento do projeto tinha aumentado e pudemos usar nossa própria biblioteca. Dessa vez, eu estava desenvolvendo meu próprio <a href="http://code.tutsplus.com/tutorials/absurdjs-or-why-i-wrote-my-own-css-preprocessor--net-36003">pré-processador CSS</a>. O projeto correu muito, muito rápido. Em pouco tempo, pude portar minha biblioteca de forma que pudesse ser usada no lado do cliente. Ela se transformou em uma pequena biblioteca, linha por linha, que, então, começamos a integrar no projeto.</p>

<h4>Por Que Criar Uma Nova Biblioteca?</h4>

<p>Você deve estar se perguntando isso. Bem, existem diversas outras bibliotecas que proveem uma vasta gama de capacidades. Sim, isso é verdade, mas... não precisávamos de uma vasta gama de funcionalidades. Precisávamos de coisas específicas e nada mais. Nós já tínhamos aceitado adicionar alguns kilobytes a mais, para pode adicionar uma biblioteca popular. Esse não era o grande problema</p><p>A situação da nossa base de códigos que era o problema. Estávamos focados em construir uma boa arquitetura e todos concordávamos que, algumas vez, uma solução customizadas servia melhor. O uso da Angular, Ember, Knockout ou Backbone vem com seus benefícios, mas, a verdade é que não há uma biblioteca universal.</p><p>Gosto do que o <a href="http://adactio.com/">Jeremy Keith</a> disse em sua palestra <a href="http://krasimirtsonev.com/blog/article/The-Power-Of-Simplicity-by-Jeremy-Keith">O poder da simplicidade</a>, que o mais importante ao escolher sua ferramenta é a filosofia da pessoa que criou a ferramenta e se essa filosofia alinha com a sua. Se as ideias da biblioteca não alinha com as suas, logo-logo, você encontrará problemas. A mesma coisa aconteceu conosco. Tentamos usar a Angular e encontramos muitas dificuldades. Éramos capazes de resolver os problemas, mas tínhamos de usar de <em>hacks</em> e soluções alternativas complexas</p><p>Também tentamos a Ember, mas também não funcionou, principalmente por ela se basear, fortemente, em seu mecanismo de roteamento. A Backbone foi uma escolha interessante e o mais próximo da nossa visão. Entretanto, quando apresentei a <a href="http://absurdjs.com/">AbsurdJS</a> decidimos utilizá-la.</p>

<h2>What AbsurdJS Did For Us</h2>

<p><a href="http://absurdjs.com/">AbsurdJS</a> was originally started as a <a href="http://absurdjs.com/pages/css-preprocessing/">CSS preprocessor</a>, expanded to an <a href="http://absurdjs.com/pages/html-preprocessing/">HTML preprocessor</a> and it was successfully ported for client side usage. So, in the beginning we use it for compiling JavaScript to HTML or CSS. Yes, you heard me right; we started writing our styles and markup in JavaScript (probably sounds strange, but please keep reading). I pushed the library forward and a dozen of functionalities were added.</p>

<h3>Divide and Rule</h3>

<p>When you have a complex system, with many pages, you really don't want to solve big problems. It is much better to split everything into smaller tasks and solve them one by one. We did the same thing. We decided that our application will be built of smaller components, like so:</p>

<pre class="brush: javascript">var absurd = Absurd();
var MyComp = absurd.component('MyComp', {
    constructor: function() {
        // ...
    }
});
var instance = MyComp();
</pre>

<p><code>absurd.component</code> defines a class. Calling the <code>MyComp()</code> method creates a new instance.</p>

<h3>Let's Talk to Each Other</h3>

<p>Having all these small components, we needed a channel for communication. The observer pattern was perfect for this case. So, every component is an event dispatcher.</p>

<pre class="brush: javascript">var MyComp = absurd.component('MyComp', {
    doSomething: function() {
        this.dispatch('something-happen');
    }
});
var instance = MyComp();
instance.on('something-happen', function() {
    console.log('Hello!');
});
instance.doSomething();
</pre>

<p>We are also able to pass data along with the message. The definition of the components and their "listen-dispatch" nature is pretty trivial. I adopted this concept from the other popular frameworks, because it looks natural. It was also much easier for my colleagues to start using AbsurdJS.</p>

<h3>Controlling the DOM</h3>

<p>Along with the PHP served markup, we had dynamically created DOM elements. This means that we needed access to the existing DOM elements or new ones, that will be later added to the page. For example, let's say that we have the following HTML:</p>

<pre class="brush: html">&lt;div class="content"&gt;
    &lt;h1&gt;Page title&lt;/h1&gt;
    &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
&lt;/div&gt;</pre>

<p>Here is a component which retrieves the heading:</p>

<pre class="brush: javascript">absurd.component('MyComp', {
    html: '.content h1',
    constructor: function() {
        this.populate();
        console.log(this.el.innerHTML); // Page title
    }
})();
</pre>

<p>The <code>populate</code> method is the only <em>magic</em> method in the whole library. It does several things like compiling CSS or HTML, it binds events and such things. In the example above, it sees that there is an <code>html</code> property and initializes the <code>el</code> variable which points to the DOM element. This works pretty good for us because once we got that reference, we were able to work with the elements and its children. For those components that needed dynamically created elements, the <code>html</code> property accepts an object.</p>

<pre class="brush: javascript">absurd.component('MyComp', {
    html: {
        'div.content': {
            h1: 'Page title',
            p: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.'
        }
    },
    constructor: function() {
        this.populate();
        document.querySelector('body').appendChild(this.el);
    }
})();
</pre>

<p>The JSON above is translated to the same HTML markup. I chose JSON because from a JavaScript point of view, it is much more flexible. We are able to merge objects, replace or delete only parts of it. In most of the popular frameworks, the templates are just plain text that makes them difficult for manipulating. AbsurdJS also has its own <a href="http://krasimirtsonev.com/blog/article/Javascript-template-engine-in-just-20-line">templating engine</a>.</p>

<pre class="brush: javascript">absurd.component('MyComp', {
    html: {
        'div.content': {
            h1: '&lt;% this.title %&gt;',
            ul: [
                '&lt;% for(var i=0; i',
                { li: '&lt;% this.availableFor[i] %&gt;' },
                '&lt;% } %&gt;'
            ]
        }
    },
    title: 'That\'s awesome',
    availableFor: ['all browsers', 'Node.js'],
    constructor: function() {
        this.populate();
        document.querySelector('body').appendChild(this.el);
    }
})();
</pre>

<p>The result is:</p>

<pre class="brush: html">&lt;div class="content"&gt;
    &lt;h1&gt;That's awesome&lt;/h1&gt;
    &lt;ul&gt;
        &lt;li&gt;all browsers&lt;/li&gt;
        &lt;li&gt;Node.js&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;</pre>

<p>The <code>this</code> keyword in the expressions above, points to the component itself. The code between <code>&lt;%</code> and <code>%&gt;</code> is valid JavaScript. So, features like computed properties could be easily developed directly into the template's definition. Of course, we are able to use the same template engine with already existing markup. For example:</p>

<pre class="brush: html">&lt;div class="content"&gt;
    &lt;h1&gt;&lt;% this.title %&gt;&lt;/h1&gt;
    &lt;ul&gt;
        &lt;% for(var i=0; i&amp;amp;lt;this.availableFor.length; i++) { %&gt;
        &lt;li&gt;&lt;% this.availableFor[i] %&gt;&lt;/li&gt;
        &lt;% } %&gt;
    &lt;/ul&gt;
&lt;/div&gt;</pre>

<p>... could be controlled with the following component (the result is the same):</p>

<pre class="brush: javascript">absurd.component('MyComp', {
    html: '.content',
    title: 'That\'s awesome',
    availableFor: ['all browsers', 'Node.js'],
    constructor: function() {
        this.populate();
    }
})();
</pre>

<p>Anyway, the point is that we were able to define templates or create such from scratch. We are also able to control the data that is injected in an easy and natural way. Everything is just properties of the good old JavaScript object. </p>

<h3>What About the Styling?</h3>

<p>We successfully split the whole system in to small modules. The parts that were before Angular controllers, became AbsurdJS components. We realized that their HTML was tightly attached to their definition, that completely changed the management of the markup in the application. We stopped thinking about the concatenation, conventions or anything like that. We did not have to create HTML files at all. When I look back, I could see this exact moment in our commit history. It is easily visible because many files were removed from the code-base. </p>

<p>Then I thought, what will happen if we do the same thing with the CSS. It was of course possible because AbsurdJS was a CSS preprocessor and could produce CSS. We just got the compiled string, create a new <code>style</code> tag in the <code>head</code> of the current page and inject it there.</p>

<pre class="brush: javascript">absurd.component('MyComp', {
    css: {
        '.content': {
            h1: {
                color: '#99FF00',
                padding: 0,
                margin: 0
            },
            p: {
                fontSize: '20px'
            }
        }
    },
    html: '.content',
    constructor: function() {
        this.populate();
    }
})();
</pre>

<p>Here is the <code>style</code> tag which is produced:</p>

<pre class="brush: html">&lt;style id="MyComp-css" type="text/css"&gt;
    .content h1 {
      color: #99FF00;
      padding: 0;
      margin: 0;
    }
    .content p {
      font-size: 20px;
    }
&lt;/style&gt;</pre>

<p>And day by day we transferred the CSS styles from the SASS files (because, at some point, we chose SASS as a CSS preprocessor) to the AbsurdJS components. To be honest, it was pretty easy because all the mixins and variables which we have, were defined as JavaScript functions and variables. The sharing of the styles was even easier because everything was JavasSript. </p>

<h3>That Awkward Moment</h3>

<p>... when everything works perfectly but you feel that something is wrong</p>

<p>We were looking at the code. It worked. AbsurdJS drove even the old parts. The new stuff uses the same library. The HTML and the CSS were nicely separated and placed directly into the components' definition. However, I felt that there was something wrong. I stopped for a while and asked myself: "What is the Web made from?".</p><figure class="post_image"><img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/20602/image/img4.png"></figure>

<p>And what we did, is a little bit different. It looks more like the picture below.</p><figure class="post_image"><img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/20602/image/img5.png"></figure>

<p>I've been building websites for more than ten years and I remember the times when we all fought for the big separation of these three building materials. And what I did in this project is exactly the opposite. There was no CSS and HTML files (almost) at all. Everything was JavaScript.&nbsp;</p><p>Many people will say that this is ridiculous and we should give the client's money back. Yes, this could be true, but this concept worked perfectly in our case. We did not write an application. In fact, we wrote a bunch of independent components. I believe that the Web will be a combination of ready-to-use components.&nbsp;</p><p>We, as developers, will have to develop such components and probably connect with and use such components written by others. Projects like <a href="http://absurdjs.com/">AbsurdJS</a> or <a href="http://www.polymer-project.org/">Polymer</a> are showing that this is possible and I encourage you to experiment in this direction. </p>

<h2>Back to Reality</h2>

<p>So in the end the client's business went well. It was so good that he decided to launch a new service. And guess what. He wanted some parts of the existing application transferred into the new project. I can't tell you how happy we were to move components from one place to another. We did not have to setup something, copy HTML markup or CSS files. We just got the JavaScript file of the component, placed it somewhere and created an instance of it. It just worked because there were no dependencies. I'd not be surprised if some of these components are put up for sale very soon. They are pretty light and provide nice functionality connected with the client's product.</p>

<p>Yes, we broke some rules. Rules that I personally agree with. Rules that I followed for many years. However, the reality is that we all want quality and sometimes that quality is reachable by breaking the rules. We want to produce good, well structured code which is easily maintainable, flexible and extendable. We do not want to look back and say, "Oh my gosh ... was that written by me!?". When I look back now, I know why the code looks the way it does. It looks like that because it was written for that project specifically.</p>

<h2>Conclusion</h2>

<p>If you found this tutorial interesting, check out the official page of <a href="http://absurdjs.com/">AbsurdJS</a>. There are guides, documentation, and articles. You can even try the <a href="http://absurdjs.com/pages/try-it/">library online</a>. Like every other tool, AbsurdJS is designed for specific usage. It fit well for our project and may fit for yours. I don't even call it a framework, because I don't like this definition. It's more like a toolbox rather then a full stack framework. Feel free to experiment with it, make pull requests or submit issues. It's completely open source and <a href="https://github.com/krasimir/absurd">available at GitHub</a>.</p>