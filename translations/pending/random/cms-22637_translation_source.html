<h1>Projeto de APIs RESTful com NodeJS e Restify</h1>

<p>Uma API Rest consiste de dois conceitos principais: <strong>Recurso</strong> e <strong>Representação</strong>. Um <em>Recurso</em> pode ser qualquer objeto associado a um dado ou identificado a uma URI (mais de uma URI pode referir-se a um mesmo recurso), e que pode ser operado usando métodos HTTP. Uma <em>Representação</em> é uma forma de apresentar um recurso. Neste tutorial, passaremos um conteúdo teórico sobre projetos de APIs RESTful e implementaremos uma API de blog, usando o NodeJS.</p>

<h2>Recurso</h2>

<p>Escolher os recursos corretos para uma API RESTful é uma parte importante do projeto. Primeiro de tudo, você precisa analisar o domínio do seu negócio e, depois, decidir quantos e quais recursos serão usados e que são relevantes às necessidades do seu negócio. Se você estiver projetando uma API para um blog, provavelmente usará recursos como <strong>Artigo</strong>, <strong>Usuário</strong> e <strong>Comentário</strong>. Esses são os nomes dos recursos e os dados associados a eles são o recurso em si:</p>

<pre class="brush: javascript">{
"title": "Como Projetar uma API RESTful",
    "content": "Projeto de API RESTful é muito importante no mundo do desenvolvimento de software.",
    "author": "erickpatrick",
    "tags": [
        "technology",
        "nodejs",
        "node-restify"
        ]
    "category": "NodeJS"
}</pre>

<h3>Verbos de Recursos</h3>

<p>Podemos prosseguir com a operação do recurso após decidir quais são os recursos obrigatório. Operações referem-se aos métodos HTTP. Por exemplo, para criarmos um artigo, podemos realizar a seguinte requisição:</p>

<pre class="brush: plain">POST /articles HTTP/1.1
Host: localhost:3000
Content-Type: application/json

{
  "title": "Projeto de API RESTful com Restify",
  "slug": "projeto-api-rest-restify",
  "content": "Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas.",
  "author": "erickpatrick"
}</pre>

<p>Da mesma forma, podemos visualizar um artigo realizando a seguinte requisição:</p>

<pre class="brush: plain">GET /articles/123456789012 HTTP/1.1
Host: localhost:3000
Content-Type: application/json</pre>

<p>E quanto a atualizar um artigo já existente? Sei muito bem o que você está pensando:</p>

<blockquote>Posso realizar outra requisição POST em relação a <code>/articles/update/123456789012</code> com os dados a serem atualizados.</blockquote>

<p>Talvez, mas a URI está ficando um pouco mais complexa. Como disse mais cedo, as operações referem-se aos métodos HTTP. Isso significa que devemos apresentar a operação de <strong>atualização</strong> no método HTTP ao invés de colocá-lo na URI. Por exemplo:</p>

<pre class="brush: plain">PUT /articles/123456789012 HTTP/1.1
Host: localhost:3000
Content-Type: application/json
{
"title": "Como Projetar um API RESTful - Atualizada",
    "content": "Como Projetar um API RESTful - Atualizada - é muito importante no mundo do desenvolvimento de software.",
    "author": "erickpatrick",
    "tags": [
        "tecnologia",
        "nodejs",
        "restify",
        "outra tag"
        ]
    "category": "NodeJS"
}</pre>

<p>Por falar em alterações, neste exemplo podemos ver campos de <em>tags</em> e categorias. Eles não são campos obrigatórios. Você pode deixá-los em branco e preenchê-los no futuro. </p>

<p>Algumas vezes, você precisa remover um artigo que esteja desatualizado. Nestes casos, você pode usar uma requisição HTTP do tipo <strong>DELETE</strong> em relação à URI <strong>/articles/123456789012.</strong></p>

<p>Os métodos HTTP são conceitos padrões. Se usá-los como operações, você terá URIs mais simples e esse tipo de API simples ajudará você a obter clientes, clientes felizes.</p>

<p>E se você quisesse publicar um comentário em um artigo? Você pode selecionar o artigo e adicionar um comentário novo a ele. Com essa expressão em mente, você pode realizar a seguinte requisição:</p>

<pre class="brush: plain">POST /articles/123456789012/comments HTTP/1.1
Host: localhost:3000
Content-Type: application/json
{
"text": "Wow! Este é um ótimo tutorial",
    "author": "Zé niguém"
}</pre>

<p>A forma de recurso acima é chamada de <strong>sub-recurso</strong>. <strong>Comentário</strong> é um sub-recurso de <strong>Artigo</strong>. Os <strong>Comentário</strong> e sua carga acima serão inseridos na base de dados como um filho de <strong>Artigo</strong>. Algumas vezes, uma URI diferente refere-se a uma mesmo recurso. Por exemplo, para ver um comentário específico, você pode usar tanto:</p>

<pre class="brush: plain">GET /articles/123456789012/comments/123 HTTP/1.1
Host: localhost:3000
Content-Type: application/json
</pre>

<p>ou:</p>

<pre class="brush: plain">GET /comments/123456789012 HTTP/1.1
Host: localhost:3000
Content-Type: application/json</pre>

<h3>Versionamento</h3>

<p>Geralmente, funcionalidades de uma API alteram-se frequentemente, para que se possa oferecer novas funcionalidades aos clientes. Neste caso, duas versões de uma mesma API podem existir ao mesmo tempo. Para separá-las, você pode usar versionamento. Há duas formas de versionamento</p>

<ol>
  <li><strong>Versão na URI: </strong>Você pode prover o número de versão na própria URI. Por exemplo, <strong><code class="inline">/v1.1/articles/123456789012</code></strong>.</li>
  <li><strong>Versão no Cabeçalho: </strong>Você pode prover o número da versão no cabeçalho e nunca precisar mudar a URI. Por exemplo:</li>
</ol>

<pre class="brush: plain">GET /articles/123456789012 HTTP/1.1
Host: localhost:3000
Accept-Version: 1.0</pre>

<p>Na verdade, a versão apenas altera a representação do recurso, não o conceito do recurso em si. Então, você não precisa alterar a estrutura do URI. Na v1.1, talvez um novo campo seja adicionado ao Artigo. Entretanto, ele ainda retorna um artigo. Na segunda opção, a URI continua simples e os clientes não precisam alterar as URIs em suas implementações. </p>

<p>É importante projetar uma estratégia para situações onde o cliente não provê um número de versão. Você pode lançar um erro quando um número de versão não é apresentado ou você pode retornar uma resposta usando a primeira versão. Se você usar a última versão estável como a versão padrão, os clientes podem obter vários erros em suas implementações.</p>

<h2>Representação</h2>

<p>A Representação é a forma como uma API apresenta um recurso. Ao invocar uma API através de uma URI, você receberá um recurso. Esse recurso pode estar em um formato como o XML, JSON, etc. É preferido o formato JSON caso esteja projetando uma nova API. Entretanto, se você estiver atualizando uma API já existente e que já é acostumada a retornar uma resposta XML, você pode prover outra versão com uma resposta em JSON. </p>

<p>Certo, deixemos a teoria sobre projetos de APIs RESTful de lado. Vejamos como projetar e implementar uma API para blogs usando o Restify.</p>

<h2>API RESTful de um Blog</h2>

<h3>Projeto</h3>

<p>Para projetarmos uma API RESTful, precisamos analizar o domínio do negócio. Só então podemos definir nossos recursos. Em uma API de blogs, precisamos:</p>

<ul>
  <li>Criar, Atualizar, Apagar e Visualizar um <strong>Artigo</strong></li>
  <li>Criar comentários para um <strong>Artigo</strong> específico, além de Atualizar, Apagar e Visualizar um <strong>Comentário</strong></li>
  <li>Criar, Atualizar, Apagar e Visualizar um <strong>Usuário</strong></li>
</ul>

<p>Nesta API, não cobrirei a parte de autenticação necessária para criar um artigo ou comentário. Para essa parte, você pode referir-se ao artigo <a href="http://code.tutsplus.com/pt/tutorials/token-based-authentication-with-angularjs-nodejs--cms-22543" target="_self">Autenticação com Tokens Usando AngularJS &amp; NodeJS</a>. </p>

<p>Os nomes dos nossos recursos estão prontos. Operações de recursos são <em>CRUD</em> simples. Você pode referir-se à tabela a seguir para ter uma visualização geral da API.</p>

<table>
  <thead>
    <tr>
      <th>Nome do Recurso</th>
      <th>Verbos HTTP</th>
      <th>Métodos HTTP</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Artigo</td>
      <td>criar Artigo, atualizar Artigo, remover Artigo, visualizar Artigo</td>
      <td>POST /articles com os dados, PUT /articles/123 com os dados, DELETE /articles/123 e GET /article/123</td>
    </tr>
    <tr>
      <td>Comentário</td>
      <td>criar Comentário, atualizar Comentário, remover Comentário, visualizar Comentário</td>
      <td>POST /articles/123/comments com os dados, PUT /comments/123 with Payload, DELETE /comments/123 e GET /comments/123</td>
    </tr>
    <tr>
      <td>Usuário</td>
      <td>criar Usuário, atualizar Usuário, remover Usuário, visualizar Usuário</td>
      <td>POST /users com os dados, PUT /users/123 com os dados, DELETE /users/123 e GET /users/123</td>
    </tr>
  </tbody>
</table>

<h3>Configuração do Projeto</h3>

<p>Neste projeto, usaremos o <strong>NodeJS</strong> com <strong>Restify</strong>. Os recursos serão salvos em uma base de dados <strong>MongoDB</strong>. Antes de tudo, devemos definir os recursos como modelos no Restify.</p>

<h4><strong>Artigo</strong></h4>

<pre class="brush: javascript">var mongoose = require("mongoose");
var Schema   = mongoose.Schema;

var ArtigoSchema = new Schema({
title: String,
    slug: String,
    content: String,
    author: {
        type: String,
        ref: "Usuario"
    }
});
mongoose.model('Artigo', ArtigoSchema);</pre>

<h4><strong>Comentários</strong></h4>

<pre class="brush: javascript">var mongoose = require("mongoose");
var Schema   = mongoose.Schema;

var ComentarioSchema = new Schema({
text: String,
    article: {
        type: String,
        ref: "Artigo"
    },
    author: {
        type: String,
        ref: "Usuario"
    }
});
mongoose.model('Comentarios', ComentariosSchema);</pre>

<h4>Usuário</h4>

<p>Não haverá operações para o recurso Usuário. Assumiremos que já sabemos o usuário atual que será capaz de operar os artigos ou comentários.</p>

<p>Você deve se perguntar de onde esse módulo <a href="http://mongoosejs.com/index.html" target="_self">mongoose</a> vem. É o <em>framework</em> ORM para MongoDB escrito como módulo para NodeJS mais conhecido. Este módulo está incluso no projeto, dentro de outro arquivo de configuração. </p>

<p>Agora, podemos definir nossos verbos HTTP para os recursos acima. Você pode ver abaixo:</p>

<pre class="brush: javascript">var restify = require('restify')
, fs = require('fs')


var controllers = {}
    , controllers_path = process.cwd() + '/app/controllers'
fs.readdirSync(controllers_path).forEach(function (file) {
    if (file.indexOf('.js') != -1) {
        controllers[file.split('.')[0]] = require(controllers_path + '/' + file)
    }
})

var server = restify.createServer();

server
    .use(restify.fullResponse())
    .use(restify.bodyParser())

// Início dos Artigos
server.post("/articles", controllers.article.createArtigo)
server.put("/articles/:id", controllers.article.updateArtigo)
server.del("/articles/:id", controllers.article.deleteArtigo)
server.get({path: "/articles/:id", version: "1.0.0"}, controllers.article.viewArtigo)
server.get({path: "/articles/:id", version: "2.0.0"}, controllers.article.viewArtigo_v2)
// Fim dos Artigos

// Início dos Comentarios
server.post("/comments", controllers.comment.createComentarios)
server.put("/comments/:id", controllers.comment.viewComentarios)
server.del("/comments/:id", controllers.comment.deleteComentarios)
server.get("/comments/:id", controllers.comment.viewComentarios)
// Fim dos Comentarios

var port = process.env.PORT || 3000;
server.listen(port, function (err) {
    if (err)
        console.error(err)
    else
        console.log('Aplicativo pronto na porta: ' + port)
})

if (process.env.environment == 'production')
    process.on('uncaughtException', function (err) {
        console.error(JSON.parse(JSON.stringify(err, ['stack', 'message', 'inner'], 2)))
    })</pre>

<p>In this code snippet, first of all the controller files that contain controller methods are iterated and all the controllers are initialized in order to execute a specific request to the URI. After that, URIs for specific operations are defined for basic CRUD operations. There is also versioning for one of the operations on Artigo. </p>

<p>For example, if you state version as <code class="inline">2</code> in Accept-Version header, <code class="inline">viewArtigo_v2</code> will be executed. <code class="inline">viewArtigo</code> and <code class="inline">viewArtigo_v2</code> both do the same job, showing the resource, but they show Artigo resource in a different format, as you can see in the <code class="inline">title</code> field below. Finally, the server is started on a specific port, and some error reporting checks are applied. We can proceed with controller methods for HTTP operations on resources.</p>

<h4><strong>article.js</strong></h4>

<pre class="brush: javascript">var mongoose = require('mongoose'),
Artigo = mongoose.model("Artigo"),
    ObjectId = mongoose.Types.ObjectId

exports.createArtigo = function(req, res, next) {
    var articleModel = new Artigo(req.body);
    articleModel.save(function(err, article) {
        if (err) {
            res.status(500);
            res.json({
                type: false,
                data: "Error occured: " + err
            })
        } else {
            res.json({
                type: true,
                data: article
            })
        }
    })
}

exports.viewArtigo = function(req, res, next) {
    Artigo.findById(new ObjectId(req.params.id), function(err, article) {
        if (err) {
            res.status(500);
            res.json({
                type: false,
                data: "Error occured: " + err
            })
        } else {
            if (article) {
                res.json({
                    type: true,
                    data: article
                })
            } else {
                res.json({
                    type: false,
                    data: "Artigo: " + req.params.id + " not found"
                })
            }
        }
    })
}

exports.viewArtigo_v2 = function(req, res, next) {
    Artigo.findById(new ObjectId(req.params.id), function(err, article) {
        if (err) {
            res.status(500);
            res.json({
                type: false,
                data: "Error occured: " + err
            })
        } else {
            if (article) {
                article.title = article.title + " v2"
                res.json({
                    type: true,
                    data: article
                })
            } else {
                res.json({
                    type: false,
                    data: "Artigo: " + req.params.id + " not found"
                })
            }
        }
    })
}

exports.updateArtigo = function(req, res, next) {
    var updatedArtigoModel = new Artigo(req.body);
    Artigo.findByIdAndUpdate(new ObjectId(req.params.id), updatedArtigoModel, function(err, article) {
        if (err) {
            res.status(500);
            res.json({
                type: false,
                data: "Error occured: " + err
            })
        } else {
            if (article) {
                res.json({
                    type: true,
                    data: article
                })
            } else {
                res.json({
                    type: false,
                    data: "Artigo: " + req.params.id + " not found"
                })
            }
        }
    })
}

exports.deleteArtigo = function(req, res, next) {
    Artigo.findByIdAndRemove(new Object(req.params.id), function(err, article) {
        if (err) {
            res.status(500);
            res.json({
                type: false,
                data: "Error occured: " + err
            })
        } else {
            res.json({
                type: true,
                data: "Artigo: " + req.params.id + " deleted successfully"
            })
        }
    })
}
</pre>

<p>You can find an explanation of basic CRUD operations on the Mongoose side below:</p>

<ul>
  <li><strong>createArtigo: </strong>This is a simple <strong>save </strong>operation on <code class="inline">articleModel</code> sent from the request body. A new model can be created by passing the request body as a constructor to a model like <code class="inline">var articleModel = new Artigo(req.body)</code>. </li>
  <li><strong>viewArtigo: </strong>In order to view article detail, an article ID is needed in the URL parameter. <code class="inline">findOne</code> with an ID parameter is enough to return article detail.</li>
  <li><strong>updateArtigo: </strong>Artigo update is a simple find query and some data manipulation on the returned article. Finally, the updated model needs to be saved to the database by issuing a <code class="inline">save</code> command.</li>
  <li><strong>deleteArtigo: </strong><code class="inline">findByIdAndRemove</code> is the best way to delete an article by providing the article ID.</li>
</ul>

<p>The Mongoose commands mentioned above are simply static like method through Artigo object that is also a reference of the Mongoose schema.</p>

<h4><strong>comment.js</strong></h4>

<pre class="brush: javascript">var mongoose = require('mongoose'),
Comentários = mongoose.model("Comentários"),
    Artigo = mongoose.model("Artigo"),
    ObjectId = mongoose.Types.ObjectId

exports.viewComentários = function(req, res) {
    Artigo.findOne({"comments._id": new ObjectId(req.params.id)}, {"comments.$": 1}, function(err, comment) {
        if (err) {
            res.status(500);
            res.json({
                type: false,
                data: "Error occured: " + err
            })
        } else {
            if (comment) {
                res.json({
                    type: true,
                    data: new Comentários(comment.comments[0])
                })
            } else {
                res.json({
                    type: false,
                    data: "Comentários: " + req.params.id + " not found"
                })
            }
        }
    })
}

exports.updateComentários = function(req, res, next) {
    var updatedComentáriosModel = new Comentários(req.body);
    console.log(updatedComentáriosModel)
    Artigo.update(
        {"comments._id": new ObjectId(req.params.id)},
        {"$set": {"comments.$.text": updatedComentáriosModel.text, "comments.$.author": updatedComentáriosModel.author}},
        function(err) {
            if (err) {
                res.status(500);
                res.json({
                    type: false,
                    data: "Error occured: " + err
                })
            } else {
                res.json({
                    type: true,
                    data: "Comentários: " + req.params.id + " updated"
                })
            }
    })
}

exports.deleteComentários = function(req, res, next) {
    Artigo.findOneAndUpdate({"comments._id": new ObjectId(req.params.id)},
        {"$pull": {"comments": {"_id": new ObjectId(req.params.id)}}},
        function(err, article) {
        if (err) {
            res.status(500);
            res.json({
                type: false,
                data: "Error occured: " + err
            })
        } else {
            if (article) {
                res.json({
                    type: true,
                    data: article
                })
            } else {
                res.json({
                    type: false,
                    data: "Comentários: " + req.params.id + " not found"
                })
            }
        }
    })
}</pre>

<p>When you make a request to one of the resource URIs, the related function stated in the controller will be executed. Every function inside the controller files can use the <strong>req</strong> and <strong>res</strong> objects. The <strong>comment</strong> resource here is a sub-resource of <strong>Artigo. </strong>All the query operations are made through the Artigo model in order to find a sub-document and make the necessary update. However, whenever you try to view a Comentários resource, you will see one even if there is no collection in MongoDB.  </p>

<h2>Other Design Suggestions</h2>

<ul>
  <li>Select easy-to-understand resources in order to provide easy usage to consumers.</li>
  <li>Let business logic be implemented by consumers. For example, the Artigo resource has a field called <strong>slug. </strong>Consumers do not need to send this detail to the RESTful API. This slug strategy should manage on the RESTful API side to reduce coupling between API and consumers. Consumers only need to send title detail, and you can generate the slug according to your business needs on the RESTful API side.</li>
  <li>Implement an authorization layer for your API endpoints. Unauthorized consumers can access restricted data that belongs to another user. In this tutorial, we did not cover the Usuário resource, but you can refer to <a href="http://code.tutsplus.com/tutorials/token-based-authentication-with-angularjs-nodejs--cms-22543" target="_self">Token Based Authentication with AngularJS &amp; NodeJS</a> for more information about API authentications.</li>
  <li>Usuário URI instead of query string. <code class="inline">/articles/123</code>  (Good), <code class="inline">/articles?id=123</code> (Bad).</li>
  <li>Do not keep the state; always use instant input/output.</li>
  <li>Use noun for your resources. You can use HTTP methods in order to operate on resources.</li>
</ul>

<p>Finally, if you design a RESTfulful API by following these fundamental rules, you will always have a flexible, maintainable, easily understandable system.</p>