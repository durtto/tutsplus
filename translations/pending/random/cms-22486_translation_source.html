<h1>Laravel, BDD and You: The First Feature</h1>

<p>In the second part of this series called Laravel, BDD and You, we will start describing and building our first feature using Behat and PhpSpec. In the last article we got everything set up and saw how easily we can interact with Laravel in our Behat scenarios.</p>

<p>Recently the creator of Behat, Konstantin Kudryashov (a.k.a. everzet), wrote a really great article called <a href="http://everzet.com/post/99045129766/introducing-modelling-by-example" target="_self">Introducing Modelling by Example</a>. The workflow we are going to use, when we build our feature, is highly inspired by the one presented by everzet. </p>

<p>In short, we are going to use the same <code class="inline">.feature</code> to design both our core domain and our user interface. I have often felt that I had a lot of duplication in my features in my acceptance/functional and integration suites. When I read everzet's suggestion about using the same feature for multiple contexts, it all clicked for me and I believe it is the way to go. </p>

<p>In our case we will have our functional context, which will, for now, also serve as our acceptance layer, and our integration context, which will cover our domain. We will start by building the domain and then add the UI and framework-specific things afterwards.</p>

<h2>Small Refactorings</h2>

<p>In order to use the "shared feature, multiple contexts" approach, we have to do a few refactorings of our existing setup.</p>

<p>First, we are going to delete the welcome feature we did in the first part, since we do not really need it and it does not really follow the generic style we need in order to use multiple contexts.</p>

<div>
  <pre class="brush: bash">$ git rm features/functional/welcome.feature</pre>
</div>

<p>Second, we are going to have our features in the root of the <code>features</code> folder, so we can go ahead and remove the <code>path</code> attribute from our <code>behat.yml</code> file. We are also going to rename the <code>LaravelFeatureContext</code> to <code>FunctionalFeatureContext</code> (remember to change the class name as well):</p>

<div>
  <pre class="brush: plain">default:
suites:
        functional:
            contexts: [ FunctionalFeatureContext ]</pre>
</div>

<p>Finally, just to clean things up a bit, I think we should move all Laravel-related stuff into its own trait:</p>

<div>
  <pre class="brush: php"># features/bootstrap/LaravelTrait.php

&lt;?php

use Illuminate\Foundation\Testing\ApplicationTrait;

trait LaravelTrait
{
/**
     * Responsible for providing a Laravel app instance.
     */
    use ApplicationTrait;

    /**
     * @BeforeScenario
     */
    public function setUp()
    {
        if ( ! $this-&gt;app)
        {
            $this-&gt;refreshApplication();
        }
    }

    /**
     * Creates the application.
     *
     * @return \Symfony\Component\HttpKernel\HttpKernelInterface
     */
    public function createApplication()
    {
        $unitTesting = true;

        $testEnvironment = 'testing';

        return require __DIR__.'/../../bootstrap/start.php';
    }
}

</pre>
</div>

<p>In the <code>FunctionalFeatureContext</code> we can then use the trait and delete the things we just moved:</p>

<div>
  <pre class="brush: php">/**
 * Behat context class.
 */
class FunctionalFeatureContext implements SnippetAcceptingContext
{
use LaravelTrait;

    /**
     * Initializes context.
     *
     * Every scenario gets its own context object.
     * You can also pass arbitrary arguments to the context constructor through behat.yml.
     */
    public function __construct()
    {
    }</pre>
</div>

<p>Traits are a great way to clean up your contexts.</p>

<h2>Sharing a Feature</h2>

<p>As presented in part one, we are going to build a small application for time tracking. The first feature is going to be about tracking time and generating a time sheet from the tracked entries. Here is the feature:</p>

<div>
  <pre>Feature: Tracking time
In order to track time spent on tasks
    As an employee
    I need to manage a time sheet with time entries

    Scenario: Generating time sheet
        Given I have the following time entries
            | task        | duration |
            | coding      | 90       |
            | coding      | 30       |
            | documenting | 150      |
        When I generate the time sheet
        Then my total time spent on coding should be 120 minutes
        And my total time spent on documenting should be 150 minutes
        And my total time spent on meetings should be 0 minutes
        And my total time spent should be 270 minutes
</pre>
</div>

<p>Remember that this is only an example. I find it easier to define features in real life, since you have an actual problem you need to solve and often get the chance to discuss the feature with colleagues, clients, or other stakeholders.</p>

<p>Okay, let us have Behat generate the scenario steps for us:</p>

<div>
  <pre class="brush: bash">$ vendor/bin/behat --dry-run --append-snippets</pre>
</div>

<p>We need to tweak the generated steps just a tiny bit. We only need four steps to cover the scenario. The end result should look something like this:</p>

<div>
  <pre class="brush: php">/**
 * @Given I have the following time entries
 */
public function iHaveTheFollowingTimeEntries(TableNode $table)
{
throw new PendingException();
}

/**
 * @When I generate the time sheet
 */
public function iGenerateTheTimeSheet()
{
    throw new PendingException();
}

/**
 * @Then my total time spent on :task should be :expectedDuration minutes
 */
public function myTotalTimeSpentOnTaskShouldBeMinutes($task, $expectedDuration)
{
    throw new PendingException();
}

/**
 * @Then my total time spent should be :expectedDuration minutes
 */
public function myTotalTimeSpentShouldBeMinutes($expectedDuration)
{
    throw new PendingException();
}
</pre>
</div>

<p>Our functional context is all ready to go now, but we also need a context for our integration suite. First, we will add the suite to the <code>behat.yml</code> file:</p>

<div>
  <pre>default:
suites:
        functional:
            contexts: [ FunctionalFeatureContext ]
        integration:
            contexts: [ IntegrationFeatureContext ]
</pre>
</div>

<p>Next, we can just copy the default <code>FeatureContext</code>:</p>

<div>
  <pre class="brush: bash">$ cp features/bootstrap/FeatureContext.php features/bootstrap/IntegrationFeatureContext.php
</pre>
</div>

<p>Remember to change the class name to <code>IntegrationFeatureContext</code> and also to copy the use statement for the <code>PendingException</code>.</p>

<p>Finally, since we are sharing the feature, we can just copy the four step definitions from the functional context. If you run Behat, you will see that the feature is run twice: once for each context.</p>

<h2>Designing the Domain</h2>

<p>At this point, we are ready to start filling out the pending steps in our integration context in order to design the core domain of our application. The first step is <code>Given I have the following time entries</code>, followed by a table with time entry records. Keeping it simple, let us just loop over the rows of the table, try to instantiate a time entry for each of them, and add them to an entries array on the context:</p>

<div>
  <pre class="brush: php">use TimeTracker\TimeEntry;

...

/**
 * @Given I have the following time entries
 */
public function iHaveTheFollowingTimeEntries(TableNode $table)
{
$this-&gt;entries = [];

    $rows = $table-&gt;getHash();

    foreach ($rows as $row) {
        $entry = new TimeEntry;

        $entry-&gt;task     = $row['task'];
        $entry-&gt;duration = $row['duration'];

        $this-&gt;entries[] = $entry;
    }
}
</pre>
</div>

<p>Running Behat will cause a fatal error, since the <code>TimeTracker\TimeEntry</code> class does not yet exist. This is where PhpSpec enters the stage. In the end, <code>TimeEntry</code> is going to be an Eloquent class, even though we do not worry about it yet. PhpSpec and ORMs like Eloquent do not play together that well, but we can still use PhpSpec to generate the class and even spec out some basic behavior. Let us use the PhpSpec generators to generate the <code>TimeEntry</code> class:</p>

<div>
  <pre class="brush: bash">$ vendor/bin/phpspec desc "TimeTracker\TimeEntry"
$ vendor/bin/phpspec run
Do you want me to create `TimeTracker\TimeEntry` for you? y
</pre>
</div>

<p>After the class is generated, we need to update the autoload section of our <code>composer.json</code> file:</p>

<div>
  <pre class="brush: javascript">"autoload": {
"classmap": [
        "app/commands",
        "app/controllers",
        "app/models",
        "app/database/migrations",
        "app/database/seeds"
    ],
    "psr-4": {
        "TimeTracker\\": "src/TimeTracker"
    }
},
</pre>
</div>

<p>And of course run <code>composer dump-autoload</code>.</p>

<p>Running PhpSpec gives us green. Running Behat gives us green as well. What a great start!</p>

<p>Letting Behat guide our way, how about we just move along to the next step, <code>When I generate the time sheet</code>, right away?</p>

<p>The keyword here is "generate", which looks like a term from our domain. In a programmer's world, translating "generate the timesheet" to code could just mean instantiating a <code>TimeSheet</code> class with a bunch of time entries. It is important to try and stick to the language from the domain when we design our code. That way, our code will help describe the intended behavior of our application. </p>

<p>I identify the term <code>generate</code> as important for the domain, which is why I think we should have a static generate method on a <code class="inline">TimeSheet</code> class that serves as an alias for the constructor. This method should take a collection of time entries and store them on the time sheet. </p>

<p>Instead of just using an array, I think it will make sense to use the <code>Illuminate\Support\Collection</code> class that comes with Laravel. Since <code>TimeEntry</code> will be an Eloquent model, when we query the database for time entries, we will get one of these Laravel collections anyway. How about something like this:</p>

<div>
  <pre class="brush: php">use Illuminate\Support\Collection;
use TimeTracker\TimeSheet;
use TimeTracker\TimeEntry;

...

/**
 * @When I generate the time sheet
 */
public function iGenerateTheTimeSheet()
{
$this-&gt;sheet = TimeSheet::generate(Collection::make($this-&gt;entries));
}
</pre>
</div>

<p>By the way, TimeSheet is not going to be an Eloquent class. At least for now, we only need to make the time entries persist, and then the time sheets will just be <em>generated</em> from the entries.</p>

<p>Running Behat will, once again, cause a fatal error, because <code>TimeSheet</code> does not exist. PhpSpec can help us solve that:</p>

<div>
  <pre class="brush: bash">$ vendor/bin/phpspec desc "TimeTracker\TimeSheet"
$ vendor/bin/phpspec run
Do you want me to create `TimeTracker\TimeSheet` for you? y
$ vendor/bin/phpspec run

$ vendor/bin/behat

PHP Fatal error:  Call to undefined method TimeTracker\TimeSheet::generate()
</pre>
</div>

<p>We still get a fatal error after creating the class, because the static <code>generate()</code> method still does not exist. Since this is a really simple static method, I do not think there is a need for a spec. It is nothing more than a wrapper for the constructor:</p>

<div>
  <pre class="brush: php">&lt;?php

namespace TimeTracker;

use Illuminate\Support\Collection;

class TimeSheet
{
protected $entries;

    public function __construct(Collection $entries)
    {
        $this-&gt;entries = $entries;
    }

    public static function generate(Collection $entries)
    {
        return new static($entries);
    }
}
</pre>
</div>

<p>This will get Behat back to green, but PhpSpec is now squeaking at us, saying: <code class="inline">Argument 1 passed to TimeTracker\TimeSheet::__construct() must be an instance of Illuminate\Support\Collection, none given</code>. We can solve this by writing a simple <code>let()</code> function that will be called before each spec:</p>

<div>
  <pre class="brush: php">&lt;?php

namespace spec\TimeTracker;

use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

use Illuminate\Support\Collection;
use TimeTracker\TimeEntry;

class TimeSheetSpec extends ObjectBehavior
{
function let(Collection $entries)
    {
        $entries-&gt;put(new TimeEntry);

        $this-&gt;beConstructedWith($entries);
    }

    function it_is_initializable()
    {
        $this-&gt;shouldHaveType('TimeTracker\TimeSheet');
    }
}
</pre>
</div>

<p>This will get us back to green all over the line. The function makes sure that the time sheet is always constructed with a mock of the Collection class.</p>

<p>We can now safely move on to the <code>Then my total time spent on...</code> step. We need a method that takes a task name and return the accumulated duration of all entries with this task name. Directly translated from gherkin to code, this could be something like <code>totalTimeSpentOn($task)</code>:</p>

<div>
  <pre class="brush: php">/**
* @Then my total time spent on :task should be :expectedDuration minutes
*/
public function myTotalTimeSpentOnTaskShouldBeMinutes($task, $expectedDuration)
{
$actualDuration = $this-&gt;sheet-&gt;totalTimeSpentOn($task);

    PHPUnit::assertEquals($expectedDuration, $actualDuration);
}
</pre>
</div>

<p>The method does not exist, so running Behat will give us <code>Call to undefined method TimeTracker\TimeSheet::totalTimeSpentOn()</code>.</p>

<p>In order to spec out the method, we will write a spec that looks somehow similar to what we already have in our scenario:</p>

<div>
  <pre class="brush: php">function it_should_calculate_total_time_spent_on_task()
{
$entry1 = new TimeEntry;
    $entry1-&gt;task = 'sleeping';
    $entry1-&gt;duration = 120;

    $entry2 = new TimeEntry;
    $entry2-&gt;task = 'eating';
    $entry2-&gt;duration = 60;

    $entry3 = new TimeEntry;
    $entry3-&gt;task = 'sleeping';
    $entry3-&gt;duration = 120;

    $collection = Collection::make([$entry1, $entry2, $entry3]);

    $this-&gt;beConstructedWith($collection);

    $this-&gt;totalTimeSpentOn('sleeping')-&gt;shouldBe(240);
    $this-&gt;totalTimeSpentOn('eating')-&gt;shouldBe(60);
}
</pre>
</div>

<p>Note that we do not use mocks for the <code>TimeEntry</code> and <code>Collection</code> instances. This is our integration suite and I do not think there is a need to mock this out. The objects are quite simple and we want to make sure that the objects in our domain interact as we expect them to. There are probably many opinions about this, but this makes sense to me.</p>

<p>Moving along:</p>

<div>
  <pre class="brush: bash">$ vendor/bin/phpspec run
Do you want me to create `TimeTracker\TimeSheet::totalTimeSpentOn()` for you? y

$ vendor/bin/phpspec run

  25  ✘ it should calculate total time spent on task
  expected [integer:240], but got null.
</pre>
</div>

<p>In order to filter the entries, we can use the <code>filter()</code> method on the <code>Collection</code> class. A simple solution that gets us to green:</p>

<div>
  <pre class="brush: php">public function totalTimeSpentOn($task)
{
$entries = $this-&gt;entries-&gt;filter(function($entry) use ($task)
    {
        return $entry-&gt;task === $task;
    });

    $duration = 0;

    foreach ($entries as $entry) {
        $duration += $entry-&gt;duration;
    }

    return $duration;
}
</pre>
</div>

<p>Our spec is green, but I feel that we could benefit from some refactoring here. The method seems to do two different things: filter entries and accumulate the duration. Let us extract the latter to its own method:</p>

<div>
  <pre class="brush: php">public function totalTimeSpentOn($task)
{
$entries = $this-&gt;entries-&gt;filter(function($entry) use ($task)
    {
        return $entry-&gt;task === $task;
    });

    return $this-&gt;sumDuration($entries);
}

protected function sumDuration($entries)
{
    $duration = 0;

    foreach ($entries as $entry) {
        $duration += $entry-&gt;duration;
    }

    return $duration;
}
</pre>
</div>

<p>PhpSpec is still green and we now have three green steps in Behat. The last step should be easy to implement, since it is somewhat similar to the one we just did.</p>

<div>
  <pre class="brush: php">/**
 * @Then my total time spent should be :expectedDuration minutes
 */
public function myTotalTimeSpentShouldBeMinutes($expectedDuration)
{
$actualDuration = $this-&gt;sheet-&gt;totalTimeSpent();

    PHPUnit::assertEquals($expectedDuration, $actualDuration);
}
</pre>
</div>

<p>Running Behat will give us <code>Call to undefined method TimeTracker\TimeSheet::totalTimeSpent()</code>. Instead of doing a separate example in our spec for this method, how about we just add it to the one we already have? It might not be completely in line with what is "right" to do, but let us be a little pragmatic:</p>

<div>
  <pre class="brush: php">...

$this-&gt;beConstructedWith($collection);

$this-&gt;totalTimeSpentOn('sleeping')-&gt;shouldBe(240);
$this-&gt;totalTimeSpentOn('eating')-&gt;shouldBe(60);
$this-&gt;totalTimeSpent()-&gt;shouldBe(300);
</pre>
</div>

<p>Let PhpSpec generate the method:</p>

<div>
  <pre class="brush: bash">$ vendor/bin/phpspec run
Do you want me to create `TimeTracker\TimeSheet::totalTimeSpent()` for you? y

$ vendor/bin/phpspec run

  25  ✘ it should calculate total time spent on task
  expected [integer:300], but got null.
</pre>
</div>

<p>Getting to green is easy now that we have the <code>sumDuration()</code> method:</p>

<div>
  <pre class="brush: php">public function totalTimeSpent()
{
return $this-&gt;sumDuration($this-&gt;entries);
}
</pre>
</div>

<p>And now we have a green feature. Our domain is slowly evolving!</p>

<h2>Designing the User Interface</h2>

<p>Now, we are moving to our functional suite. We are going to design the user interface and deal with all the Laravel-specific stuff that is not the concern of our domain.</p>

<p>While working in the functional suite, we can add the <code>-s</code> flag to instruct Behat to only run our features through the <code>FunctionalFeatureContext</code>:</p>

<div>
  <pre class="brush: bash">$ vendor/bin/behat -s functional
</pre>
</div>

<p>The first step is going to look similar to the first one of the integration context. Instead of just making the entries persist on the context in an array, we need to actually make them persist in a database so that they can be retrieved later:</p>

<div>
  <pre class="brush: php">use TimeTracker\TimeEntry;

...

/**
 * @Given I have the following time entries
 */
public function iHaveTheFollowingTimeEntries(TableNode $table)
{
$rows = $table-&gt;getHash();

    foreach ($rows as $row) {
        $entry = new TimeEntry;

        $entry-&gt;task     = $row['task'];
        $entry-&gt;duration = $row['duration'];

        $entry-&gt;save();
    }
}
</pre>
</div>

<p>Running Behat will give us fatal error <code>Call to undefined method TimeTracker\TimeEntry::save()</code>, since <code>TimeEntry</code> still is not an Eloquent model. That is easy to fix:</p>

<div>
  <pre class="brush: php">namespace TimeTracker;

class TimeEntry extends \Eloquent
{
}
</pre>
</div>

<p>If we run Behat again, Laravel will complain that it cannot connect to the database. We can fix this by adding a <code>database.php</code> file to the <code>app/config/testing</code> directory, in order to add the connection details for our database. For larger projects, you probably want to use the same database server for your tests and your production code base, but in our case, we will just use an in memory SQLite database. This is super simple to set up with Laravel:</p>

<div>
  <pre class="brush: php">&lt;?php

return array(

'default' =&gt; 'sqlite',

    'connections' =&gt; array(

        'sqlite' =&gt; array(
            'driver'   =&gt; 'sqlite',
            'database' =&gt; ':memory:',
            'prefix'   =&gt; '',
        ),

    ),

);
</pre>
</div>

<p>Now if we run Behat, it will tell us that there is no <code>time_entries</code> table. In order to fix this, we need to make a migration:</p>

<div>
  <pre class="brush: bash">$ php artisan migrate:make createTimeEntriesTable --create="time_entries"
</pre>
</div>

<div>
  <pre class="brush: php">Schema::create('time_entries', function(Blueprint $table)
{
$table-&gt;increments('id');
    $table-&gt;string('task');
    $table-&gt;integer('duration');
    $table-&gt;timestamps();
});
</pre>
</div>

<p>We are still not green, since we need a way to instruct Behat to run our migrations before every scenario, so we have a clean slate every time. By using Behat's annotations, we can add these two methods to the <code>LaravelTrait</code> trait:</p>

<div>
  <pre class="brush: php">/**
 * @BeforeScenario
 */
public function setupDatabase()
{
$this-&gt;app['artisan']-&gt;call('migrate');
}

/**
 * @AfterScenario
 */
public function cleanDatabase()
{
    $this-&gt;app['artisan']-&gt;call('migrate:reset');
}
</pre>
</div>

<p>This is pretty neat and gets our first step to green.</p>

<p>Next up is the <code>When I generate the time sheet</code> step. The way I see it, generating the time sheet is the equivalent of visiting the <code>index</code> action of the time entry resource, since the time sheet is the collection of all the time entries. So the time sheet object is like a container for all the time entries and gives us a nice way to handle entries. Instead of going to <code class="inline">/time-entries</code>, in order to see the time sheet, I think the employee should go to <code>/time-sheet</code>. We should put that in our step definition:</p>

<div>
  <pre class="brush: php">/**
 * @When I generate the time sheet
 */
public function iGenerateTheTimeSheet()
{
$this-&gt;call('GET', '/time-sheet');

    $this-&gt;crawler = new Crawler($this-&gt;client-&gt;getResponse()-&gt;getContent(), url('/'));
}
</pre>
</div>

<p>This will cause a <code>NotFoundHttpException</code>, since the route is not defined yet. As I just explained, I think this URL should map to the <code>index</code> action on the time entry resource:</p>

<div>
  <pre class="brush: php">Route::get('time-sheet', ['as' =&gt; 'time_sheet', 'uses' =&gt; 'TimeEntriesController@index']);
</pre>
</div>

<p>In order to get to green, we need to generate the controller:</p>

<div>
  <pre class="brush: bash">$ php artisan controller:make TimeEntriesController
$ composer dump-autoload
</pre>
</div>

<p>And there we go.</p>

<p>Finally, we need to crawl the page to find the total duration of the time entries. I reckon we will have some sort of table that summarises the durations. The last two steps are so similar that we are just going to implement them at the same time:</p>

<div>
  <pre class="brush: php">/**
 * @Then my total time spent on :task should be :expectedDuration minutes
 */
public function myTotalTimeSpentOnTaskShouldBeMinutes($task, $expectedDuration)
{
$actualDuration = $this-&gt;crawler-&gt;filter('td#' . $task . 'TotalDuration')-&gt;text();

    PHPUnit::assertEquals($expectedDuration, $actualDuration);
}

/**
 * @Then my total time spent should be :expectedDuration minutes
 */
public function myTotalTimeSpentShouldBeMinutes($expectedDuration)
{
    $actualDuration = $this-&gt;crawler-&gt;filter('td#totalDuration')-&gt;text();

    PHPUnit::assertEquals($expectedDuration, $actualDuration);
}
</pre>
</div>

<p>The crawler is looking for a <code>&lt;td&gt;</code> node with an id of <code>[task_name]TotalDuration</code> or <code>totalDuration</code> in the last example.</p>

<p>Since we still do not have a view, the crawler will tell us that <code>The current node list is empty.</code></p>

<p>In order to fix this, let us build the <code>index</code> action. First, we fetch the collection of time entries. Second, we generate a time sheet from the entries and send it along to the (still non-existing) view.</p>

<div>
  <pre class="brush: php">use TimeTracker\TimeSheet;
use TimeTracker\TimeEntry;

class TimeEntriesController extends \BaseController {

/**
     * Display a listing of the resource.
     *
     * @return Response
     */
    public function index()
    {
        $entries = TimeEntry::all();
        $sheet = TimeSheet::generate($entries);

        return View::make('time_entries.index', compact('sheet'));
    }

...

</pre>
</div>

<p>The view, for now, is just going to consist of a simple table with the summarised duration values:</p>

<div>
  <pre class="brush: php">&lt;h2&gt;Time Sheet&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
        &lt;th&gt;Task&lt;/th&gt;
        &lt;th&gt;Total duration&lt;/th&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;coding&lt;/td&gt;
            &lt;td id="codingTotalDuration"&gt;{{ $sheet-&gt;totalTimeSpentOn('coding') }}&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;documenting&lt;/td&gt;
            &lt;td id="documentingTotalDuration"&gt;{{ $sheet-&gt;totalTimeSpentOn('documenting') }}&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;meetings&lt;/td&gt;
            &lt;td id="meetingsTotalDuration"&gt;{{ $sheet-&gt;totalTimeSpentOn('meetings') }}&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;&lt;strong&gt;Total&lt;/strong&gt;&lt;/td&gt;
            &lt;td id="totalDuration"&gt;{{ $sheet-&gt;totalTimeSpent() }}&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;
</pre>
</div>

<p>If you run Behat again, you will see that we successfully implemented the feature. Maybe we should take a moment to realise that not even once did we open up a browser! This is a massive improvement to our workflow, and as a nice bonus, we now have automated tests for our application. Yay!</p>

<h2><a name="user-content-conclusion" href="https://github.com/petersuhm/writings/blob/master/laravel-bdd-second-article.md#conclusion"/>Conclusion</h2>

<p>If you run <code>vendor/bin/behat</code> in order to run both Behat suites, you will see that both of them are green now. If you run PhpSpec though, unfortunately, you will see that our specs are broken. We get a fatal error <code>Class 'Eloquent' not found in ...</code>. This is because Eloquent is an alias. If you take a look in <code>app/config/app.php</code> under aliases, you will see that <code>Eloquent</code> is actually an alias for <code>Illuminate\Database\Eloquent\Model</code>. In order to get PhpSpec back to green, we need to import this class:</p>

<div>
  <pre class="brush: php">namespace TimeTracker;

use Illuminate\Database\Eloquent\Model as Eloquent;

class TimeEntry extends Eloquent
{
}
</pre>
</div>

<p>If you run these two commands:</p>

<div>
  <pre class="brush: bash">$ vendor/bin/phpspec run; vendor/bin/behat
</pre>
</div>

<p>You will see that we are back to green, both with Behat and PhpSpec. Yay! </p>

<p>We have now described and designed our first feature, completely using a BDD approach. We have seen how we can benefit from designing the core domain of our application, before we worry about the UI and the framework specific stuff. We have also seen how easy it is to interact with Laravel, and especially the database, in our Behat contexts. </p>

<p>In the next article, we are going to do a lot of refactoring in order to avoid too much logic on our Eloquent models, since these are more difficult to test in isolation and are tightly coupled to Laravel. Stay tuned!</p>