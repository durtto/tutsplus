<h1>Introduction to Generators & Koa.js: Part 2</h1>

<p>Welcome to the second part of our series on generators and Koa. If you missed it you can read <a href="http://goo.gl/mkO57l" target="_self">read part 1 here</a>. Before starting with the development process, make sure that you have installed Node.js 0.11.9 or higher.</p>

<p>In this part, we will be creating a dictionary API using Koa.js, and you'll learn about routing, compressing, logging, rate-limiting, and error handling in Koa.js. We will also use Mongo as our datastore and learn briefly about importing data into Mongo and the ease that comes with querying in Koa. Finally, we'll look into debugging Koa apps.</p>

<h2>Understanding Koa</h2>

<p>Koa has radical changes built under its hood which leverage the generator goodness of ES6. Apart from the change in the control flow, Koa introduces its own custom objects, such as <code class="inline">this</code>, <code class="inline">this.request</code>, and <code class="inline">this.response</code>, which conveniently act as a syntactic-sugar layer built on top of Node's req and res objects, giving you access to various convenience methods and getters/setters. </p>

<p>Apart from convenience, Koa also cleans up the middleware which, in Express, relied on ugly hacks which often modified core objects. It also provides better stream handling.</p>

<h2>Wait, What's a Middleware?</h2>

<p>A middleware is a pluggable function that adds or removes a particular piece of functionality by doing some work in the request/response objects in Node.js.</p>

<h3>Koa's Middleware</h3>

<p>A Koa middleware is essentially a generator function that returns one generator function and accepts another. Usually, an application has a series of middleware that are run for each request. </p>

<p>Also, a middleware must yield to the next 'downstream' middleware if it is run by an 'upstream middleware'. We will discuss more about this in the error handling section.</p>

<h3>Building Middleware</h3>

<p>Just one last thing: To add a middleware to your Koa application, we use the <code class="inline">koa.use()</code> method and supply the middleware function as the argument. Example: <code class="inline">app.use(koa-logger)</code> adds <code class="inline">koa-logger</code> to the list of middleware that our application uses.</p>

<h2>Building the Application</h2>

<p>To start with the dictionary API, we need a working set of definitions. To recreate this real-life scenario, we decided to go with a real dataset. We took the definition dump from Wikipedia and loaded it into Mongo. The set consisted of about 700,000 words as we imported only the English dump. Each record (or document) consists of a word, its type, and its meaning. You can read more about the importing process in the <code class="inline">import.txt</code> file in the repository.</p>

<p>To move along the development process, clone the repository and check your progress by switching to different commits. To clone the repo, use the following command:</p>

<pre class="brush: bash">$ git clone https://github.com/bhanuc/dictapi.git</pre>

<p>We can start by creating a base server Koa:</p>

<pre class="brush: javascript">var koa = require('koa');
var app = koa();

app.use(function *(next){
this.type = 'json';
    this.status = 200;
    this.body = {'Welcome': 'This is a level 2 Hello World Application!!'};
});

if (!module.parent) app.listen(3000);
console.log('Hello World is Running on http://localhost:3000/');

</pre>

<p>In the first line, we import Koa and save an instance in the app variable. Then we add a single middleware in line 5, which is an anonymous generator function that takes the next variable as a parameter. Here, we set the type and status code of the response, which is also automatically determined, but we can also set those manually. Then finally we set the body of the response. </p>

<p>Since we have set the body in our first middleware, this will mark the end of each request cycle and no other middleware will be involved. Lastly, we start the server by calling its <code class="inline">listen</code> method and pass on the port number as a parameter.</p>

<p>We can start the server by running the script via:</p>

<pre class="brush: bash">$ npm install koa
$ node --harmony index.js</pre>

<p>You can directly reach this stage by moving to commit <code class="inline">6858ae0</code>:</p>

<pre class="brush: bash">$ git checkout 6858ae0</pre>

<h3>Adding Routing Capabilities</h3>

<p>Routing allows us to redirect different requests to different functions on the basis of request type and URL. For example, we might want to respond to <code class="inline">/login</code> differently than <code class="inline">signup</code>. This can be done by adding a middleware, which manually checks the URL of the request received and runs corresponding functions. Or, instead of manually writing that middleware, we can use a community-made middleware, also known as a middleware module.</p>

<p>To add routing capability to our application, we will use a community module named <code class="inline">koa-router</code>. </p>

<p>To use <code class="inline">koa-router</code>, we will modify the existing code to the code shown below: </p>

<pre class="brush: javascript">var koa = require('koa');
var app = koa();
var router = require('koa-router');
var mount = require('koa-mount');

var handler = function *(next){
this.type = 'json';
    this.status = 200;
    this.body = {'Welcome': 'This is a level 2 Hello World Application!!'};
};

var APIv1 = new router();
APIv1.get('/all', handler);

app.use(mount('/v1', APIv1.middleware()));
if (!module.parent) app.listen(3000);
console.log('Hello World is Running on http://localhost:3000/');

</pre>

<p>Here we have imported two modules, where <code class="inline">router</code> stores <code class="inline">koa-router</code> and <code class="inline">mount</code> stores the <code class="inline">koa-mount</code> module, allowing us to use the router in our Koa application.</p>

<p>On line 6, we have defined our <code class="inline">handler</code> function, which is the same function as before but here we have given it a name. On line 12, we save an instance of the router in <code class="inline">APIv1</code>, and on line 13 we register our handler for all the <code class="inline">GET</code> requests on route <code class="inline">/all</code>. </p>

<p>So all the requests except when a get request is sent to <code class="inline">localhost:3000/all</code> will return "not found". Finally on line 15 , we use <code class="inline">mount</code> middleware, which gives a usable generator function that can be fed to <code class="inline">app.use()</code>.</p>

<p>To directly reach this step or compare your application, execute the following command in the cloned repo:</p>

<pre class="brush: bash">$ git checkout 8f0d4e8</pre>

<p>Before we run our application, now we need to install <code class="inline">koa-router</code> and <code class="inline">koa-mount</code> using <code class="inline">npm</code>. We observe that as the complexity of our application increases, the number of modules/dependencies also increases. </p>

<p>To keep track of all the information regarding the project and make that data available to <code class="inline">npm</code>, we store all the information in <code class="inline">package.json</code> including all the dependencies. You can create package.json manually or by using an interactive command line interface which is opened using the <code class="inline">$ npm init </code><i> </i>command.</p>

<pre class="brush: javascript">{
"name": "koa-api-dictionary",
    "version": "0.0.1",
    "description": "koa-api-dictionary application",
    "main": "index",
    "author": {
    "name": "Bhanu Pratap Chaudhary",
    "email": "bhanu423@gmail.com"
    },
    "repository": {
    "type": "git",
    "url": "https://github.com/bhanuc/dictapi.git"
    },
    "license": "MIT",
    "engines": {
    "node": "&gt;= 0.11.13"
    }
}

</pre>

<p>A very minimal <code class="inline">package.json</code> file looks like the one above. </p>

<p>Once <code class="inline">package.json</code> is present, you can save the dependency using the following command:</p>

<pre class="brush: bash">$ npm install &lt;package-name&gt; --save</pre>

<p>For example: In this case, we will install the modules using the following command to save the dependencies in <code class="inline">package.json</code>.</p>

<pre class="brush: bash">$ npm install koa-router koa-mount --save</pre>

<p>Now you can run the application using <code class="inline">$ node --harmony index.js</code>. </p>

<p>You can read more about <code class="inline">package.json</code> <a href="https://www.npmjs.org/doc/files/package.json.html" target="_self">here</a>.</p>

<h3> Adding Routes for the Dictionary API</h3>

<p>We will start by creating two routes for the API, one for getting a single result in a faster query, and a second to get all the matching words (which is slower for the first time). </p>

<p>To keep things manageable, we will keep all the API functions in a separate folder called <code class="inline">api</code> and a file called <code class="inline">api.js</code>, and import it later in our main <code class="inline">index.js</code> file.</p>

<pre class="brush: javascript">var monk = require('monk');
var wrap = require('co-monk');
var db = monk('localhost/mydb');
var words = wrap(db.get('words'));
/**
* GET all the results.
*/
exports.all = function *(){
if(this.request.query.word){
        var res = yield words.find({ word : this.request.query.word });
        this.body = res;
    } else {
        this.response.status = 404;
        }
    };
/**
* GET a single result.
*/
exports.single = function *(){
    if(this.request.query.word){
        var res = yield words.findOne({ word : this.request.query.word });
        this.body = res;
    } else {
        this.response.status = 404;
    }
};</pre>

<p>Here we are using <code class="inline">co-monk</code>, which acts a wrapper around <code class="inline">monk</code>, making it very easy for us to query MongoDB using generators in Koa. Here, we import <code class="inline">monk</code> and <code class="inline">co-monk</code>, and connect to the MongoDB instance on line 3. We call <code class="inline">wrap()</code> on collections, to make them generator-friendly. </p>

<p>Then we add two generator methods named <code class="inline">all</code> and <code class="inline">single</code> as a property of the <code class="inline">exports</code> variable so that they can be imported in other files. In each of the functions, first we check for the query parameter 'word.' If present, we query for the result or else we reply with a 404 error. </p>

<p>We use the <code class="inline">yield</code> keyword to wait for the results as discussed in the first article, which pauses the execution until the result is received. On line 12, we use the <code class="inline">find</code> method, which returns all the matching words, which is stored in res and subsequently sent back. On line 23, we use the <code class="inline">findOne</code> method available on the collection, which returns the first matching result. </p>

<h3>Assigning These Handlers to Routes</h3>

<pre class="brush: javascript">var koa = require('koa');
var app = koa();
var router = require('koa-router');
var mount = require('koa-mount');
var api = require('./api/api.js');

var APIv1 = new router();
APIv1.get('/all', api.all);
APIv1.get('/single', api.single);


app.use(mount('/v1', APIv1.middleware()));
if (!module.parent) app.listen(3000);
console.log('Dictapi is Running on http://localhost:3000/');</pre>

<p>Here we import exported methods from <code class="inline">api.js</code> and we assign handlers to <code class="inline">GET</code> routes <code class="inline">/all</code>  <code class="inline">/single</code> and we have a fully functional API and application ready.</p>

<p>To run the application, you just need to install the <code class="inline">monk</code> and <code class="inline">co-monk</code> modules using the command below. Also, ensure you have a running instance of MongoDB in which you have imported the collection present in the git repository using the instructions mentioned in <code class="inline">import.txtweird</code>.</p>

<pre class="brush: bash">$ npm install monk co-monk --save</pre>

<p>Now you can run the application using the following command:</p>

<pre class="brush: bash">$ node --harmony index.js</pre>

<p>You can open the browser and open the following URLs to check the functioning of the application. Just replace 'new' with the word you want to query.</p>

<ul>
  <li><code class="inline">http://localhost:3000/v1/all?word=new</code></li>
  <li><code class="inline">http://localhost:3000/v1/single?word=new</code></li>
</ul>

<p>To directly reach this step or compare your application, execute the following command in the cloned repo:</p>

<pre class="brush: bash">$ git checkout f1076eb  </pre>

<h3>Error Handling in Koa</h3>

<p>By using cascading middlewares, we can catch errors using the <code class="inline">try/catch</code> mechanism, as each middleware can respond while yielding to downstream as well as upstream. So, if we add a <i>Try and Catch</i> middleware in the beginning of the application, it will catch all the errors encountered by the request in the rest of the middleware as it will be the last middleware during upstreaming. Adding the following code on line 10 or before in <code class="inline">index.js</code> should work.</p>

<pre class="brush: javascript">app.use(function *(next){
try{
yield next; //pass on the execution to downstream middlewares
} catch (err) { //executed only when an error occurs &amp; no other middleware responds to the request
this.type = 'json'; //optional here
this.status = err.status || 500;
this.body = { 'error' : 'The application just went bonkers, hopefully NSA has all the logs ;) '};
//delegate the error back to application
this.app.emit('error', err, this);
    }
});</pre>

<h3>Adding Logging and Rate-Limiting to the Application</h3>

<p>Storing logs is an essential part of a modern-day application, as logs are very helpful in debugging and finding out issues in an application. They also store all the activities and thus can be used to find out user activity patterns and interesting other patterns. </p>

<p>Rate-limiting has also become an essential part of modern-day applications, where it is important to stop spammers and bots from wasting your precious server resources and to stop them from scraping your API.</p>

<p>It is fairly easy to add logging and rate-limiting to our Koa application. We will use two community modules: <code class="inline">koa-logger</code> and <code class="inline">koa-better-rate-limiting</code>. We need to add the following code to our application:</p>

<pre class="brush: plain">var logger = require('koa-logger');
var limit = require('koa-better-ratelimit');
//Add the lines below just under error middleware.
app.use(limit({ duration: 1000*60*3 , // 3 min
            max: 10, blacklist: []}));
app.use(logger());</pre>

<p>Here we have imported two modules and added them as middleware. The logger will log each request and print in the <code class="inline">stdout</code> of the process which can be easily saved in a file. And limit middleware limits the number of requests a given user can request in a given timeframe (here it is maximum ten requests in three minutes). Also you can add a array of IP addresses which will be blacklisted and their request will not be processed.</p>

<p>Do remember to install the modules before using the code using: </p>

<pre class="brush: bash">$ npm install koa-logger koa-better-ratelimit --save</pre>

<h3>Compressing the Traffic</h3>

<p>One of the ways to ensure faster delivery is to gzip your response, which is fairly simple in Koa. To compress your traffic in Koa, you can use the <code class="inline">koa-compress</code> module. </p>

<p>Here, options can be an empty object or can be configured as per the requirement.</p>

<pre class="brush: javascript">var compress = require('koa-compress');
var opts =  { 
filter: function (content_type) { return /text/i.test(content_type) }, // filter requests to be compressed using regex 
    threshold: 2048, //minimum size to compress
    flush: require('zlib').Z_SYNC_FLUSH };
            }
//use the code below to add the middleware to the application
app.use(compress(opts));
</pre>

<p>You can even turn off compression in a request by adding the following code to a middleware:</p>

<pre class="brush: javascript">this.compress = true;</pre>

<p>Don't forget to install compress using <code class="inline">npm</code>. </p>

<pre class="brush: bash">$ npm install compress --save </pre>

<p>To directly reach this step or compare your application, execute the following command in the cloned repo:</p>

<pre class="brush: javascript">git checkout 8f5b5a6 </pre>

<h3>Writing Tests</h3>

<p>Test should be an essential part of all code, and one should target for maximum test coverage. In this article, we will be writing tests for the routes that are accessible from our application. We will be using supertest and Mocha to create our tests. </p>

<p>We will be storing our test in <code class="inline">test.js</code> in the <code class="inline">api</code> folder. In both tests, we first describe our test, giving it a more human readable name. After that, we will pass an anonymous function which describes the correct behavior of the test, and takes a callback which contains the actual test. In each test, we import our application, initiate the server, describe the request type, URL and query, and then set encoding to gzip.  Finally we check for the response if it's correct.</p>

<pre class="brush: javascript">var request = require('supertest');
var api = require('../index.js');

describe('GET all', function(){
  it('should respond with all the words', function(done){
var app = api;
    request(app.listen())
    .get('/v1/all')
    .query({ word: 'new' })
    .set('Accept-Encoding', 'gzip')    
    .expect('Content-Type', /json/)
    .expect(200)
    .end(done);
  })
})

describe('GET /v1/single', function(){
  it('should respond with a single result', function(done){
    var app = api;

    request(app.listen())
    .get('/v1/single')
    .query({ word: 'new' })
    .set('Accept-Encoding', 'gzip')
    .expect(200)
    .expect('Content-Type', /json/)
    .end(function(err, res){
    if (err) throw err;
    else {
        if (!('_id' in res.body)) return "missing id";
        if (!('word' in res.body)) throw new Error("missing word");
        done();
    }
  });
  })
})</pre>

<p>To run our test, we will make a <code class="inline">Makefile</code>:</p>

<pre class="brush: plain">test:
@NODE_ENV=test ./node_modules/.bin/mocha \
		--require should \
		--reporter nyan \
		--harmony \
		--bail \
		api/test.js

.PHONY: test</pre>

<p>Here, we've configured the reporter (nyan cat) and the testing framework (mocha). Note that the import should add <code class="inline">--harmony</code> to enable ES6 mode. Finally, we also specify the location of all the tests. A <code class="inline">Makefile</code> can be configured for endless testing of your application.</p>

<p>Now to test your app, just use the following command in the main directory of the application. </p>

<pre class="brush: bash">$ make test</pre>

<p>Just remember to install testing modules (mocha, should, supertest) before testing, using the command below: </p>

<pre class="brush: bash">$ npm install mocha should mocha --save-dev </pre>

<h3>Running in Production</h3>

<p>To run our applications in production, we will use PM2, which is an useful Node process monitor. We should disable the logger app while in production; it can be automated using environment variables.</p>

<p>To install PM2, enter the following command in terminal</p>

<pre class="brush: bash">$ npm install pm2 -g </pre>

<p>And our app can be launched using the following command:</p>

<pre class="brush: html">$ pm2 start index.js --node-args="--harmony" </pre>

<p>Now, even if our application crashes, it will restart automatically and you can sleep soundly. </p>

<h3>Conclusion</h3>

<p>Koa is a light and expressive middleware for Node.js that makes the process of writing web applications and APIs more enjoyable. </p>

<p>It allows you to leverage a multitude of community modules to extend the functionality of your application and simplify all the mundane tasks, making web development a fun activity. </p>

<p>Please don't hesitate to leave any comments, questions, or other information in the field below.</p>