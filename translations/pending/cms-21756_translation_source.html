<h1>Introdução a Geradores & Koa.js: Parte 2</h1>

<p>Bem-vindo à segunda parte da nossa série sobre geradores e Koa. Se você perdeu a primeira parte, <a href="http://goo.gl/mkO57l" target="_self">pode lê-la aqui</a>. Antes de começarmos com o processo de desenvolvimento, tenha certeza de ter instalado a versão 0.11.9, ou mais recente, do Node.js.</p>

<p>Nesta parte, começaremos a criar nossa API usando o Koa.js e você aprenderá sobre roteamento, compressão, registros de log, limitação de uso e manipulação de erros no Koa.js. Também usaremos o Mongo como nosso armazenamento de dados e aprenderemos rapidamente sobre a importação de dados para o Mongo, e o quão fácil é selecionar dados usando o Koa. Finalmente, veremos como depurar apps no Koa.</p>

<h2>Entendendo o Koa</h2>

<p>Koa tem mudanças substanciais por trás dos panos, fazendo uso das maravilhas dos geradores do EcmaScript 6. Fora a mudança de fluxo de controle, o Koa introduz seus próprios objetos customizados, como o <code class="inline">this</code>, <code class="inline">this.request</code> e o<code class="inline">this.response</code>, que funcionam como uma camada de açúcar sintático sobre os objetos <code class="inline">req</code> e <code class="inline">res</code> do Node, dando-lhe acesso a vários métodos convenientes e vários <code class="inline">getters/setters</code>. </p>

<p>Além das conveniências, o Koa também faz uma limpeza nos mediadores que, no Express, dependia de <em>hacks</em> horrorosos que quase sempre modificavam os objetos base. Também fornece uma melhor manipulação de fluxo de dados.</p>

<h2>Espere, O Que É Um Mediador?</h2>

<p>Um mediador é uma função plugável que adiciona ou remover alguma funcionalidade específica ao realizar alguma tarefa nos objetos de requisição/resposta do Node.js.</p>

<h3>Mediadores do Koa</h3>

<p>Essencialmente, um mediador do Koa é uma função geradora que retorna uma função geradora e que aceita uma outra função geradora. Geralmente, uma aplicação possui uma série de mediadores que são executados a cada requisição. </p>

<p>Além disso, um mediador deve retornar para o próximo mediador abaixo no fluxo de controle, caso seja executado por um mediador mais alto. Discutiremos mais sobre isso na seção de manipulação de erros.</p>

<h3>Construindo Mediadores</h3>

<p>Uma última coisa: Para adicionar um mediador à sua aplicação Koa, usaremos o método <code class="inline">koa.use()</code> e prover uma função mediadora (geradora) como argumento. Exemplo: <code class="inline">app.use(koa-logger)</code> adiciona o <code class="inline">koa-logger</code> à lista de mediadores que nossa aplicação usa.</p>

<h2>Construindo a Aplicação</h2>

<p>Para começar com a API do dicionário, precisamos de conjunto funcional de definições. Para recriar esse cenário da vida real, decidimos ir com um conjunto de dados real. Baixamos a lista de definições da Wikipedia e carregamos no Mongo. O conjunto tem cerca de 700.000 palavras, uma vez que importamos somente a lista de definições em inglês. Cada registro (ou documento) consiste de uma palavra, seu tipo e seu significado. Você pode ler mais sobre o processo de importação no arquivo <code class="inline">import.txt</code> do repositório.</p>

<p>Continuando com o processo de desenvolvimento, clone o repositório e verifique seu progresso, navegando pelos diferentes <em>commits</em>. Para clonar o repositório, use o comando a seguir:</p>

<pre class="brush: bash">$ git clone https://github.com/bhanuc/dictapi.git</pre>

<p>Comecemos criando um servidor base do Koa:</p>

<pre class="brush: javascript">var koa = require('koa');
var app = koa();

app.use(function *(next){
this.type = 'json';
    this.status = 200;
    this.body = {'Welcome': 'Essa é uma aplicação Olá Mundo de nível 2!!'};
});

if (!module.parent) app.listen(3000);
console.log('Olá Mundo executando em http://localhost:3000/');

</pre>

<p>Na primeira linha, importamos o Koa e salvamos uma instância na variável <code class="inline">app</code>. Então, adicionamos um único mediador na linha 5, que é uma função geradora anônima que recebe a variável <code class="inline">next</code> como parâmetro. Aqui, atribuímos o tipo e o estado da resposta, que é determinado automaticamente, mas também podemos configurá-lo manualmente. Finalmente, configuramos o corpo da resposta. </p>

<p>Já que configuramos o corpo de nosso primeiro mediador, ele marcará o fim de cada ciclo de requisição e não envolveremos qualquer outro mediador. Por último, iniciamos o servidor, executando seu método <code class="inline">listen</code> e passando um número de porta como parâmetro.</p>

<p>Podemos iniciar o servidor através da execução do <em>script</em>, dessa forma:</p>

<pre class="brush: bash">$ npm install koa
$ node --harmony index.js</pre>

<p>Você pode ir direto para esse ponto, buscando o <em>commit</em> <code class="inline">6858ae0</code>:</p>

<pre class="brush: bash">$ git checkout 6858ae0</pre>

<h3>Adicionando Capacidade de Roteamento</h3>

<p>Roteamento permite-nos redirecionar diferentes requisições a diferentes funções, baseado no tipo da requisição e na URL requisitada. Por exemplo, podemos querer responder a <code class="inline">/login</code> diferentemente de <code class="inline">signup</code>. Isso pode ser feito a partir da adição de um mediador, que verifica manualmente a URL da requisição recebida e executa as funções correspondentes. Ou, ao invés de escrever o mediador manualmente, podemos usar um mediador criado pela comunidade, também conhecido como módulo mediador.</p>

<p>Para adicionar a capacidade de roteamento à nossa aplicação, usaremos um módulo da comunidade chamado de <code class="inline">koa-router</code>. </p>

<p>Para usar o <code class="inline">koa-router</code>, modificaremos o código que já temos para algo parecido com isso: </p>

<pre class="brush: javascript">var koa = require('koa');
var app = koa();
var router = require('koa-router');
var mount = require('koa-mount');

var handler = function *(next){
this.type = 'json';
    this.status = 200;
    this.body = {'Welcome': 'Essa é uma aplicação Olá Mundo de nível 2!!'};
};

var APIv1 = new router();
APIv1.get('/all', handler);

app.use(mount('/v1', APIv1.middleware()));
if (!module.parent) app.listen(3000);
console.log('Olá Mundo executando em http://localhost:3000/');

</pre>

<p>Nós importamos dois módulos aqui, onde a variável <code class="inline">router</code> guarda o <code class="inline">koa-router</code> e a variável <code class="inline">mount</code> guarda o módulo <code class="inline">koa-mount</code>, permitindo-nos usar o roteador em nossa aplicação Koa.</p>

<p>Na linha 6, definimos nossa função <code class="inline">handler</code>, que é a mesma função de antes mas, dessa vez, demos um nome a ela. Na linha 12, guardamos uma instância do roteador em <code class="inline">APIv1</code> e na linha 13 registrarmos nosso manipulador para requisições <code class="inline">GET</code> na rota <code class="inline">/all</code>. </p>

<p>Assim, todas as requisições retornarão "<em>not found</em>", exceto aquelas que foram feitas para <code class="inline">localhost:3000/all</code>. Finalmente, na linha 15, usamos o mediador <code class="inline">mount</code>, que nos fornece uma função gerador que pode ser passada para <code class="inline">app.use()</code>.</p>

<p>Para ver esse passo em específico ou comparar sua aplicação, execute o seguinte comando no repositório clonado:</p>

<pre class="brush: bash">$ git checkout 8f0d4e8</pre>

<p>Antes de executarmos nossa aplicação, precisamos instalar o <code class="inline">koa-router</code> e o <code class="inline">koa-mount</code> usando o <code class="inline">npm</code>. De acordo com o aumento da complexidade da aplicação, o número de módulos/dependências também aumenta. </p>

<p>Para manter o controle de todas as informações relacionadas ao projeto e disponibilizar esses dados no <code class="inline">npm</code>, guardamos toda a informação em um arquivo <code class="inline">package.json</code>, incluindo todas as dependências. Você pode criar um arquivo <code class="inline">package.json</code> manualmente ou usar a interface interativa de linha de comando, que abrimos com o comando <code class="inline">$ npm init </code>.</p>

<pre class="brush: javascript">{
"name": "koa-api-dictionary",
    "version": "0.0.1",
    "description": "koa-api-dictionary application",
    "main": "index",
    "author": {
    "name": "Bhanu Pratap Chaudhary",
    "email": "bhanu423@gmail.com"
    },
    "repository": {
    "type": "git",
    "url": "https://github.com/bhanuc/dictapi.git"
    },
    "license": "MIT",
    "engines": {
    "node": "&gt;= 0.11.13"
    }
}

</pre>

<p>Um arquivo <code class="inline">package.json</code> bem simples deve ser parecido com o que temos acima. </p>

<p>Uma vez que o arquivo <code class="inline">package.json</code> esteja presente, você pode salvar a dependência usando o comando a seguir:</p>

<pre class="brush: bash">$ npm install &lt;package-name&gt; --save</pre>

<p>Por exemplo: Nesse caso, instalaremos os módulos usando o comando abaixo e  registraremos as dependências no arquivo <code class="inline">package.json</code>.</p>

<pre class="brush: bash">$ npm install koa-router koa-mount --save</pre>

<p>Agora, você pode executar sua aplicação, usando <code class="inline">$ node --harmony index.js</code>. </p>

<p>Você pode ler mais sobre o arquivo <code class="inline">package.json</code> <a href="https://www.npmjs.org/doc/files/package.json.html" target="_self">aqui</a>.</p>

<h3>Adicionando Rotas para a API do Dicionário</h3>

<p>Começaremos criando duas rotas para a API, uma para obter todos os resultados em uma consulta rápida e uma segunda para obter todas as palavras combinantes (que é bem mais devagar na primeira vez). </p>

<p>Para manter controle sobre as coisas, colocaremos as funções da API em um diretório à parte, chamado de <code class="inline">api</code> e em um arquivo <code class="inline">api.js</code>, e importaremos esse último em nosso arquivo <code class="inline">index.js</code> posteriormente.</p>

<pre class="brush: javascript">var monk = require('monk');
var wrap = require('co-monk');
var db = monk('localhost/mydb');
var words = wrap(db.get('words'));
/**
* GET - todos os resultados.
*/
exports.all = function *(){
if(this.request.query.word){
        var res = yield words.find({ word : this.request.query.word });
        this.body = res;
    } else {
        this.response.status = 404;
        }
    };
/**
* GET - um único resultado.
*/
exports.single = function *(){
    if(this.request.query.word){
        var res = yield words.findOne({ word : this.request.query.word });
        this.body = res;
    } else {
        this.response.status = 404;
    }
};</pre>

<p>Aqui, usaremos o <code class="inline">co-monk</code>, que age como um invólucro para o <code class="inline">monk</code>, facilitando bastante o nosso trabalho de consultar o MongoDB usando geradores no Koa. Aqui, nós importamos o <code class="inline">monk</code> e <code class="inline">co-monk</code>, e conectamos à instância do MongoDB na linha 3. Invocamos o método <code class="inline">wrap()</code> nas coleções, para torná-lo amigável a geradores. </p>

<p>Logo depois adicionamos dois métodos geradores, chamados <code class="inline">all</code> e <code class="inline">single</code>, como propriedades da variável <code class="inline">exports</code>, de modo que eles possam ser importados por outros arquivos. Em cada uma dessas funções, primeiro verificamos o parâmetro da consulta, <code class="inline">word</code>. Se ele estiver presente, realizamos a consulta e a retornamos. Caso contrário, lançamos um erro 404. </p>

<p>Usamos a palavra-chave <code class="inline">yield</code> para esperar pelos resultados, assim como foi discutido no primeiro artigo, pausando a execução daquela função até que o resultado seja recebido. Na linha 12, usamos o método <code class="inline">find</code>, que retorna todas as palavras combinantes, que são salvar em <code class="inline">res</code> e, subsequentemente, enviadas de volta. Na linha 23, usamos o método <code class="inline">findOne</code> disponível na coleção, que retorna o primeiro resultado combinante. </p>

<h3>Atribuindo Os Manipuladores às Rotas</h3>

<pre class="brush: javascript">var koa = require('koa');
var app = koa();
var router = require('koa-router');
var mount = require('koa-mount');
var api = require('./api/api.js');

var APIv1 = new router();
APIv1.get('/all', api.all);
APIv1.get('/single', api.single);


app.use(mount('/v1', APIv1.middleware()));
if (!module.parent) app.listen(3000);
console.log('Dictapi Executando em http://localhost:3000/');</pre>

<p>Aqui importamos os métodos exportados do arquivo <code class="inline">api.js</code> e atribuímos os manipuladores às respectivas rotas <code class="inline">GET</code>, <code class="inline">/all</code> e <code class="inline">/single</code>, e temos uma API completamente funcional e aplicação pronta, agora.</p>

<p>Para executar a aplicação, você só precisa instalar os módulos <code class="inline">monk</code> e <code class="inline">co-monk</code> usando o comando abaixo. Além disso, garanta a existência de uma instância do MongoDB executando, a qual você importou os dados, de acordo com as instruções mencionadas no arquivo <code class="inline">import.txt</code>, presente no repositório do GitHub.</p>

<pre class="brush: bash">$ npm install monk co-monk --save</pre>

<p>Agora, execute a aplicação usando o comando a seguir:</p>

<pre class="brush: bash">$ node --harmony index.js</pre>

<p>Você pode abrir o navegador e abrir as seguintes URLS para verificar o funcionamento da aplicação. Apenas substitua a palavra 'new' por uma outra palavra que queira consultar.</p>

<ul>
  <li><code class="inline">http://localhost:3000/v1/all?word=new</code></li>
  <li><code class="inline">http://localhost:3000/v1/single?word=new</code></li>
</ul>

<p>Para chegar a esse passo rapidamente, execute o comando a seguir no diretório do repositório clonado:</p>

<pre class="brush: bash">$ git checkout f1076eb  </pre>

<h3>Manipulação de Erros no Koa</h3>

<p>Ao usar mediadores em cascata, podemos capturar erros usando o mecanismo <code class="inline">try/catch</code>, uma vez que cada mediador pode responder enquanto repassa para os geradores abaixo e acima. Assim, se adicionarmos um mediador <i>Try and Catch</i> no começo da aplicação, ele capturará todos os erros encontrados pela requisição durante a passagem por todos os outros mediadores, uma vez que ele será o último mediador na volta dos geradores. Para tanto, basta adicionar o código a seguir na linha 10 do arquivo <code class="inline">index.js</code> ou antes.</p>

<pre class="brush: javascript">app.use(function *(next){
try{
yield next; // passa a execução para o próximo mediador da fila
} catch (err) { //só executando quando ocorre erros &amp; e nenhum outro mediador responde à requisição
this.type = 'json'; //declaração opcional
this.status = err.status || 500;
this.body = { 'error' : 'A aplicação ficou louca. Torçamos que a NSA tenha todos os logs ;) '};
//delega o erro de volta para a aplicação
this.app.emit('error', err, this);
    }
});</pre>

<h3>Adicionando Registro de Log e Limitação de Uso na Aplicação</h3>

<p>Registrar logs é uma parte essencial de uma aplicação moderna, uma vez que são bastante úteis na depuração e descoberta de problemas em nossas aplicações. Eles também guardam todas as atividades realizada e, dessa forma, podem ser usados para descobrir padrões de atividade de usuários e outros padrões interessantes. </p>

<p>Limitação de uso também se tornou uma parte essencial de aplicações modernos, onde é importante parar <em>spammers</em> e <em>bots</em> de drenarem recursos preciosos do servidor e pará-los de consumir sua API.</p>

<p>É bem simples de adicionar registro de logs e limitação de uso em uma aplicação Koa. Usaremos dois módulos da comunidade: <code class="inline">koa-logger</code> e<code class="inline">koa-better-rate-limiting</code>. Precisamos adicionar o código a seguir à nossa aplicação:</p>

<pre class="brush: plain">var logger = require('koa-logger');
var limit = require('koa-better-ratelimit');
//e as linhas abaixo um pouco antes do mediador de erros
app.use(limit({ duration: 1000*60*3 , // 3 minutos
            max: 10, blacklist: []}));
app.use(logger());</pre>

<p>Nessa parte, importamos os dois módulos e os adicionamos como mediador. O registrador de logs salvará e imprimirá na <code class="inline">stdout</code> do processo que pode ser salva, facilmente em um arquivo. E o limitador de uso limita o número de requisições que um dado usuário pode fazer em um determinado período de tempo (o máximo de requisições aqui é de 10 em 3 minutos). Você também pode adicionar um vetor de endereços IP que pode ser bloqueadas e suas requisições não serão processadas.</p>

<p>Lembre-se de instalar os móduos antes de usá-los, usando o comando abaixo: </p>

<pre class="brush: bash">$ npm install koa-logger koa-better-ratelimit --save</pre>

<h3>Comprimindo o Tráfego</h3>

<p>Uma das maneiras de garantir uma entrega rápida é usar <code class="inline">gzip</code> em sua resposta, que é bem simples no Koa. Para comprimir o tráfego no koa, você pode usar o módulo <code class="inline">koa-compress</code>. </p>

<p>Nesse caso, as opções podem ser um objeto vazio ou podem ser configurados de acordo com a necessidade.</p>

<pre class="brush: javascript">var compress = require('koa-compress');
var opts =  {
filter: function (content_type) { return /text/i.test(content_type) }, // filtra as requisições a serem comprimidas usando regex
    threshold: 2048, //minimum size to compress
    flush: require('zlib').Z_SYNC_FLUSH };
            }
//use the code below to add the middleware to the application
app.use(compress(opts));
</pre>

<p>Você pode até desligar a compressão em uma requisição adicionando o trecho de código a seguir ao mediador:</p>

<pre class="brush: javascript">this.compress = true;</pre>

<p>Não esqueça de instalar o módulo <code>compress</code> através do <code class="inline">npm</code>. </p>

<pre class="brush: bash">$ npm install compress --save </pre>

<p>Para chegar a esse estágio e comparar à sua aplicação, execute o comando a seguir no diretório do repositório clonado:</p>

<pre class="brush: javascript">git checkout 8f5b5a6 </pre>

<h3>Escrevendo Testes</h3>

<p>Testes devem ser uma parte essencial de qualquer código e devem objetivar o máximo de cobertura do código que for possível. Nesse artigo, criaremos os testes paras as rotas que são acessíveis em nossa aplicação. Usaremos o <em>supertest</em> e o <em>Mocha</em> para criar nossos testes. </p>

<p>Salvaremos nossos testes no arquivo <code class="inline">test.js</code> que ficará dentro da pasta <code class="inline">api</code>. Em ambos os casos, primeiro descreveremos nosso teste, dando-lhe um nome mais legível por humanos. Logo depois, passaremos uma função anônima que descreverá o comportamento correto do teste e levará uma função <em>callback</em> que conterá o teste de verdade. Em cada teste, importaremos nossa aplicação, iniciaremos o servidor, descreveremos o tipo de requisição, URL e consulta, e então passaremos a codificação para o gzip. Finalmente, verificaremos se a resposta está correta.</p>

<pre class="brush: javascript">var request = require('supertest');
var api = require('../index.js');

describe('GET all', function(){
  it('deveshould respond with all the words', function(done){
var app = api;
    request(app.listen())
    .get('/v1/all')
    .query({ word: 'new' })
    .set('Accept-Encoding', 'gzip')
    .expect('Content-Type', /json/)
    .expect(200)
    .end(done);
  })
})

describe('GET /v1/single', function(){
  it('should respond with a single result', function(done){
    var app = api;

    request(app.listen())
    .get('/v1/single')
    .query({ word: 'new' })
    .set('Accept-Encoding', 'gzip')
    .expect(200)
    .expect('Content-Type', /json/)
    .end(function(err, res){
    if (err) throw err;
    else {
        if (!('_id' in res.body)) return "id faltando";
        if (!('word' in res.body)) throw new Error("palavra faltando");
        done();
    }
  });
  })
})</pre>

<p>Para executar nosso teste, criaremos um arquivo <code class="inline">Makefile</code>:</p>

<pre class="brush: plain">test:
@NODE_ENV=test ./node_modules/.bin/mocha \
		--require should \
		--reporter nyan \
		--harmony \
		--bail \
		api/test.js

.PHONY: test</pre>

<p>Nós configuramos o relator (nyan cat) e o <em>framework</em> de testes (mocha). Perceba que a importação deve adicionar o semáforo <code class="inline">--harmony</code> para habilitar o modo ES6. Finalmente, também especificamos o local onde estão os testes. Um arquivo <code class="inline">Makefile</code> configurado para testes infinitos da sua aplicação.</p>

<p>Agora, para testar sua aplicação, apenas execute o comando a seguir, no diretório principal da sua aplicação. </p>

<pre class="brush: bash">$ make test</pre>

<p>Lembre-se de instalar os módulos de teste (mocha, should, supertest) antes de executar os testes, usando o comando abaixo: </p>

<pre class="brush: bash">$ npm install mocha should mocha --save-dev </pre>

<h3>Executando em Modo Produção</h3>

<p>Para executar nossa aplicação em produção, usaremos o PM2, que é um monitor de processo para Node, muito útil. Nós devemos desabilitar o registrador de logs na produção. Isso pode ser automatizado através de variáveis de ambiente.</p>

<p>Para instalar o PM2, digite o comando a seguir no terminal</p>

<pre class="brush: bash">$ npm install pm2 -g </pre>

<p>E nosso aplicativo pode ser iniciado, usando o comando a seguir:</p>

<pre class="brush: html">$ pm2 start index.js --node-args="--harmony" </pre>

<p>Agora, mesmo que nossa aplicação dê problemas, ela reiniciará automaticamente e você pode dormir sem problemas. </p>

<h3>Conclusão</h3>

<p>O Koa é um mediador leve e expressivo para o Node.js que torna o processo de criação de aplicações web e de APIs muito mais agradáveis. </p>

<p>Ele permite você lançar mão de uma enorme gama de módulos da comunidade para estender a funcionalidade de sua aplicação e simplificar as tarefas padrões, tornando o desenvolvimento para web uma atividade divertida. </p>

<p>Por favor, não hesite em deixar comentários, perguntas ou quaisquer outras informações logo abaixo.</p>