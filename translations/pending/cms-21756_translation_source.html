<h1>Introdução a Geradores & Koa.js: Parte 2</h1>

<p>Bem vindo à segunda parte da nossa série sobre geradores e Koa. Se você perdeu a primeira parte, <a href="http://goo.gl/mkO57l" target="_self">pode lê-la aqui</a>. Antes de começarmos com o processo de desenvolvimento, tenha certeza de ter isntalado a versão 0.11.9, ou mais recente, do Node.js.</p>

<p>Nesta parte, começaremos a criar nossa API usando o Koa.js e você aprenderá sobre roteamento, compressão, registros de log, limitação de uso e manipulação de erros no Koa.js. Também usaremos o Mongo como nosso armazenamento de dados e aprenderemos rapidamente sobre a importação de dados para o Mongo, e o quão fácil é selecionar dados usando o Koa. Finalmente, veremos como depurar apps no Koa.</p>

<h2>Entendendo o Koa</h2>

<p>Koa tem mudanças substanciais por trás dos panos, fazendo uso das maravilhas dos geradores do EcmaScript 6. Fora a mudança de fluxo de controle, o Koa introduz seus próprios objetos customizados, como o <code class="inline">this</code>, <code class="inline">this.request</code> e o<code class="inline">this.response</code>, que funcionam como uma camada de açucar sintático sobre os objetos <code class="inline">req</code> e <code class="inline">res</code> do Node, dando-lhe acesso a vários métodos convenientes e vários <code class="inline">getters/setters</code>. </p>

<p>Além das conveniências, o Koa também faz uma limpeza nos mediadores que, no Express, dependia de <em>hacks</em> horrorosos que quase sempre modificavam os objetos base. Também fornece uma melhor manipulação de fluxo de dados.</p>

<h2>Espere, O Que É Um Mediador?</h2>

<p>Um mediador é uma função plugável que adiciona ou remover alguma funcionalidade específica ao realizar alguma tarefa nos objetos de requisição/resposta do Node.js.</p>

<h3>Mediadores do Koa</h3>

<p>Essencialmente, um mediador do Koa é uma função geradora que retorna uma função geradora e que aceita uma outra função geradora. Geralmente, uma aplicação possui uma série de mediadores que são executados a cada requisição. </p>

<p>Além disso, um mediador deve retornar para o próximo mediador abaixo no fluxo de controle, caso seja executado por um mediador mais alto. Discutiremos mais sobre isso na seção de manipulação de erros.</p>

<h3>Construindo Mediadores</h3>

<p>Uma última coisa: Para adicionar um mediador à sua aplicação Koa, usaremos o método <code class="inline">koa.use()</code> e prover uma função mediadora (geradora) como argumento. Exemplo: <code class="inline">app.use(koa-logger)</code> adiciona o <code class="inline">koa-logger</code> à lista de mediadores que nossa aplicação usa.</p>

<h2>Construindo a Aplicação</h2>

<p>Para começar com a API do dicionário, precisamos de conjunto funcional de definições. Para recriar esse cenário da vida real, decidimos ir com uma conjunto de dados real. Baixamos a lista de definições da Wikipedia e carregamos no Mongo. O conjunto tem cerca de 700.000 palavras, uma vez que importamos somente a lista de definições em inglês. Cada registro (ou documento) consiste de uma palavra, seu tipo e seu significado. Você pode ler mais sobre o processo de importação no arquivo <code class="inline">import.txt</code> do repositório.</p>

<p>Continuando com o processo de desenvolvimento, clone o repositório e verifique seu progresso, navegando pelos diferentes <em>commits</em>. Para clonar o repositório, use o comando a seguir:</p>

<pre class="brush: bash">$ git clone https://github.com/bhanuc/dictapi.git</pre>

<p>Comecemos criando um servidor base do Koa:</p>

<pre class="brush: javascript">var koa = require('koa');
var app = koa();

app.use(function *(next){
this.type = 'json';
    this.status = 200;
    this.body = {'Welcome': 'Essa é uma aplicação Olá Mundo de nível 2!!'};
});

if (!module.parent) app.listen(3000);
console.log('Olá Mundo executando em http://localhost:3000/');

</pre>

<p>Na primeira linha, importamos o Koa e salvamos uma instância na variável <code class="inline">app</code>. Então, adicionamos um único mediador na linha 5, que é uma função geradora anônima que recebe a variável <code class="inline">next</code> como parâmetro. Aqui, atribuímos o tipo e o estado da resposta, que é determinado automaticamente, mas também podemos configurá-lo manualmente. Finalmente, configuramos o corpo da resposta. </p>

<p>Já que configuramos o corpo de nosso primeiro mediador, ele marcará o fim de cada ciclo de requisição e não envolveremos qualquer outro mediador. Por último, iniciamos o servidor, executando seu método <code class="inline">listen</code> e passando um número de porta como parâmetro.</p>

<p>Podemos iniciar o servidor através da execução do <em>script</em>, dessa forma:</p>

<pre class="brush: bash">$ npm install koa
$ node --harmony index.js</pre>

<p>Você pode ir direto para esse ponto, buscando o <em>commit</em>  <code class="inline">6858ae0</code>:</p>

<pre class="brush: bash">$ git checkout 6858ae0</pre>

<h3>Adicionando Capacidade de Roteamento</h3>

<p>Roteamento permite-nos redirecionar diferentes requisições a diferentes funções, baseado no tipo da requisição e na URL requisitada. Por exemplo, podemos querer responder a <code class="inline">/login</code> diferentemente de <code class="inline">signup</code>. Isso pode ser feito a partir da adição de um mediador, que verifica manualmente a URL da requisição recebida e executa as funções correspondentes. Ou, ao invés de escrever o mediador manualmente, podemos usar um mediador criado pela comunidade, também conhecido como módulo mediador.</p>

<p>Para adicionar a capacidade de roteamento à nossa aplicação, usaremos um módulo da comunidade chamado de <code class="inline">koa-router</code>. </p>

<p>Para usar o <code class="inline">koa-router</code>, modificaremos o código que já temos para algo parecido com isso: </p>

<pre class="brush: javascript">var koa = require('koa');
var app = koa();
var router = require('koa-router');
var mount = require('koa-mount');

var handler = function *(next){
this.type = 'json';
    this.status = 200;
    this.body = {'Welcome': 'Essa é uma aplicação Olá Mundo de nível 2!!'};
};

var APIv1 = new router();
APIv1.get('/all', handler);

app.use(mount('/v1', APIv1.middleware()));
if (!module.parent) app.listen(3000);
console.log('Olá Mundo executando em http://localhost:3000/');

</pre>

<p>Nós importamos dois módulos aqui, onde a variável <code class="inline">router</code> guarda o <code class="inline">koa-router</code> e a variável <code class="inline">mount</code> guarda o módulo <code class="inline">koa-mount</code>, permitindo-nos usar o roteador em nossa aplicação Koa.</p>

<p>Na linha 6, definomos nossa função <code class="inline">handler</code> function, que é a mesma função de antes mas, dessa vez, demos um nome a ela. Na linha 12, guardamos uma instância do roteador em <code class="inline">APIv1</code> e na linha 13 registrarmos nosso manipulador para requisições <code class="inline">GET</code> na rota <code class="inline">/all</code>. </p>

<p>Assim, todas as requisições retornarão "not found", exceto aquelas que foram feitas para <code class="inline">localhost:3000/all</code>. Finalmente, na linha 15, usamos o mediador <code class="inline">mount</code>, que nos fornece uma função gerador que pode ser passada para <code class="inline">app.use()</code>.</p>

<p>Para ver esse passo em específico ou comparar sua aplicação, execute o seguinte comando no repositório clonado:</p>

<pre class="brush: bash">$ git checkout 8f0d4e8</pre>

<p>Antes de executarmos nossa aplicação, precisamos instalar o <code class="inline">koa-router</code> e o <code class="inline">koa-mount</code> usando o <code class="inline">npm</code>. De acordo com o auumento da complexidade da aplicação, o número de módulos/dependências também aumenta. </p>

<p>Para manter o controle de todas as informações relacionadas ao projeto e disponibilizar esses dados no <code class="inline">npm</code>, guardamos toda a informação em um arquivo <code class="inline">package.json</code>, incluindo todas as dependências. Você pode criar um arquivo <code class="inline">package.json</code> manualmente or usar a interface interativa de linha de comando, que abrimos com o comando <code class="inline">$ npm init </code>.</p>

<pre class="brush: javascript">{
"name": "koa-api-dictionary",
    "version": "0.0.1",
    "description": "koa-api-dictionary application",
    "main": "index",
    "author": {
    "name": "Bhanu Pratap Chaudhary",
    "email": "bhanu423@gmail.com"
    },
    "repository": {
    "type": "git",
    "url": "https://github.com/bhanuc/dictapi.git"
    },
    "license": "MIT",
    "engines": {
    "node": "&gt;= 0.11.13"
    }
}

</pre>

<p>A very minimal <code class="inline">package.json</code> file looks like the one above. </p>

<p>Once <code class="inline">package.json</code> is present, you can save the dependency using the following command:</p>

<pre class="brush: bash">$ npm install &lt;package-name&gt; --save</pre>

<p>For example: In this case, we will install the modules using the following command to save the dependencies in <code class="inline">package.json</code>.</p>

<pre class="brush: bash">$ npm install koa-router koa-mount --save</pre>

<p>Now you can run the application using <code class="inline">$ node --harmony index.js</code>. </p>

<p>You can read more about <code class="inline">package.json</code> <a href="https://www.npmjs.org/doc/files/package.json.html" target="_self">here</a>.</p>

<h3> Adding Routes for the Dictionary API</h3>

<p>We will start by creating two routes for the API, one for getting a single result in a faster query, and a second to get all the matching words (which is slower for the first time). </p>

<p>To keep things manageable, we will keep all the API functions in a separate folder called <code class="inline">api</code> and a file called <code class="inline">api.js</code>, and import it later in our main <code class="inline">index.js</code> file.</p>

<pre class="brush: javascript">var monk = require('monk');
var wrap = require('co-monk');
var db = monk('localhost/mydb');
var words = wrap(db.get('words'));
/**
* GET all the results.
*/
exports.all = function *(){
if(this.request.query.word){
        var res = yield words.find({ word : this.request.query.word });
        this.body = res;
    } else {
        this.response.status = 404;
        }
    };
/**
* GET a single result.
*/
exports.single = function *(){
    if(this.request.query.word){
        var res = yield words.findOne({ word : this.request.query.word });
        this.body = res;
    } else {
        this.response.status = 404;
    }
};</pre>

<p>Here we are using <code class="inline">co-monk</code>, which acts a wrapper around <code class="inline">monk</code>, making it very easy for us to query MongoDB using generators in Koa. Here, we import <code class="inline">monk</code> and <code class="inline">co-monk</code>, and connect to the MongoDB instance on line 3. We call <code class="inline">wrap()</code> on collections, to make them generator-friendly. </p>

<p>Then we add two generator methods named <code class="inline">all</code> and <code class="inline">single</code> as a property of the <code class="inline">exports</code> variable so that they can be imported in other files. In each of the functions, first we check for the query parameter 'word.' If present, we query for the result or else we reply with a 404 error. </p>

<p>We use the <code class="inline">yield</code> keyword to wait for the results as discussed in the first article, which pauses the execution until the result is received. On line 12, we use the <code class="inline">find</code> method, which returns all the matching words, which is stored in res and subsequently sent back. On line 23, we use the <code class="inline">findOne</code> method available on the collection, which returns the first matching result. </p>

<h3>Assigning These Handlers to Routes</h3>

<pre class="brush: javascript">var koa = require('koa');
var app = koa();
var router = require('koa-router');
var mount = require('koa-mount');
var api = require('./api/api.js');

var APIv1 = new router();
APIv1.get('/all', api.all);
APIv1.get('/single', api.single);


app.use(mount('/v1', APIv1.middleware()));
if (!module.parent) app.listen(3000);
console.log('Dictapi is Running on http://localhost:3000/');</pre>

<p>Here we import exported methods from <code class="inline">api.js</code> and we assign handlers to <code class="inline">GET</code> routes <code class="inline">/all</code>  <code class="inline">/single</code> and we have a fully functional API and application ready.</p>

<p>To run the application, you just need to install the <code class="inline">monk</code> and <code class="inline">co-monk</code> modules using the command below. Also, ensure you have a running instance of MongoDB in which you have imported the collection present in the git repository using the instructions mentioned in <code class="inline">import.txtweird</code>.</p>

<pre class="brush: bash">$ npm install monk co-monk --save</pre>

<p>Now you can run the application using the following command:</p>

<pre class="brush: bash">$ node --harmony index.js</pre>

<p>You can open the browser and open the following URLs to check the functioning of the application. Just replace 'new' with the word you want to query.</p>

<ul>
  <li><code class="inline">http://localhost:3000/v1/all?word=new</code></li>
  <li><code class="inline">http://localhost:3000/v1/single?word=new</code></li>
</ul>

<p>To directly reach this step or compare your application, execute the following command in the cloned repo:</p>

<pre class="brush: bash">$ git checkout f1076eb  </pre>

<h3>Error Handling in Koa</h3>

<p>By using cascading middlewares, we can catch errors using the <code class="inline">try/catch</code> mechanism, as each middleware can respond while yielding to downstream as well as upstream. So, if we add a <i>Try and Catch</i> middleware in the beginning of the application, it will catch all the errors encountered by the request in the rest of the middleware as it will be the last middleware during upstreaming. Adding the following code on line 10 or before in <code class="inline">index.js</code> should work.</p>

<pre class="brush: javascript">app.use(function *(next){
try{
yield next; //pass on the execution to downstream middlewares
} catch (err) { //executed only when an error occurs &amp; no other middleware responds to the request
this.type = 'json'; //optional here
this.status = err.status || 500;
this.body = { 'error' : 'The application just went bonkers, hopefully NSA has all the logs ;) '};
//delegate the error back to application
this.app.emit('error', err, this);
    }
});</pre>

<h3>Adding Logging and Rate-Limiting to the Application</h3>

<p>Storing logs is an essential part of a modern-day application, as logs are very helpful in debugging and finding out issues in an application. They also store all the activities and thus can be used to find out user activity patterns and interesting other patterns. </p>

<p>Rate-limiting has also become an essential part of modern-day applications, where it is important to stop spammers and bots from wasting your precious server resources and to stop them from scraping your API.</p>

<p>It is fairly easy to add logging and rate-limiting to our Koa application. We will use two community modules: <code class="inline">koa-logger</code> and <code class="inline">koa-better-rate-limiting</code>. We need to add the following code to our application:</p>

<pre class="brush: plain">var logger = require('koa-logger');
var limit = require('koa-better-ratelimit');
//Add the lines below just under error middleware.
app.use(limit({ duration: 1000*60*3 , // 3 min
            max: 10, blacklist: []}));
app.use(logger());</pre>

<p>Here we have imported two modules and added them as middleware. The logger will log each request and print in the <code class="inline">stdout</code> of the process which can be easily saved in a file. And limit middleware limits the number of requests a given user can request in a given timeframe (here it is maximum ten requests in three minutes). Also you can add a array of IP addresses which will be blacklisted and their request will not be processed.</p>

<p>Do remember to install the modules before using the code using: </p>

<pre class="brush: bash">$ npm install koa-logger koa-better-ratelimit --save</pre>

<h3>Compressing the Traffic</h3>

<p>One of the ways to ensure faster delivery is to gzip your response, which is fairly simple in Koa. To compress your traffic in Koa, you can use the <code class="inline">koa-compress</code> module. </p>

<p>Here, options can be an empty object or can be configured as per the requirement.</p>

<pre class="brush: javascript">var compress = require('koa-compress');
var opts =  {
filter: function (content_type) { return /text/i.test(content_type) }, // filter requests to be compressed using regex
    threshold: 2048, //minimum size to compress
    flush: require('zlib').Z_SYNC_FLUSH };
            }
//use the code below to add the middleware to the application
app.use(compress(opts));
</pre>

<p>You can even turn off compression in a request by adding the following code to a middleware:</p>

<pre class="brush: javascript">this.compress = true;</pre>

<p>Don't forget to install compress using <code class="inline">npm</code>. </p>

<pre class="brush: bash">$ npm install compress --save </pre>

<p>To directly reach this step or compare your application, execute the following command in the cloned repo:</p>

<pre class="brush: javascript">git checkout 8f5b5a6 </pre>

<h3>Writing Tests</h3>

<p>Test should be an essential part of all code, and one should target for maximum test coverage. In this article, we will be writing tests for the routes that are accessible from our application. We will be using supertest and Mocha to create our tests. </p>

<p>We will be storing our test in <code class="inline">test.js</code> in the <code class="inline">api</code> folder. In both tests, we first describe our test, giving it a more human readable name. After that, we will pass an anonymous function which describes the correct behavior of the test, and takes a callback which contains the actual test. In each test, we import our application, initiate the server, describe the request type, URL and query, and then set encoding to gzip.  Finally we check for the response if it's correct.</p>

<pre class="brush: javascript">var request = require('supertest');
var api = require('../index.js');

describe('GET all', function(){
  it('should respond with all the words', function(done){
var app = api;
    request(app.listen())
    .get('/v1/all')
    .query({ word: 'new' })
    .set('Accept-Encoding', 'gzip')
    .expect('Content-Type', /json/)
    .expect(200)
    .end(done);
  })
})

describe('GET /v1/single', function(){
  it('should respond with a single result', function(done){
    var app = api;

    request(app.listen())
    .get('/v1/single')
    .query({ word: 'new' })
    .set('Accept-Encoding', 'gzip')
    .expect(200)
    .expect('Content-Type', /json/)
    .end(function(err, res){
    if (err) throw err;
    else {
        if (!('_id' in res.body)) return "missing id";
        if (!('word' in res.body)) throw new Error("missing word");
        done();
    }
  });
  })
})</pre>

<p>To run our test, we will make a <code class="inline">Makefile</code>:</p>

<pre class="brush: plain">test:
@NODE_ENV=test ./node_modules/.bin/mocha \
		--require should \
		--reporter nyan \
		--harmony \
		--bail \
		api/test.js

.PHONY: test</pre>

<p>Here, we've configured the reporter (nyan cat) and the testing framework (mocha). Note that the import should add <code class="inline">--harmony</code> to enable ES6 mode. Finally, we also specify the location of all the tests. A <code class="inline">Makefile</code> can be configured for endless testing of your application.</p>

<p>Now to test your app, just use the following command in the main directory of the application. </p>

<pre class="brush: bash">$ make test</pre>

<p>Just remember to install testing modules (mocha, should, supertest) before testing, using the command below: </p>

<pre class="brush: bash">$ npm install mocha should mocha --save-dev </pre>

<h3>Running in Production</h3>

<p>To run our applications in production, we will use PM2, which is an useful Node process monitor. We should disable the logger app while in production; it can be automated using environment variables.</p>

<p>To install PM2, enter the following command in terminal</p>

<pre class="brush: bash">$ npm install pm2 -g </pre>

<p>And our app can be launched using the following command:</p>

<pre class="brush: html">$ pm2 start index.js --node-args="--harmony" </pre>

<p>Now, even if our application crashes, it will restart automatically and you can sleep soundly. </p>

<h3>Conclusion</h3>

<p>Koa is a light and expressive middleware for Node.js that makes the process of writing web applications and APIs more enjoyable. </p>

<p>It allows you to leverage a multitude of community modules to extend the functionality of your application and simplify all the mundane tasks, making web development a fun activity. </p>

<p>Please don't hesitate to leave any comments, questions, or other information in the field below.</p>