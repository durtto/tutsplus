<h1>Introdução a Geradores & Koa.js: Parte 1</h1>

<p>O <a href="http://koajs.com/" target="_self">Koa.js</a> é um <em>framework</em> para web, expressivo e de próxima geração, para <a href="http://nodejs.org/" target="_self">Node.js</a>, criado pelo pessoal responsável pelos <em>frameworks</em> Express e Connect. O Koa.js lança mão de geradores, que são uma funcionalidade bem recente no JavaScript, e que ainda não chegou às versões estáveis do Node.js. O Koa tem como objetivo lançar mão de geradores para evitar que os desenvolvedores acabem em código espaguete de funções <em>call-backs</em>, diminuindo a ocorrência de erros, tornando-o mais administrável.</p>

<p>Com apenas 550 linhas de código, o Koa é um <em>framework</em> extremamente leve. Ainda assim, o Koa vem com um elegante conjunto de métodos, como os de negociação de conteúdo, redirecionamentos, suporte a <em>proxy</em>, etc., facilitando e acelerando o desenvolvimento, juntamente ao controle granular sobre sua aplicação para Node.</p>

<h2>Instalando o Node</h2>

<p>Antes de começarmos, você precisará ter a versão <code class="inline">0.11.x</code> do Node, ou mais recente.</p>

<p>Você pode instalar a versão mais recente do Node usando o módulo N:</p>

<pre class="brush: bash">sudo npm install -g n
sudo n stable </pre>

<p>Você pode usar outros módulos da comunidade, como o nvm ou construí-lo a partir do código fonte, a escolha é sua. Note que o N também é um módulo da comunidade.</p>

<span class="wysiwyg-font-size-medium"><span class="wysiwyg-font-size-medium">
</span></span>

<p>Para executar um código JavaScript que faz uso de geradores, você precisa prover o semáforo (<em>flag</em>) <code class="inline">--harmony</code> ao executá-lo.</p>

<p>Por exemplo, para executar o código <code class="inline">app.js</code>, digite o seguinte comando:</p>

<pre class="brush: bash">node --harmony app.js</pre>

<div/>

<p>Ou para evitar que tenha de digitar o semáforo todas as vezes, você pode criar um apelido (<em>alias</em>), usando o seguinte comando:</p>

<pre class="brush: bash">alias node="node --harmony"</pre>

<div/>

<p>Agora, para executar suas aplicações que usam geradores, basta digitar:</p>

<pre class="brush: bash">node app.js</pre>

<p>Muito bem! Lembre-se que todo o código desse artigo está disponível no <a href="https://github.com/bhanuc/koa-article" target="_self">GitHub</a>. Sinta-se livre para fazer uma cópia para você e brincar com ele.</p>

<p>Para entender o Koa, primeiro, você tem de entender os geradores, que são a espinha dorsal do <em>framework</em>.</p>

<span class="wysiwyg-font-size-medium"><span class="wysiwyg-font-size-medium">
</span></span>

<b><h2>O Que São Geradores?</h2>
</b>

<p>Com a EcmaScript 6, os geradores finalmente chegaram à terra mágica do JavaScript. Se você já usou geradores em outras linguagens de programação como o Lua, Python, Scheme, Smalltalk, etc., então você ficará feliz de saber que algo muito semelhante foi implementado no JavaScript. </p>

<p>Os geradores são co-rotinas de primeira classe no JavaScript, isso é, introduzem uma interface de pausa e execução na linguagem. Antes dos geradores, o código inteiro <em>costumava</em> executar do início ao fim, sem uma maneira fácil de parar a execução do código e dar continuidade de onde parou. Agora, sujemos nossas mãos com alguns exemplos.</p>

<p>De acordo com a atual especificação da EcmaScript 6, precisamos usar uma versão diferente de definição de função para criar uma função geradora. Ela se parece com isso:</p>

<pre class="brush: javascript">var generator_func = function* () { };</pre>

<p>Aqui, a <code class="inline">generator_func</code> é só uma função geradora vazia.</p>

<span class="wysiwyg-font-size-medium"><span class="wysiwyg-font-size-medium">
</span></span>

<p>O que podemos fazer agora é usar a palavra-chave <code class="inline">yield</code> no corpo da função para parar a execução e guardar o estado atual da pilha de execução.</p>

<span class="wysiwyg-font-size-medium"><span class="wysiwyg-font-size-medium">
</span></span>

<p>Eis um exemplo simples demonstrando a Soma de uma Progressão Aritmética Infinita:</p>

<pre class="brush: javascript">var r = 3;

function* infinite_ap(a) {
 for( ; ; ) {
        a = a + r;
        yield a;
      }
}

var sum = infinite_ap(5);

console.log(sum.next()); // retorna { value : 8, done : false }
console.log(sum.next()); // retorna { value : 11, done: false }</pre>

<span class="wysiwyg-font-size-medium"><span class="wysiwyg-font-size-medium">
</span></span>

<p>No código acima, começamos criando uma instância de um iterador, chamado de <code class="inline">infinite_ap</code>, que inclui o um laço infinito e se executado sob condições normais, pode parar a execução.</p>

<p>Depois, salvamos a instância do iterador na variável <code class="inline">sum</code>.</p>

<p>Agora, quando executarmos <code class="inline">sum.next()</code>, ela retornará <code class="inline">{ value: 8, done: false }</code>, significando que ela pausou sua execução quando alcançou a declaração <code class="inline">yield</code> retornando <code class="inline">value</code> com o valor de 'a' e <code class="inline">done</code> com o valor de 'false'.</p>

<p>Enquanto a execução não for finalizada, <code class="inline">done</code> continuará retornando 'false'. Assim que a execução estiver finalizada (no caso acima, isso nunca acontece), a função retornará <code class="inline">{value: undefined, done: true}</code>.</p>

<p>Eis uma pequena modificação do trecho de código anterior para demosntrar a finalização da execução:</p>

<pre class="brush: plain">var r = 3;

function* infinite_ap(a) {
for( var i = 0; i &lt; 3 ; i++) {
       a = a + r ;
       yield a;
    }
}

var sum = infinite_ap(5);

console.log(sum.next()); // retorna { value : 8, done : false }
console.log(sum.next()); // retorna { value : 11, done: false }
console.log(sum.next()); // retorna { value : 14, done: false }
console.log(sum.next()); // retorna { value: undefined, done: true } </pre>

<span class="wysiwyg-font-size-medium"><span class="wysiwyg-font-size-medium">
</span></span>

<p>Em programas mais complexos, você poderia verificar e usar os valores retornados e o estado <code class="inline">done</code>.</p>

<span class="wysiwyg-font-size-medium"><span class="wysiwyg-font-size-medium">
</span></span>

<p><i>Nota</i>: Usar <code class="inline">yield</code> sem <code class="inline">function*</code> levará a um erro.</p>

<span class="wysiwyg-font-size-medium"><span class="wysiwyg-font-size-medium">
</span></span>

<h2>Métodos de Geradores Disponíveis</h2>

<span class="wysiwyg-font-size-medium"><span class="wysiwyg-font-size-medium">
</span></span>

<p>Eis alguns métodos que serão úteis ao lidar com geradores padrão.</p>

<p>Cada um dos métodos abaixo está disponível apenas em uma função geradora e lançará um erro, caso contrário.</p>

<span class="wysiwyg-font-size-medium"><span class="wysiwyg-font-size-medium">
</span></span>

<b><h3><code class="inline">next()</code></h3>
</b>

<p>Esse método é usado para dar continuidade à execução e os argumentos necessários. Se nada for passado, <code class="inline">undefined</code> é passado como o primeiro argumento.</p>

<p>Exemplo: <code class="inline">sum.next(5);</code></p>

<span class="wysiwyg-font-size-medium"><span class="wysiwyg-font-size-medium">
</span></span>

<b><h3><code class="inline">throw()</code></h3>
</b>

<span class="wysiwyg-font-size-medium"><span class="wysiwyg-font-size-medium">
</span></span>

<p>Esse método é usado para lançar um erro ou exceção em qualquer passo. Ele torna a manipulação de erros muito mais fácil. Lançar um erro pode resultar na finalização da execução de um arquivo, caso não seja manipulado em algum lugar. A forma mais simples de manipular erros é usar <code class="inline">try-catch</code>. Esse método leva um único argumento que pode ser qualquer coisa.</p>

<p>Exemplo: <code class="inline">sum.throw(new Error("Isso é um erro"));</code> </p>

<span class="wysiwyg-font-size-medium"><span class="wysiwyg-font-size-medium">
</span></span>

<h3><b>Delegando o <code class="inline">yield</code></b></h3>

<p>Delegação de geradores é usado para fornecer um gerador a partir de um gerador existente e pode ser usado para compor geradores e, até mesmo, iterar sobre um gerador.</p>

<span class="wysiwyg-font-size-medium"><span class="wysiwyg-font-size-medium"><p>Ao delegar a outro gerador, o gerador atual para de produzir valores para si próprio e começa a esperar pelos valores do gerador delegado até que ele finalize. Uma vez finalizada a delegação do gerador, o gerador original volta a retornar seus próprios valores.</p>
</span></span>

<p>É quase a mesma coisa que usar um laço <code class="inline">for-in</code> para iterar sobre o gerador, mas as exceções do gerador delegado são propagadas e lançadas pelo método <code class="inline">throw</code> do gerador original, e deveria ser manipulado de acordo. Eis um exemplo:</p>

<pre class="brush: javascript">var consoleLogThunk = function(msg) {
return function() {
        console.log(msg);
      }
}

var generator = function*() {
    yield consoleLogThunk("Yo");
    yield consoleLogThunk("Dawg");
    yield consoleLogThunk("!!!");
}

var delegator_function = function* () {
    yield consoleLogThunk("I yielded before delegated yield");
    yield* generator();
    yield consoleLogThunk("I yielded after delegated yield");
}

var k = delegator_function();

k.next().value();
k.next().value();
k.next().value();

console.log(k.next()); // Se você invocar k.next(), será lançado um erro Type, uma vez que o valor é undefined, que não é uma função

</pre>

<p>Agora que você tem sabe um pouco sobre geradores no JavaScript, você pode usá-los para escrever aplicações muito mais claras e precisas, onde você pode criar códigos de I/O, sem bloquear o processo de verdade. </p>

<p>Passemos para a instalação do Koa e criação de uma aplicação bem simples em Koa.js.</p>

<span class="wysiwyg-font-size-medium"><span class="wysiwyg-font-size-medium">
</span></span>

<b><div/><h2>Koa.js:</h2>
</b>

<p>O Koa é um objeto que contém um vetor de funções geradores de mediador (<em>middlewares</em>), os quais são compostos e executados em pilha a cada requisição.</p>

<h3><b>Instalando Koa</b></h3>

<p>No diretório do seu projeto, execute o comando a seguir.</p>

<pre class="brush: bash">npm install koa --save</pre>

<p>Koa será baixado automaticamente e salvo no arquivo <code class="inline">package.json</code>, se existir.</p>

<p>Apesar do pequeno do Koa, ela inclui métodos como limpeza de cache, negociação de conteúdo, suporte a proxy, etc., sem qualquer <em>mediador</em> adicionado.</p>

<p>Eis um exemplo de uma aplicação ola-mundo:</p>

<pre class="brush: javascript">var koa = require('koa');
var app = koa();

app.use(function *(){
this.body = "Olá Mundo !!!";
});

app.listen(3000);</pre>

<h3>Fluxo de Controle do Koa</h3>

<p>Koa também implementa o controle de fluxo de ida e volta. Inicialmente, pode ser difícil de entender, mas, uma vez que conseguir compreender o exemplo abaixo, as coisas ficarão mais claras.</p>

<p>Eis um exemplo de controle de fluxo no Koa:</p>

<pre class="brush: javascript">var koa = require('koa')();

koa.use(function* (next) {
// faça algo antes de esperar/passar para a próxima função gerador, que será o primeiro da ida
    console.log("A");
    yield next;

    // faça algo quando a execução voltar, esse será o último evento da volta
    console.log("B");
});

koa.use(function* (next) {
    // faça algo antes de esperar/passar para a próxima função gerador, que será o segundo da ida
    console.log("C");

    yield next;

    // faça algo quando a execução voltar, esse será o segundo evento da volta
    console.log("D");
});

koa.use(function* () { // faça algo antes de esperar/passar para a próxima função gerador, que será a última da ida
    console.log("E");
    this.body = "hey guys";
    console.log("F"); // Primeiro evento da volta (do último para o primeiro)

});

koa.listen(3000);
</pre>

<p>O código acima é bem simples. Note que que nem todos as declarações de <code class="inline">console.log</code> são requeridas mas elas ajudarão a clarear o entendimento do fluxo de execução de ida e volta do Koa.js.</p>

<h4>Entendendo o Fluxo de Execução do Exemplo</h4>

<p>Quando executamos essa aplicação e digitamos o endereço <code class="inline">localhost:3000</code> no navegador, podemos observar que os <code class="inline">console.logs</code> no terminal não estão na ordem <b>A-B-C-D-E-F</b>. Nem na ordem <b>A-C-E-B-D-F</b>.</p>

<p>A ordem á <b>A-C-E-F-D-B</b> que demonstra o comportamento de ida e volta dos <code class="inline">yields</code> da execução em uma aplicação em Koa.</p>

<p>Talvez tenha notado que a sequência foi impressa duas vezes. Isso é devido à dupla requisição enviada pelo navegador, onde uma serve para buscar o <em>favicon</em>.</p>



<span class="wysiwyg-font-size-medium"><span class="wysiwyg-font-size-medium"><p><i>Dica</i>: O método <code class="inline">koa.use(function)</code> adiciona uma função mediadora à aplicação.</p>
</span></span>

<span class="wysiwyg-font-size-medium"><span class="wysiwyg-font-size-medium">
</span></span>

<div/>

<h2>Em Conclusão</h2>

<p>E isso é tudo para essa primeira parte deste tutorial sobre geradores no JavaScript e sobre o Koa.js. Você aprendeu sobre a maioria dos pré-requesitos, como o que são geradores, como usá-los, como usar uma submissão delegada e como o controle de fluxo funciona no Koa.js.</p>

<p>Na próxima parte deste tutorial, iremos mais a fundo no Koa e aprenderemos como construir uma aplicação CRUD. Se tiver quaisquer dúvidas ou comentários, sinta-se à vontade de contatar-me ou deixar uma mensagem logo abaixo. </p>