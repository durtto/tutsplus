<h1>Building With the Twitter API: Using Real-Time Streams</h1>

<p>While the <a href="https://dev.twitter.com/rest/public" target="_self">Twitter REST API</a> is suitable for many applications, if you want immediate updates and access to a broader array of notifications, the <a href="https://dev.twitter.com/streaming/overview" target="_self">Twitter Streaming API</a> is essential. For example, only the streaming API will tell you when another user favorites one of your tweets.</p>

<p>Using the Streaming API requires a persistent, keep-alive connection between your web server and Twitter. This type of implementation may be unfamiliar to many PHP developers. As soon as tweets come in, Twitter notifies your server in real time, allowing you to store them into your database without the delay of polling the REST API. Use of the Streaming API is also not subject to Twitter's API rate limits.</p>

<p>Here's a visualization of how it works:</p>

<figure class="post_image">
  <img alt="How the Twitter Streaming API works" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/317/posts/22194/image/streaming-intro-2_1.png"/>
</figure>

<p>There are three variations of the Twitter Streaming API:</p>

<ol>
  <li><a href="https://dev.twitter.com/streaming/public" target="_self">The Public Stream</a>. This allows your application to monitor public data on Twitter, such as public tweets, hashtag filters, et al. </li>
  <li><a href="https://dev.twitter.com/streaming/userstreams" target="_self">The User Stream</a>. This allows you to track a user's tweet stream in real time. Part three of this series will focus on the user stream. </li>
  <li><a href="https://dev.twitter.com/streaming/sitestreams" target="_self">Site Streams</a>. Site streams allow your application to monitor real-time Twitter feeds for a large number of users. </li>
</ol>

<p>The job of your streaming implementation is to log the incoming events as quickly as possible and process them in the background using the REST API as necessary to harvest deeper data. Site streams require <a href="https://dev.twitter.com/streaming/sitestreams#applyingforaccess" target="_self">prior approval from Twitter</a>, which are likely reserved for larger companies and developers.</p>

<p>Fortunately, there is a free, open-source library called <a href="https://github.com/tutsplus/phirehose" target="_self">Phirehose</a>, which implements most of the streaming API requirements. This tutorial will describe how to integrate Phirehose into our open-source Birdcage application.</p>

<h2>The Phirehose Library</h2>

<p>Phirehose is a fantastic open-source PHP implementation of the Twitter Stream API requirements written by <a href="https://github.com/fennb" target="_self">Fenn Bailey</a>. As he describes it, Phirehose is meant to:</p>

<ul class="task-list">
  <li>provide a simple interface to the Twitter Streaming API for PHP applications</li>
  <li>comply with Streaming API recommendations for error handling, reconnection, etc.</li>
  <li>encourage well-behaved streaming API clients</li>
  <li>operate independently of PHP extensions (i.e. shared memory, PCNTL, etc.)</li>
</ul>

<p>I've found the library to operate quite flawlessly. There's more <a href="https://github.com/fennb/phirehose/wiki/Introduction" target="_self">Phirehose documentation here</a>.</p>

<p>It's meant to maintain the connection with Twitter and respond to Twitter's data feed while operating indefinitely without interruption. It's not meant to perform detailed tweet processing and data hydrating, which we've described in <a href="http://code.tutsplus.com/tutorials/building-with-the-twitter-api-oauth-reading-and-posting--cms-22193" target="_self">part two of this series</a>. This can be done separately.</p>

<h2>Running Phirehose Indefinitely</h2>

<p>Generally, you can't run a typical web-based cron task as an indefinite keep-alive operation. It's better to create a command line daemon.</p>

<p>One of the powerful features <a href="http://code.tutsplus.com/articles/introduction-to-the-yii-framework--cms-20948" target="_self">Yii</a> offers is the ability to run console-based applications from the command line. This will allow us to run a keep-alive command line application that utilizes the entire Birdcage PHP and MySQL framework that we've built.</p>

<h3>Building a Yii Console Command</h3>

<p>In the <code class="inline">/app/</code> directory, outside the web accessible root, we'll add a <code class="inline">stream.php</code> file that runs our Phirehose streaming console command:</p>

<pre class="brush: php">&lt;?php
defined('YII_DEBUG') or define('YII_DEBUG',true);
$yii=dirname(__FILE__).'/../framework/yii.php';
$config=dirname(__FILE__).'/protected/config/main.php';
require_once($yii);
Yii::createConsoleApplication($config)-&gt;run();</pre>

<p>Next, we'll build the actual command file, <code class="inline">StreamCommand.php</code>, in the <code class="inline">/app/protected/commands</code> directory:</p>

<pre class="brush: php">&lt;?php
class StreamCommand extends CConsoleCommand
{
    // test with php ./app/stream.php Stream
    public function run($args)
    {
        // get Twitter user account keys
        $result = Account::model()-&gt;findByPk(1);
        $c = new Consumer($result['oauth_token'],$result['oauth_token_secret'],Phirehose::METHOD_USER);
        // load Twitter App keys
        $app = UserSetting::model()-&gt;loadPrimarySettings();
        $c-&gt;consumerKey = $app['twitter_key'];
        $c-&gt;consumerSecret = $app['twitter_secret'];
        $c-&gt;consume();
    }
}</pre>

<p>It will launch the Phirehose process, Consumer, using our Twitter application and user keys.</p>

<p><i>Note: For purposes of the Birdcage streaming example, we assume there is only one Twitter account registered and hardcode loading the credentials, e.g. account_id = 1.</i></p>

<h3>Integrating Phirehose</h3>

<p>To integrate Phirehose into Birdcage, I moved <code class="inline">OAuthPhirehose.php</code> and <code class="inline">UserstreamPhirehose.php</code> into the <code class="inline">/app/protected/components</code> directory. In my <code class="inline">main.php</code> configuration file, I added <code class="inline">phirehose</code> to the list of loaded components:</p>

<pre class="brush: php">'preload'=&gt;array(
	  'log',
	  'bootstrap',
	  'mailgun',
	  'phirehose',
  	  'advanced'
	  ),
</pre>

<p>Then, I created a database migration to create a table to store raw data from the Twitter stream:</p>

<pre class="brush: php">class m140919_193106_create_stream_table extends CDbMigration
{
 protected $MySqlOptions = 'ENGINE=InnoDB CHARSET=utf8 COLLATE=utf8_unicode_ci';
     public $tablePrefix;
     public $tableName;

     public function before() {
       $this-&gt;tablePrefix = Yii::app()-&gt;getDb()-&gt;tablePrefix;
       if ($this-&gt;tablePrefix &lt;&gt; '')
         $this-&gt;tableName = $this-&gt;tablePrefix.'stream';
     }

       public function safeUp()
   	{
   	  $this-&gt;before();
      $this-&gt;createTable($this-&gt;tableName, array(
               'id' =&gt; 'pk',
               'tweet_id' =&gt; 'bigint(20) unsigned NOT NULL',
               'code' =&gt; 'text  NULL',
               'is_processed' =&gt; 'tinyint default 0',
               'created_at' =&gt; 'DATETIME NOT NULL DEFAULT 0',
               'modified_at' =&gt; 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP',
                 ), $this-&gt;MySqlOptions);
                 $this-&gt;createIndex('tweet_id', $this-&gt;tableName , 'tweet_id', true);               

   	}</pre>

<p>I also created a new model called <code class="inline">Consumer.php</code> which extends <code class="inline">OauthPhirehose</code> with its required <code class="inline">enqueueStatus</code> method. </p>

<p>We want to minimize the amount of processing the real-time response needs to perform. Essentially, we just want to record the data received from Twitter to our database—and nothing else. We can do other processing in our own background tasks without slowing Phirehose's streaming connection. My function just takes tweet data from the incoming stream and stores it in the stream table:</p>

<pre class="brush: plain">&lt;?php
  class Consumer extends OauthPhirehose
  {
// This function is called automatically by the Phirehose class
    // when a new tweet is received with the JSON data in $status
    public function enqueueStatus($status) {
      $stream_item = json_decode($status);
      if (!(isset($stream_item-&gt;id_str))) { return;}
      $s = new Stream;
      $s-&gt;tweet_id = $stream_item-&gt;id_str;
      $s-&gt;code = base64_encode(serialize($stream_item));
      $s-&gt;is_processed=0;
      $s-&gt;created_at = new CDbExpression('NOW()');          
      $s-&gt;modified_at =new CDbExpression('NOW()');          
      $s-&gt;save();
      var_dump($stream_item);
    }
  }
  ?&gt;
</pre>

<p>We'll rely on background tasks run by our <code class="inline">DaemonController</code> to process the data into the Bircdcage Tweet model. This is described further below.</p>

<h3>Activating Phirehose</h3>

<p>You can test Phirehose using the PHP console command:</p>

<p><code class="inline">php ./app/stream.php Stream</code></p>

<p>Twitter will send a stream of follower information for the user account, followed by real-time data as it arrives.</p>

<p>To activate Phirehose as a keep-alive, always-on console command, we'll use the <a href="http://manpages.ubuntu.com/manpages/hardy/man1/nohup.1.html" target="_self">nohup command</a>, e.g. no hangup, and redirect output to dev/null:</p>

<p><code class="inline">nohup php ./app/stream.php Stream &gt; /dev/null 2&gt;&amp;1&amp;</code></p>

<p>Ubuntu will respond with a job id of your process for future monitoring and termination:</p>

<p><code class="inline">[1] 9768</code></p>

<p>If you wish to check that the process is running, scan the task list for the job id:</p>

<p><code class="inline">ps -e all | grep 9768</code></p>

<p>You should see something like this:</p>

<p><code class="inline">0  1000  9768  9743  20   0 273112 16916 poll_s S    pts/0      0:00 php ./app/stream.php Stream</code></p>

<p>And you can terminate Phirehose by killing the job id:</p>

<p><code class="inline">kill 9768</code></p>

<p>In my experience, Phirehose has worked flawlessly with this technique operating without interruption for the past two weeks.</p>

<h2>Processing the Streaming Data</h2>

<p>We also need to create a background process in Birdcage which will process the streaming data into our Tweet, Mention, URL and Hashtag tables—as if it had come from the REST API.</p>

<p>Change your <code class="inline">twitter.ini</code> file setting to use streams:</p>

<pre class="brush: bash">twitter_stream = true</pre>

<p>And, we can use the same cron job from part two to run this operation:</p>

<pre class="brush: bash"># To define the time you can provide concrete values for
# minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use '*' in these fields (for 'any').# 
# Notice that tasks will be started based on the cron's system
# daemon's notion of time and timezones.
# 
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
# 
# m h  dom mon dow   command
*/5 * * * * wget -O /dev/null http://birdcage.yourdomain.com/daemon/index</pre>

<p>Then, when DaemonController is called, it will activate the Stream <code class="inline">model()</code> process method:</p>

<pre class="brush: php">public function actionIndex() {
	  // if not using twitter streams, we'll process tweets by REST API
	  if (!Yii::app()-&gt;params['twitter_stream']) {
	    Tweet::model()-&gt;getStreams();	    
	  } else {
	    Stream::model()-&gt;process();
	  }
  }</pre>

<p>The process method unpacks the encoded stream data and parses each entry just as we did with content from the REST API:</p>

<pre class="brush: php">public function process() {
	  // get unprocessed tweets from stream engine
	  // to do 
	  $account_id = 1;
	  $items = Stream::model()-&gt;unprocessed()-&gt;findAll();
	  foreach ($items as $i) {
	    $tweet = unserialize(base64_decode($i['code']));
      Tweet::model()-&gt;parse($account_id,$tweet);
      $this-&gt;setStatus($i['id'],self::STREAM_PROCESSED);      
	  }
	}</pre>

<p>Birdcage currently ignores data from the stream that's not a tweet, e.g. notifications, direct messages, etc. I'll leave that to you to expand—or you can check out my expanded application, <a href="http://jeffreifman.com/birdhouse" target="_self">Birdhouse</a>.</p>

<h2>In Closing</h2>

<p>I hope you've found this three-part Twitter API series informative and useful. By now, you've learned about OAuth, the REST API, the Streaming API, building a database for Twitter, processing the timeline with both types of APIs, properly counting characters in tweets and posting them, and more.</p>

<p>Please post any comments, corrections, or additional ideas below. You can browse my other Tuts+ tutorials on <a href="http://tutsplus.com/authors/jeff-reifman" target="_self">my author page</a> or follow me on <a href="https://twitter.com/intent/user?screen_name=reifman" target="_self">Twitter @reifman</a>.</p>