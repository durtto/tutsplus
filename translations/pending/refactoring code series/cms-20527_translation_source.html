<h1>Refatorando Código Legado: Parte 2 - Cadeias de Caracteres Mágicas & Constantes</h1>

<p>Código velho. Código feio. Código complicado. Código macarrônico. Código sem sentido. Em outras palavras, <em>Código Legado</em>. Esta é uma série que ajudará você a trabalhar e lidar com esse tipo de código.</p>

<p>A primeira vez que encontramos nosso código legado foi no <a href="http://code.tutsplus.com/tutorials/refactoring-legacy-code-part-1-the-golden-master--cms-20331">artigo anterior</a>. Executamos o código para descobrimos algumas coisas sobre suas funcionalidades e criamos o <em>Resultado Esperado</em>, para termos uma boa base de avaliação para mudanças futuras. Continuaremos a trabalhar nesse código e você pode encontrá-lo no diretório <code>trivia/php_start</code>. O outro diretório, <code>trivia/php_start</code>, possui o código já finalizado da lição.</p>

<p>A hora das primeiras mudanças chegou e que melhor maneira de compreender uma base de código complicada que extraindo constantes e cadeias de caracteres mágicos, tornando-os em variáveis? Essa tarefa, aparentemente, simples, dará uma compreensão maior e até inesperada sobre o funcionamento interno do código legado. Precisaremos descobrir a intenção do autor original do código e criar nomes apropriados para os trechos de códigos que nunca vimos antes.</p>

<h2>Cadeias de Caracteres Mágicas</h2>

<p>As cadeias de caracteres mágicas são cadeias de caracteres usadas diretamente em várias expressões, sem serem atribuídas a uma variável. Esse tipo de cadeia de caracteres tinha um significado especial para o autor do código, mas, ao invés de atribuí-la a uma variável bem nomeada, o autor achou que o significado da cadeia fosse óbvio o bastante.</p>

<h3>Identifique as Primeiras Cadeias de Caracteres a Alterar</h3>

<p>Comecemos dando uma olhada em nosso arquivo <code>Game.php</code> e tentemos identificar essas cadeias de caracteres. Se estiver usando uma IDE (e você deveria usar uma) ou um editor de texto mais inteligente, capaz de destacar códigos fonte, identificar essas cadeias de caracteres será fácil. Eis uma imagem de como o código aparece em meu monitor.</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/20527/image/sourcecode-with-strings.png"/>
</figure>

<p>Tudo que está em laranja é uma cadeia de caracteres. Dessa forma, é bem fácil encontrar cada uma delas em nosso código. Então, tenha certeza que um destacador de código fonte está ativo em seu editor, qualquer que seja a sua aplicação.</p>

<p>O primeiro laranja em nosso código está logo na linha número três. Entretanto, essa cadeia de caractere contém um caractere de nova linha, apenas. Isso é óbvio o bastante, na minha opinião. Podemos continuar com o resto do código.</p>

<p>Quando se trata em decidir, exatamente, o que extrais e o que manter inalterado, há algumas decisões melhores que outras, contudo, no final das contas, a sua opinião profissional que deverá prevalecer. Baseado nela, terá de decidir o que fazer com cada peça de código que você analisar.</p>

<pre class="brush: php">for ($i = 0; $i &lt; 50; $i++) {
		array_push($this-&gt;popQuestions, "Pergunta sobre Pop " . $i);
		array_push($this-&gt;scienceQuestions, ("Pergunta sobre Ciências " . $i));
		array_push($this-&gt;sportsQuestions, ("Pergunta sobre Esportes " . $i));
		array_push($this-&gt;rockQuestions, $this-&gt;createRockQuestion($i));
	}
}

function createRockQuestion($index) {
	return "Pergunta sobre Rock " . $index;
}</pre>

<p>Então, analisemos da linha 32 à 42, que é o trecho de código acima. Para as perguntas sobre Pop, Ciências e Esportes, é usada uma simples concatenação. Entretanto, a composição de uma cadeia de caracteres para a pergunta sobre Rock foi extraída em um método. Em sua opinião, essas concatenações e cadeias de caracteres são claras o suficiente para que possamos deixá-las todas dentro do nosso laço <code class="inline">for</code>? Ou você acha que extrair todas essas cadeias de caracteres em seus próprios métodos justificaria a existência deles? Se sim, como você nomearia esses métodos?</p>

<h3>Atualize o <em>Resultado Esperado</em> e os Testes</h3>

<p>Independente da resposta, precisaremos modificar o código. É hora de colocar nosso <a href="http://code.tutsplus.com/tutorials/refactoring-legacy-code-part-1-the-golden-master--cms-20331">Resultado Esperado</a> para trabalhar e criar testes que executem e verifiquem de verdade nosso código com o conteúdo existente.</p>

<pre class="brush: php">class GoldenMasterTest extends PHPUnit_Framework_TestCase {

	private $gmPath;

	function setUp() {
		$this-&gt;gmPath = __DIR__ . '/gm.txt';
	}

	function testGenerateOutput() {
		$times = 20000;
		$this-&gt;generateMany($times, $this-&gt;gmPath);
	}

	function testOutputMatchesGoldenMaster() {
		$times = 20000;
		$actualPath = '/tmp/actual.txt';
		$this-&gt;generateMany($times, $actualPath);
		$file_content_gm = file_get_contents($this-&gt;gmPath);
		$file_content_actual = file_get_contents($actualPath);
		$this-&gt;assertTrue($file_content_gm == $file_content_actual);
	}

	private function generateMany($times, $fileName) {...}

	private function generateOutput($seed) {...}
}</pre>

<p>Criamos outro teste para comparar os retornos, garantindo que o método <code>testGenerateOutput()</code> gere o retorno apenas uma vez e nada mais. Também movemos o <em>resultado esperado</em> para o arquivo <code>"gm.txt"</code> que ficará dentro do diretório atual, uma vez que o diretório <code>"/tmp"</code> será esvaziado sempre que o sistema reiniciar. Para nossos resultados atuais, ainda podemos utilizá-lo. Na maioria dos sistemas <strong>UNIX</strong>, o diretório <code>"/tmp"</code> é criado direto na memória RAM, o que o torna muito mais rápido que o sistema de arquivos. Se você fez tudo certo, os testes devem passar sem qualquer problema.</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/20527/image/gm-initial-pass.png"/>
</figure>

<p>É muito importante lembrarmos de pular nosso teste gerador para mudanças futuras. Se você se sentir mais confortável comentando ou até mesmo removendo o código de uma só vez, faça-o. É importante que nosso <a href="http://code.tutsplus.com/tutorials/refactoring-legacy-code-part-1-the-golden-master--cms-20331">Resultado Esperado</a> não altere quando nosso código for mudado. Ele foi gerado uma vez e não queremos que ele seja modificado, nunca. Assim, poderemos ter certeza que nosso código modificado sempre será comparado com o original. Se se sentir mais confortável realizando uma cópia dele, por favor, faça-o.</p>

<pre class="brush: php">function testGenerateOutput() {
	$this-&gt;markTestSkipped();
	$times = 20000;
	$this-&gt;generateMany($times, $this-&gt;gmPath);
}</pre>

<p>Apenas marcarei para pular o teste. Isso colocará nosso teste como <code>"amarelo"</code>, significando que todos os testes passaram, porém, alguns foram ditos para pular ou marcados como incompletos.</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/20527/image/gm-initial-skipped.png"/>
</figure>

<h3>Realizando Nossa Primeira Mudança</h3>

<p>Com os testes prontos, podemos começar a fazer mudanças no código. Na minha opinião profissional, todas as cadeias de caracteres podem ser mantidas dentro do laço <code>for</code>. Pegaremos o código do método <code>createRockQuestion()</code>, moveremos para dentro do laço <code>for</code> e removeremos o método. Esse tipo de refatoração é chamado de <em>Método em Linha</em>.</p>

<p>"Coloque o corpo do método no corpo do seu invocador remova o método." ~ Martin Fowler</p>

<p>Há passos específicos para realizar esse tipo de refatoração, como foi definido por Marting Fowler no livro <a href="https://www.goodreads.com/book/show/44936.Refactoring">Refactoring: Improving the Design of Existing Code</a>: </p>

<ul>
  <li>Verifique que o método não é polimórfico;</li>
  <li>Entre todas as chamadas ao método;</li>
  <li>Substitua cada chamada pelo corpo do método;</li>
  <li>Compile e teste;</li>
  <li>Remova a definição do método;</li>
</ul>

<p>Não temos quaisquer subclasses estendendo a classe <code>Game</code>, então, o primeiro passo já é válido.</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/20527/image/rock-question-code-usage.png"/>
</figure>

<p>Há um único uso do nosso método, dentro do laço <code>for</code>.</p>

<pre class="brush: php">function  __construct() {

	$this-&gt;players = array();
	$this-&gt;places = array(0);
	$this-&gt;purses = array(0);
	$this-&gt;inPenaltyBox = array(0);

	$this-&gt;popQuestions = array();
	$this-&gt;scienceQuestions = array();
	$this-&gt;sportsQuestions = array();
	$this-&gt;rockQuestions = array();

	for ($i = 0; $i &lt; 50; $i++) {
		array_push($this-&gt;popQuestions, "Pergunta sobre Pop " . $i);
		array_push($this-&gt;scienceQuestions, ("Pergunta sobre Ciências " . $i));
		array_push($this-&gt;sportsQuestions, ("Pergunta sobre Esportes " . $i));
		array_push($this-&gt;rockQuestions, "Pergunta sobre Rock " . $i);
	}
}

function createRockQuestion($index) {
	return "Pergunta sobre Rock " . $index;
}</pre>

<p>Colocamos o código do método <code>createRockQuestion()</code> dentro do laço <code>for</code> no método construtor. Ainda temos nosso código antigo. É hora de executar nossos testes.</p>

<p>Nossos testes passaram. Podemos remover o método <code>createRockQuestion()</code>.</p>

<pre class="brush: php">function  __construct() {

	// ... //

	for ($i = 0; $i &lt; 50; $i++) {
		array_push($this-&gt;popQuestions, "Pergunta sobre Pop " . $i);
		array_push($this-&gt;scienceQuestions, ("Pergunta sobre Ciências " . $i));
		array_push($this-&gt;sportsQuestions, ("Pergunta sobre Esportes " . $i));
		array_push($this-&gt;rockQuestions, "Pergunta sobre Rock " . $i);
	}
}

function isPlayable() {
	return ($this-&gt;howManyPlayers() &gt;= 2);
}</pre>

<p>Por fim, devemos executar nossos testes novamente. Se esquecemos alguma chamada ao método, os testes falharão.</p>

<p>Eles devem passar novamente. Parabéns! Terminamos com nossa primeira refatoração.</p>

<h3>Outras Cadeias de Caracteres a Considerar</h3>

<p>As cadeias de caracteres nos métodos <code>add()</code> e <code>roll()</code> são usadas apenas para serem retornadas usando o método <code>echoln()</code>. O método <code>askQuestions()</code> compara cadeias de caracteres a categorias, o que também parece aceitável. O método <code>currentCategory()</code>, por outro lado, retorna cadeias de caracteres baseado em um número. Neste método, há várias cadeias de caracteres duplicadas. Alterar qualquer categoria, com a exceção da do Rock, requereria alterar seu nome em três lugares, só nesse método.</p>

<pre class="brush: php">function currentCategory() {
	if ($this-&gt;places[$this-&gt;currentPlayer] == 0) {
		return "Pop";
	}
	if ($this-&gt;places[$this-&gt;currentPlayer] == 4) {
		return "Pop";
	}
	if ($this-&gt;places[$this-&gt;currentPlayer] == 8) {
		return "Pop";
	}
	if ($this-&gt;places[$this-&gt;currentPlayer] == 1) {
		return "Ciências";
	}
	if ($this-&gt;places[$this-&gt;currentPlayer] == 5) {
		return "Ciências";
	}
	if ($this-&gt;places[$this-&gt;currentPlayer] == 9) {
		return "Ciências";
	}
	if ($this-&gt;places[$this-&gt;currentPlayer] == 2) {
		return "Esportes";
	}
	if ($this-&gt;places[$this-&gt;currentPlayer] == 6) {
		return "Esportes";
	}
	if ($this-&gt;places[$this-&gt;currentPlayer] == 10) {
		return "Esportes";
	}
	return "Rock";
}</pre>

<p>Acredito que podemos fazer algo melhor. Podemos usar um método de refatoração chamado de <em>Introdução de Variável Local</em> e eliminar essa duplicação. Siga o guia:</p>

<ul>
  <li>Adicione uma variável com o valor desejado;</li>
  <li>Encontre todos os usos para a variável;</li>
  <li>Substitua todos os casos pela variável em questão;</li>
</ul>

<pre class="brush: php">function currentCategory() {
	$popCategory = "Pop";
	$scienceCategory = "Ciências";
	$sportCategory = "Esportes";
	$rockCategory = "Rock";

	if ($this-&gt;places[$this-&gt;currentPlayer] == 0) {
		return $popCategory;
	}
	if ($this-&gt;places[$this-&gt;currentPlayer] == 4) {
		return $popCategory;
	}
	if ($this-&gt;places[$this-&gt;currentPlayer] == 8) {
		return $popCategory;
	}
	if ($this-&gt;places[$this-&gt;currentPlayer] == 1) {
		return $scienceCategory;
	}
	if ($this-&gt;places[$this-&gt;currentPlayer] == 5) {
		return $scienceCategory;
	}
	if ($this-&gt;places[$this-&gt;currentPlayer] == 9) {
		return $scienceCategory;
	}
	if ($this-&gt;places[$this-&gt;currentPlayer] == 2) {
		return $sportCategory;
	}
	if ($this-&gt;places[$this-&gt;currentPlayer] == 6) {
		return $sportCategory;
	}
	if ($this-&gt;places[$this-&gt;currentPlayer] == 10) {
		return $sportCategory;
	}
	return $rockCategory;
}</pre>

<p>Isso está muito melhor. Você já deve ter percebido alguns aprimoramentos futuros que poderíamos fazer ano nosso código, porém, estamos apenas começando nosso trabalho. É tentado ajustar tudo que encontrarmos de uma só vez, mas, por favor, não o faça. Muitas vezes, especialmente antes de um código ser bem compreendido, mudanças tentadoras podem levar a becos sem fim ou mesmo a códigos quebrados. Se você acha que há alguma chance que esquecerá sua ideia, basta criar uma nota ou tarefa em seu aplicativo de gerenciamento de projetos. Agora, continuemos com nossos problemas relacionados às cadeias de caracteres.</p>

<p>No resto do arquivo, todas as cadeias de caracteres estão relacionadas aos seus retornos, enviados através do <code>echoln()</code>. Por hora, deixaremos como está. Modificar isso afetaria a impressão e a lógica de entrega de nossa aplicação. Elas fazem parte da camada de apresentação, misturada com a lógica de negócios. Lidaremos com problemas diferentes em uma lição futura.</p>

<h2>Constantes Mágicas</h2>

<p>Constantes mágicas são muito parecidas com cadeias de caracteres mágicas, mas com outros valores. Esses valores podem ser booleanos ou números. Concentrar-nos-emos mais em números usados em declarações <code>if</code> ou de <code>return</code> e de outras expressões. Se esses números tiverem algum significado impreciso, precisamos extraí-lo em variáveis e métodos.</p>

<pre class="brush: php">include_once __DIR__ . '/Game.php';

$notAWinner;

$aGame = new Game();

$aGame-&gt;add("Chet");
$aGame-&gt;add("Pat");
$aGame-&gt;add("Sue");

do {

	$aGame-&gt;roll(rand(0, 5) + 1);

	if (rand(0, 9) == 7) {
		$notAWinner = $aGame-&gt;wrongAnswer();
	} else {
		$notAWinner = $aGame-&gt;wasCorrectlyAnswered();
	}

} while ($notAWinner);</pre>

<p>Começaremos pelo arquivo <code>GameRunner.php</code> e nosso foco será o método <code>roll()</code>, que gera números aleatórios. O autor anterior não se preocupou com o significado dos números. Será que precisamos? Se analisarmos o código:</p>

<pre class="brush: php">rand(0, 5) + 1</pre>

<p>Ele retornará um número entre um e seis. A parte aleatória gera um número entre zero e cinco, e sempre adicionaremos um a esse valor. Então, é garantido que será entre um e seis. Agora, precisamos analisar no contexto de nossa aplicação. Estamos desenvolvendo um jogo de perguntas e respostas. Sabemos que que tem um tabuleiro no qual os jogadors se movimentarão. E, para tanto, precisarão rolar um dado. O dado possui seis lados e pode produzir números de um a seis. Acredito que isso seja uma dedução razoável.</p>

<pre class="brush: php">$dice = rand(0, 5) + 1;
$aGame-&gt;roll($dice);</pre>

<p>Isso não é legal? Usamos o método de Introdução de Variável Local, novamente. Chamamos nossa variável de <code>$dice</code> e ela representa o número aleatório gerado entre um e seis. Além disso, conseguimos torna a declaração posterior soar bem natural: Jogo, role um dado.</p>

<p>Você executou seus testes? Não mencionei, mas precisamos executá-los com máximo de frequência possível. Caso não os tenha executado, agora seria uma ótima hora para fazê-lo. E eles deveriam passar sem problemas.</p>

<p>Então, esse foi um caso da troca de um número por uma variável. Tornamos uma expressão inteira que representava um número e extraímos em uma variável. Isso pode ser considerado um caso de uma Constante Mágica, mas não é um caso puro de verdade. E que tal a próxima expressão?</p>

<pre class="brush: php">if (rand(0, 9) == 7)</pre>

<p>Essa é um pouco mais complicada. O que significam esse zero, nove e sete, nesta expressão? Talvez possamos nomeá-los. A primeira vista, não tenho a menor ideia do que significam esses zero e nove, mas, tentarei adivinhar o do sete. Se o número gerado aleatoriamente for igual a sete, entraremos na primeira opção do <code>if</code>, que produz uma resposta errada. Então, talvez, nosso número sete deva ser chamado de <code>$wrongAnswerId</code> ("Id da resposta errada").</p>

<pre class="brush: php">$wrongAnswerId = 7;
if (rand(0, 9) == $wrongAnswerId) {
	$notAWinner = $aGame-&gt;wrongAnswer();
} else {
	$notAWinner = $aGame-&gt;wasCorrectlyAnswered();
}</pre>

<p>Nossos testes continuam passando e o código está um pouco mais expressivo. Agora que nomeamos o número sete, ele gera um novo contexto para o condicional. Podemos pensar em alguns nomes decentes para o zero e o nome. Eles são apenas parâmetros para o <code>rand()</code>, então essas variáveis poderão ser chamadas de min-algumacoisa e max-algumacoisa.</p>

<pre class="brush: php">$minAnswerId = 0;
$maxAnswerId = 9;
$wrongAnswerId = 7;
if (rand($minAnswerId, $maxAnswerId) == $wrongAnswerId) {
	$notAWinner = $aGame-&gt;wrongAnswer();
} else {
	$notAWinner = $aGame-&gt;wasCorrectlyAnswered();
}</pre>

<p>Agora o código está mais expressivo. Agora, temos IDs mínimo e máximo para respostas e um outro para a resposta errada. Mistério resolvido.</p>

<pre class="brush: php">do {

	$dice = rand(0, 5) + 1;
	$aGame-&gt;roll($dice);

	$minAnswerId = 0;
	$maxAnswerId = 9;
	$wrongAnswerId = 7;
	if (rand($minAnswerId, $maxAnswerId) == $wrongAnswerId) {
		$notAWinner = $aGame-&gt;wrongAnswer();
	} else {
		$notAWinner = $aGame-&gt;wasCorrectlyAnswered();
	}

} while ($notAWinner);</pre>

<p>Mas, perceba que o código está dentro do laço <code>do-while</code>. Precisamos reatribuir os IDs das variáveis todas as vezes? Acho que não. Tentemos colocá-las para fora do laço e ver se nossos testes continuam passando.</p>

<pre class="brush: php">$minAnswerId = 0;
$maxAnswerId = 9;
$wrongAnswerId = 7;
do {
	$dice = rand(0, 5) + 1;
	$aGame-&gt;roll($dice);

	if (rand($minAnswerId, $maxAnswerId) == $wrongAnswerId) {
		$notAWinner = $aGame-&gt;wrongAnswer();
	} else {
		$notAWinner = $aGame-&gt;wasCorrectlyAnswered();
	}

} while ($notAWinner);</pre>

<p>Sim. Os testes passaram para isso também.</p>

<p>É hora de seguirmos para o arquivo <code>Game.php</code> e procurar por constantes mágicas lá, também. Se tiver destaque de código ativado, com certeza terá constantes destacadas em alguma cor brilhante. As minhas são azuis e são bem fáceis de encontrar.</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/20527/image/for-with-magic-constant.png"/>
</figure>

<p>Encontrar a constante mágica <code class="inline">50</code>, naquele laço <code>for</code> foi muito fácil. E se olharmos para o que o código faz, descobriremos que, dentro do laço <code>for</code>, os elementos são colocados em vários vetores. Então temos algum tipo de lista, cada uma com 50 elementos. Cada lista representa uma categoria de pergunta e as variáveis são, na verdade, campos de classe, definidos mais acima como vetores. </p>

<pre class="brush: php">$this-&gt;popQuestions = array();
$this-&gt;scienceQuestions = array();
$this-&gt;sportsQuestions = array();
$this-&gt;rockQuestions = array();</pre>

<p>Então, o que o <code class="inline">50</code> representa? Aposto que você já tem algumas ideias. Nomeação é uma das tarefas mais difíceis na programação. Se você tiver mais de uma ideia e não sabe qual escolher, não se sinta envergonhado. Eu também pensei em vários nomes e estou avaliando as possibilidades para escolher o melhor deles, enquanto escrevo este parágrafo. Algo no estilo <code>$questionsInEachCategory</code> (perguntas em cada categoria) ou <code>$categorySize</code> (tamanho da categoria) ou algo parecido.</p>

<pre class="brush: php">$categorySize = 50;
for ($i = 0; $i &lt; $categorySize; $i++) {
	array_push($this-&gt;popQuestions, "Pergunta sobre Pop " . $i);
	array_push($this-&gt;scienceQuestions, ("Pergunta sobre Ciências " . $i));
	array_push($this-&gt;sportsQuestions, ("Pergunta sobre Esportes " . $i));
	array_push($this-&gt;rockQuestions, "Pergunta sobre Rock " . $i);
}</pre>

<p>Isso parece bom. Podemos deixar assim. E os testes, claro, continuam passando.</p>

<pre class="brush: php">function isPlayable() {
	return ($this-&gt;howManyPlayers() &gt;= 2);
}</pre>

<p>O que é esse dois? Tenho certeza que, nesse ponto, a resposta está clara para você. Essa é bem fácil:</p>

<pre class="brush: php">function isPlayable() {
	// número mínimo de jogadores
	$minimumNumberOfPlayers = 2;
	return ($this-&gt;howManyPlayers() &gt;= $minimumNumberOfPlayers);
}</pre>

<p>Você concorda? Se tiver alguma ideia melhor, sinta-se livre para deixar um comentário. E seus testes? Continuam passando?</p>

<p>Agora, no método <code>roll()</code>, também temos alguns números: dois, zero, onze e doze.</p>

<pre class="brush: php">if ($roll % 2 != 0)</pre>

<p>Isso está bem claro. Extrairemos essa expressão em um método, mas não neste tutorial. Ainda estamos na fase de compreensão e busca por constantes e cadeias de caracteres mágicos. E os números onze e doze? Eles estão no terceiro nível das expressões <code>if</code>. É um tanto difícil entender suas serventias. Quem sabe se olharmos nas linhas ao redor deles...</p>

<pre class="brush: php">if ($this-&gt;places[$this-&gt;currentPlayer] &gt; 11) {
	$this-&gt;places[$this-&gt;currentPlayer] = $this-&gt;places[$this-&gt;currentPlayer] - 12;
}</pre>

<p>Se a posição de algum jogador for maior ou igual a onze, então a posição desse jogador será reduzida em doze. Isso me parece o caso de quando o jogador atinge o fim do tabuleiro e deve retornar para a posição inicial. Provavelmente, posição número zero. Ou, se o tabuleiro for circular, passar pela última possibilidade o levará para a primeira posição novamente. Logo, onze deve ser o tamanho do tabuleiro. </p>

<pre class="brush: php">$boardSize = 11; // tamanho do tabuleiro
if ($this-&gt;inPenaltyBox[$this-&gt;currentPlayer]) {
	if ($roll % 2 != 0) {
		// ... //
		if ($this-&gt;places[$this-&gt;currentPlayer] &gt; $boardSize) {
			$this-&gt;places[$this-&gt;currentPlayer] = $this-&gt;places[$this-&gt;currentPlayer] - 12;
		}
		// ... //
	} else {
		// ... //
	}
} else {
	// ... //
	if ($this-&gt;places[$this-&gt;currentPlayer] &gt; $boardSize) {
		$this-&gt;places[$this-&gt;currentPlayer] = $this-&gt;places[$this-&gt;currentPlayer] - 12;
	}
// ... //
}</pre>

<p>Não esqueça de substituir os números 11 em todos os lugares dentro do método. Isso nos forçará a mover a atribuição da variável para fora das expressões <code>if</code>, logo para o primeiro nível da indentação.</p>

<p>Mas, se 11 é o tamanho do tabuleiro, o que será o doze? Subtraímos doze da atual posição, não 11. E por que não configuramos a posição para zero ao invés ed realizar uma subtração? Porque isso faria nossos testes falharem. Nossa suposição anterior, que o jogador acabaria na posição zero após que o código dentro da expressão <code>if</code> ser executado, estava errada. Digamos que o jogador esteja na posição dez e role um quatro. Quatorze é maior que 11, logo, a subtração ocorrerá. O jogador acabará na posição <code>10+4-12=2</code>.</p>

<p>Isso nos leva a outra possível nomeação para o 11 e 12. Acredito que seja muito mais apropriado chamar o 12 de <code>$boardSize</code>. Mas o que significa o 11? Talvez <code>$lastPositionOnTheBoard</code> (última posição do tabuleiro)? Um pouco grande, mas nos diz a verdade sobre a constante mágica.</p>

<pre class="brush: php">$lastPositionOnTheBoard = 11;
$boardSize = 12;
if ($this-&gt;inPenaltyBox[$this-&gt;currentPlayer]) {
	if ($roll % 2 != 0) {
		// ... //
		if ($this-&gt;places[$this-&gt;currentPlayer] &gt; $lastPositionOnTheBoard) {
			$this-&gt;places[$this-&gt;currentPlayer] = $this-&gt;places[$this-&gt;currentPlayer] - $boardSize;
		}
		// ... //
	} else {
		// ... //
	}
} else {
	// ... //
	if ($this-&gt;places[$this-&gt;currentPlayer] &gt; $lastPositionOnTheBoard) {
		$this-&gt;places[$this-&gt;currentPlayer] = $this-&gt;places[$this-&gt;currentPlayer] - $boardSize;
	}
// ... //
}</pre>

<p>Eu sei, eu sei! Há duplicação de código aqui, É um pouco óbvio, especialmente com o resto do código escondido. Mas, lembre-se, estávamos atrás das constantes mágicas. Haverá tempo para a parte do código duplicado, mas não agora.</p>

<h2>Conclusão</h2>

<p>Deixei uma constante mágica no código. Você foi capaz de encontrá-la? Se olhar no código finalizado, ela estará alterada, mas, claro, isso seria trapaça. Boa sorte na busca e obrigado pela leitura.</p>