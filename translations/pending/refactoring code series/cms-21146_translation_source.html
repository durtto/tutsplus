<h1>Refatorando Código Legado: Parte 4 - Nossos Primeiros Testes Unitários</h1>

<p>Código velho. Código feio. Código complicado. Código macarrônico. Código sem sentido. Em outras palavras, <em>Código Legado</em>. Esta é uma série que ajudará você a trabalhar e lidar com esse tipo de código.</p>

<p>Um dos momentos chave da refatoração de um código totalmente legado é quando começamos a extração desses pequenos trechos de código e escrevemos testes unitários para esses trechos. Mas isso pode ser bem difícil, especialmente, quando se tem código que é escrito de tal forma que torna difícil a compilação ou mesmo a execução, caso partes dele estejam faltando. Não podemos realizar <em>cirurgias</em> grandes de forma segura em um código que mal entendemos e só temos o <em>resultado esperado</em> para nos apoiar. Felizmente, existem algumas técnicas que podem nos ajudar nisso.</p>

<h2>O Que É um Teste Unitário?</h2>

<p>Através da história dos testes automatizados, nos últimos vinte e poucos anos, o termo <em>Teste Unitário</em> foi definido de várias formas. Inicialmente, relacionava-se ao escopo do código exercitado dentro de um teste. Um teste unitário era um teste que testava a menor unidade possível de uma linguagem de programação em particular.</p>

<p>Nesse sentido, para nosso código PHP, um teste unitário é aquele teste que exercita uma única função ou método. Quando programamos com o paradigma orientado a objetos, nossas funções são organizadas em classes. Todos os testes associados a uma única classe, geralmente, são chamados de <em>Caso de Teste</em>.</p>

<p>Existe cerca de 25 outras definições para a expressão <em>Teste Unitário</em>, então, não falaremos sobre cada um deles. Embora essas definições possam ser bem diferentes, todas elas possuem duas coisas em comum, o que nos leva a provável definição mais aceita dentre todas.</p>

<blockquote>Um Teste Unitário é um teste que é executado em milissegundos e testa um trecho de código de forma isolada.</blockquote>

<p>Devemos atentar para duas palavras-chaves nessa definição: milissegundos - nossos testes devem ocorrer muito, muito rápido; e isolação - devemos testar nosso código o mais isolado possível. Essas duas palavras-chave andam juntas, porque, para fazer os testes executarem masi rápido, precisamos reduzir seus escopos. Banco de dados, comunicação de rede, interfaces de usuário... Todas elas são muito lentas para serem testadas dessa forma. Precisamos encontrar e isolar um pequeno trecho de código, para que possamos compilar (se necessário) e executar esse código na casa dos milissegundos, isso é, em menos de dez milissegundos, porque, acima disso, já seria na ordem dos centissegundos. Nosso <em>framework</em> de testes adicionará um pouco de sobrecarga sobre a execução do código puro, mas é algo negligível. </p>

<h2>Identificando Código Que Precisam de Testes Unitários</h2>

<h3>Encontrando Métodos Isolados</h3>

<p>Se a estrutura do código permitir, é recomendado começar criando testes para qualquer código que possamos testar de verdade. Isso nos ajudará na cobertura do código e também nos forçará a concentramo-nos em pequenos pedaços de código. Lembre-se, ao refatorar, não queremos alterar comportamento. Na verdade, nesse passo inicial, não queremos alterar nosso código em produção de qualquer maneira, se possível.</p>

<p>Precisamos analisar nossos três arquivos, para ver o que podemos testar ou não.</p>

<p>Basicamente, o arquivo <code>GameRunner.php</code> não tem lógica. Nós o criamos apenas para delegação. Poderíamos testá-lo? Devemos testá-lo? Não, não devemos. Mesmo que alguns métodos possam ser testados, tecnicamente falando, se não há lógica neles, então, não precisamos testá-los.</p>

<p>Já com o arquivo <code>RunnerFunctions.php</code> temos outra história. O método <code>run()</code> é bem grande, executando completamente o sistema. Isso não é algo que possamos testar facilmente. Além disso, não possui qualquer valor de retorno, apenas imprimindo na tela, de modo que precisamos capturá-lo para que possamos comparar. Isso não é típico de Testes Unitários. Por outro lado, o método <code>isCurrentAnswerCorrect()</code> retorna um simples <code>true</code> ou <code>false</code>, baseado em algumas condições. Podemos testá-lo?</p>

<pre class="brush: php">function isCurrentAnswerCorrect() {
	$minAnswerId = 0;
	$maxAnswerId = 9;
	$wrongAnswerId = 7;
	return rand($minAnswerId, $maxAnswerId) != $wrongAnswerId;
}</pre>

<p>Nós já sabemos que esse código gera um código aleatória e compara seu resultado ao ID do número errado.</p>

<p><i>Passo 1</i> - vá até o arquivo <code>GoldenMasterTest.php</code> e marque todos os testes para serem saltados. Não queremos executá-los agora. Assim que começarmos a criar os testes unitários, raramente executaremos nosso <em>resultado esperado</em>. De acordo que criarmos novos testes e não modificarmos o código de produção, respostas rápidas são muito mais importantes.</p>

<p><i>Passo 2</i> - crie um novo arquivo de teste, <code>RunnerFunctionsTest.php</code>, em nosso diretório <code>Test</code>, junto do arquivo <code>GoldenMasterTest.php</code>. Agora, pense no teste mais simples que você pode escrever. Qual o mínimo necessário para fazê-lo executar? Pois bem, é algo mais ou menos assim:</p>

<pre class="brush: php">require_once __DIR__ . '/../trivia/php/RunnerFunctions.php';

class RunnerFunctionsTest extends PHPUnit_Framework_TestCase {

	function testItCanFindCorrectAnswer() {

	}

}</pre>

<p>Requeremos o arquivo <code>RunnerFunctions.php</code>, para testar se podemos incluí-lo sem produzir quaisquer erros. O resto do código é algo básico de qualquer teste, apenas uma classe esqueleto e uma função de teste vazia. Mas, e agora? O que faremos depois? Você sabe como fazer a função <code>rand()</code> retornar o que queremos? Eu não sei, ainda. Então, investiguemos como ela está funcionando.</p>

<p>Sabemos como alimentar o gerador aleatório, então, que tal alimentá-lo com alguns números? Será que funcionará? Podemos escrever códigos nos nossos testes para descobrirmos se algo funciona.</p>

<pre class="brush: php">function testItCanFindCorrectAnswer() {

	srand(0);
	var_dump(rand(0,9));
	srand(1);
	var_dump(rand(0,9));
	srand(2);
	var_dump(rand(0,9));
	srand(3);
	var_dump(rand(0,9));
	srand(4);
	var_dump(rand(0,9));

}</pre>

<p>Também sabemos que os IDs das nossas perguntas estão entre zero e novo. O código acima produz o retorno abaixo.</p>

<pre class="brush: bash">int(8)
int(8)
int(7)
int(5)
int(9)</pre>

<p>Bem, isso não parece muito óbvio. Na verdade, não consigo enxergar qualquer lógica para que possamos determinar os valores que a função <code>rand()</code> produzirá. Precisaremos alterar o nosso código de produção, para que possamos injetar os valores que precisamos.</p>

<h3>Dependências e Injeção de Dependência</h3>

<p>Quando a maioria das pessoas fala sobre "dependência" eles estão pensando na conexão entre as classes. Esse é o caso mais comum, principalmente, na programação orientada a objetos. Mas, que tal generalizarmos um pouco esse termo? Esqueça as classes e objetos. Concentre-se apenas no significado de "dependência". Do que o nosso método <code>rand(min,max)</code> depende? Ele depende de dois valores, um mínimo e um máximo.</p>

<p>Podemos controlar o método <code>rand()</code> através desses dois parâmetros? O <code>rand()</code> não retorna o mesmo número se tanto o mínimo e o máximo forem o mesmo número? Vejamos.</p>

<pre class="brush: php">function testItCanFindCorrectAnswer() {

	var_dump(rand(0,0));
	var_dump(rand(1,1));
	var_dump(rand(2,2));
	var_dump(rand(3,3));
	var_dump(rand(4,4));

}</pre>

<p>Se estivermos certo, cada linha deve retornar um número, de zero a quatro.</p>

<pre class="brush: bash">int(0)
int(1)
int(2)
int(3)
int(4)</pre>

<p>Isso parece bem previsível para mim. Ao passar o mesmo número para os valores mínimo e máximo da função <code>rand()</code>, podemos ter certeza que geraremos um certo número. Agora, como faremos isso com nossa função? Ela não possui parâmetro!</p>

<p>Provavelmente, a forma mais comum de injetar dependências em um método é usar parâmetros com valores padrão. Isso preservará a funcionalidade atual do método, mas nos permite controlar seu fluxo ao testá-lo.</p>

<pre class="brush: php">function isCurrentAnswerCorrect($minAnswerId = 0, $maxAnswerId = 9) {
	$wrongAnswerId = 7;
	return rand($minAnswerId, $maxAnswerId) != $wrongAnswerId;
}</pre>

<p>Modificando o método <code>isCurrentAnswerCorrect()</code> dessa forma preservará o comportamento atual e permite-nos testá-lo ao mesmo tempo. Você pode reabilitar seu "retorno esperado" e executá-lo, agora. O código de produção foi alterado, precisamos garantir que não o quebramos.</p>

<p>A forma como <code>isCurrentAnswerCorrect()</code> está agora, para testá-la, basta enviarmos 10 valores para cada possível número retornável por <code>rand()</code>.</p>

<pre class="brush: php">function testItCanFindCorrectAnswer() {

	$this-&gt;assertTrue(isCurrentAnswerCorrect(0,0));
	$this-&gt;assertTrue(isCurrentAnswerCorrect(1,1));
	$this-&gt;assertTrue(isCurrentAnswerCorrect(2,2));
	$this-&gt;assertTrue(isCurrentAnswerCorrect(3,3));
	$this-&gt;assertTrue(isCurrentAnswerCorrect(4,4));
	$this-&gt;assertTrue(isCurrentAnswerCorrect(5,5));
	$this-&gt;assertTrue(isCurrentAnswerCorrect(6,6));
	$this-&gt;assertFalse(isCurrentAnswerCorrect(7,7));
	$this-&gt;assertTrue(isCurrentAnswerCorrect(8,8));
	$this-&gt;assertTrue(isCurrentAnswerCorrect(9,9));

}</pre>

<p>Essa função teste foi construída para executar nossos testes após cada linha. Agora que nossos testes estão muito rápido, podemos executá-los quase continuamente. Na verdade, existe <a href="https://code.tutsplus.com/tutorials/automatic-testing-for-tdd-with-php--net-26395">ferramentas para executar nossos testes tão logo um arquivo seja alterado</a> e ouvi falar sobre programadores que executam seus testes continuamente e apenas prestam atenção no estado da base ao fim de cada comando. De acordo com que você programa, você sabe o que esperar. Quando o teste não retorna verde quando você achava que deveria retornar, você fez algo errado. A aparência do retorno deles é tão firme que é quase certo que algo aconteceu na última linha ou comando escrita.</p>

<p>Embora isso parece um desenvolvimento voltado a teste extremo, acho que seja especialmente útil ao desenvolver seus algoritmos. Pessoalmente, prefiro executar meus testes ao apertar algum atalho, uma única tecla de atalho. E, como os testes me <em>ajudam</em> a desenvolver meus programas, meu atalho para executar meus testes é o <strong>F1</strong>.</p>

<p>Voltemos ao trabalho. Aquele teste, com dez assertivas, executa em aproximadamente, 66ms, cerca de 6.6ms por assertiva. Cada assertiva invoca e executa um trecho do seu código. Isso parece estar dentro do que definimos para testes unitários no início do nosso tutorial.</p>

<p>Você percebeu o <code>assertFalse()</code> para a do número? Aposto que metade de vocês não percebeu. Está escondido no meio de todas as outras assertivas. Acredito que ela merece seu próprio teste, para que deixemos explícito caso único da resposta errada.</p>

<pre class="brush: php">function testItCanFindCorrectAnswer() {
	$this-&gt;assertTrue(isCurrentAnswerCorrect(0, 0));
	$this-&gt;assertTrue(isCurrentAnswerCorrect(1, 1));
	$this-&gt;assertTrue(isCurrentAnswerCorrect(2, 2));
	$this-&gt;assertTrue(isCurrentAnswerCorrect(3, 3));
	$this-&gt;assertTrue(isCurrentAnswerCorrect(4, 4));
	$this-&gt;assertTrue(isCurrentAnswerCorrect(5, 5));
	$this-&gt;assertTrue(isCurrentAnswerCorrect(6, 6));
	$this-&gt;assertTrue(isCurrentAnswerCorrect(8, 8));
	$this-&gt;assertTrue(isCurrentAnswerCorrect(9, 9));
}

function testItCanFindWrongAnser() {
	$this-&gt;assertFalse(isCurrentAnswerCorrect(7, 7));
}</pre>

<h3>Refatorando Testes</h3>

<p>Como estamos numa peregrinação por refatoração, por tornar o código melhor, mais fácil de entender, não podemos esquecer sobre nossos testes. Eles são tão importantes quanto códigos de produção. Precisamos manter nossos códigos limpos e fáceis de entender também. Precisamos refatorar nossos testes e devemos fazê-lo tão logo observemos algo errado com eles e apenas quando eles estiverem verdes. Se tivermos um teste verde e o refatoramos, e ele acaba vermelho, fizemos algo errado na refatoração. Podemos desfazer alguns passos e tentar novamente.</p>

<p>Poderíamos extrair os números em um vetor e usá-lo para gerar as respostas corretas.</p>

<pre class="brush: php">function testItCanFindCorrectAnswer() {
	$correctAnserIDs = [0, 1, 2, 3, 4, 5, 6, 8, 9];
	foreach ($correctAnserIDs as $id) {
		$this-&gt;assertTrue(isCurrentAnswerCorrect($id, $id));
	}
}</pre>

<p>Isso faz o teste passar, mas introduz um pouco de lógica. Talvez possamos extrair uma assertiva customizada. Pode ser que seja um pouco extremo para um teste tão simples, mas é uma boa oportunidade para entendermos o conceito.</p>

<pre class="brush: php">function testItCanFindCorrectAnswer() {
	$correctAnserIDs = [0, 1, 2, 3, 4, 5, 6, 8, 9];
	$this-&gt;assertAnswersAreCorrectFor($correctAnserIDs);
}

function testItCanFindWrongAnser() {
	$this-&gt;assertFalse(isCurrentAnswerCorrect(7, 7));
}

private function assertAnswersAreCorrectFor($correctAnserIDs) {
	foreach ($correctAnserIDs as $id) {
		$this-&gt;assertTrue(isCurrentAnswerCorrect($id, $id));
	}
}</pre>

<p>Isso nos ajudou de duas formas: Primeiro, movemos para fora a lógica sobre iterar e verificar cada elemento de um vetor para um método privado. Como, geralmente, mantemos nossos métodos privados ao final de nossas classes, fora de vista, fora do caminho da lógica de alto nível nos métodos públicos, conseguimos aumentar a abstração de nossos testes. No método do teste não nos importamos sobre como as respostas são verificadas. Só nos preocupamos sobre os IDs que devem representar as respostas corretas. A segunda vantagem é dividir a implementação da preparação. Manter os IDs das respostas corretas no teste nos ajudou a separar os detalhes da implementação do pressuposto que precisamos testar.</p>

<h3>Testando por Dependências de Código da Produção</h3>

<p>Um dos erros mais comuns que qualquer um de nós comete ao criar teste é repetir o que existe no código de produção. Isso é um caso tanto de duplicação de código quanto de dependência escondida, geralmente, em relação a valores ou constantes. Em nosso caso, a dependência está no ID da resposta que representa a resposta errada.</p>

<p>Mas, como provar essa dependência? A primeira vista, parece apenas uma duplicação de código simples de um único valor. Para responder seu dilema, pergunte-se o seguinte: <em>"Os meus testes deveriam falhar se resolver alterar o ID da resposta errada?"</em>. Claro que a resposta é não. Alterar uma simples constante no código da produção não afetará o comportamento ou a lógica e, assim, os testes não devem falhar.</p>

<p>Isso parece interessante! Mas, como conseguir? Bem, a forma mais simples é expor a variável em questão como uma variável pública de classe, preferivelmente como uma variável estática ou constante. Em nosso caso, como não temos uma classe, podemos apenar torná-la uma variável global ou uma constante.</p>

<pre class="brush: php">include_once __DIR__ . '/Game.php';

const WRONG_ANSWER_ID = 7;

function isCurrentAnswerCorrect($minAnswerId = 0, $maxAnswerId = 9) {
	return rand($minAnswerId, $maxAnswerId) != WRONG_ANSWER_ID;
}

function run() {
	// ... //
}</pre>

<p>Primeiro, modifique o arquivo <code>RunnerFunctions.php</code> para que a função <code>isCurrentAnswerCorrect()</code> passe a usar a constante ao invés de uma variável local. Então execute seus testes unitários. Isso garante que nossas mudanças no código de produção não atrapalharam. É hora do teste.</p>

<pre class="brush: php">	function testItCanFindWrongAnswer() {
		$this-&gt;assertFalse(isCurrentAnswerCorrect(WRONG_ANSWER_ID, WRONG_ANSWER_ID));
	}
</pre>

<p>Modifique o teste <code>testItCanFindWrongAnswer()</code> para usar a mesma constante. Como o arquivo <code>RunnerFunctions.php</code> foi incluído no começo do arquivo de teste, a constante declarada estará acessível para o teste também.</p>

<h3>Refatorando Testes (Novamente)</h3>

<p>Agora que dependemos da constante <code>WRONG_ANSWER_ID</code> para nosso teste <code>testItCanFindWrongAnswer()</code>, não deveríamos refatorar nossos testes, de modo que <code>testItCanFindCorrectAnswer()</code> também dependa da mesma constate? Bem, devemos sim. Não apenas fará nossos testes serem mais fáceis de entender como os tornará mais robustos. Sim, uma vez que, se selecionarmos um ID para a resposta errada que conste na lista de respostas corretas do teste, esse caso em particular falhar o teste, mesmo que o código de produção esteja correto.</p>

<pre class="brush: php">class RunnerFunctionsTest extends PHPUnit_Framework_TestCase {

	function testItCanFindCorrectAnswer() {
		$correctAnserIDs = $this-&gt;getGoodAnswerIDs();
		$this-&gt;assertAnswersAreCorrectFor($correctAnserIDs);
	}

	private function getGoodAnswerIDs() {
		return [0, 1, 2, 3, 4, 5, 6, 8, 9];
	}

}</pre>

<p>Embora ter os IDs das respostas corretas na função teste em si fosse uma boa ideia, ao alteramos nosso teste para depender mais e mais dos valores providos pelo código de produção, também queremos esconder os detalhes sobre os números. O primeiro passo é aplicar uma refatoração de <em>Extração de Método</em> e colocá-los em seu próprio método.</p>

<pre class="brush: php">class RunnerFunctionsTest extends PHPUnit_Framework_TestCase {

	function testItCanFindCorrectAnswer() {
		$correctAnserIDs = $this-&gt;getGoodAnswerIDs();
		$this-&gt;assertAnswersAreCorrectFor($correctAnserIDs);
	}

	private function getGoodAnswerIDs() {
		return array_diff(range(0,9), [WRONG_ANSWER_ID]);
	}

}</pre>

<p>Alteramos o método <code>getGoodAnswerIDs()</code> de forma significativa. Primeiro de tudo, geramos uma lista usando a função <code>range()</code> ao invés de digitar todos os IDs possíveis, manualmente. Depois disso, subtraímos do vetor, o ID da resposta errada, <code>WRONG_ANSWER_ID</code>. Agora, a lista de IDs das respostas corretas também é independente do valor que configuramos para o ID da resposta errada. Mas, será que isso basta? E os valores mínimos e máximos para os IDs? Não podemos extraí-los também? Bem, vejamos se sim.</p>

<pre class="brush: php">include_once __DIR__ . '/Game.php';

const WRONG_ANSWER_ID = 7;
const MIN_ANSWER_ID = 0;
const MAX_ANSWER_ID = 9;

function isCurrentAnswerCorrect($minAnswerId = MIN_ANSWER_ID, $maxAnswerId = MAX_ANSWER_ID) {
	return rand($minAnswerId, $maxAnswerId) != WRONG_ANSWER_ID;
}

function run() {
	// ... //
}</pre>

<p>Parece tudo certo. As constantes foram usadas apenas como valores padrão para os parâmetro da função <code>isCurrentAnswerCorrect()</code>. Isso ainda nos permite injetar os valores requeridos durante os testes, além de tornar mais claro o que cada parâmetro significa. Como um ótimo efeito colateral, um bloco, logo no topo do arquivo, com as constantes passou a chamar atenção para os valores chave que nosso arquivo <code>RunnerFunctions.php</code> usa. Legal!</p>

<p>Apenas não esqueça de reabilitar a função de teste <code>testOutputMatchesGoldenMaster()</code> em nosso <em>resultado esperado</em>. As constantes introduzidas são apenas usadas nos testes do <em>resultado esperado</em>. Nossos testes criam atalhos para esses valores.</p>

<p>Agora, precisamos atualizar nosso teste unitário para usar as constantes.</p>

<pre class="brush: php">class RunnerFunctionsTest extends PHPUnit_Framework_TestCase {

	function testItCanFindCorrectAnswer() {
		$correctAnserIDs = $this-&gt;getGoodAnswerIDs();
		$this-&gt;assertAnswersAreCorrectFor($correctAnserIDs);
	}

	private function getGoodAnswerIDs() {
		return array_diff(range(MIN_ANSWER_ID,MAX_ANSWER_ID), [WRONG_ANSWER_ID]);
	}

}</pre>

<p>Simples e fácil. Tivemos de mudar, apenas, os parâmetros do método <code>range()</code>. </p>

<p>O último passo que podemos fazer com nosso teste é limpar a bagunça que deixamos no nosso método <code>testItCanFindCorrectAnswer()</code>.</p>

<pre class="brush: php">function testItCanFindCorrectAnswer() {
	$correctAnserIDs = $this-&gt;getGoodAnswerIDs();
	$this-&gt;assertAnswersAreCorrectFor($correctAnserIDs);
}</pre>

<p>Podemos observar dois grandes problemas com esse código: Primeiro, inconsistência na nomenclatura. Uma vez chamamos as respostas de <em>correct</em> e depois chamamos de <em>good</em>. Devemos escolher uma das duas nomenclaturas, uma vez que correto (<em>correct</em>) é o oposto de errado (<em>wrong</em>) e bom (<em>good</em>) é o oposto de ruim (<em>bad</em>).</p>

<pre class="brush: php">class RunnerFunctionsTest extends PHPUnit_Framework_TestCase {

	function testItCanFindCorrectAnswer() {
		$correctAnserIDs = $this-&gt;getCorrectAnswerIDs();
		$this-&gt;assertAnswersAreCorrectFor($correctAnserIDs);
	}

	private function getCorrectAnswerIDs() {
		return array_diff(range(MIN_ANSWER_ID,MAX_ANSWER_ID), [WRONG_ANSWER_ID]);
	}

}</pre>

<p>Renomeamos nosso método privado de acordo com os motivos acima. Mas isso não é o suficiente. Precisamos resolver o segundo problema. Atribuímos o valore de retorno de um método privado a uma variável, só para usá-la na próxima linha. E esse é o único caso de uso dessa variável. Em nosso caso, a variável estava lá para prover um esclarecimento extra sobre o que o vetor de números significava. Ela teve seu uso e escopo. Mas, agora que temos um método com, praticamente, o mesmo nome, expressando o mesmo conceito, a variável perde sua utilidade. Essa é uma atribuição desnecessária.</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/21146/image/inline-variable-phpstorm.png"/>
</figure>

<p>Podemos usar a refatoração de <em>variável em linha</em> para remover a variável e invocar o método diretamente ao invés de usar a variável na linha seguinte.</p>

<pre class="brush: php">class RunnerFunctionsTest extends PHPUnit_Framework_TestCase {

	function testItCanFindCorrectAnswer() {
		$this-&gt;assertAnswersAreCorrectFor($this-&gt;getCorrectAnswerIDs());
	}

	private function getCorrectAnswerIDs() {
		return array_diff(range(MIN_ANSWER_ID,MAX_ANSWER_ID), [WRONG_ANSWER_ID]);
	}

}</pre>

<p>O mais legal disso tudo é que começamos com apenas duas linhas de código que não eram tão claras e poluíam com duplicação de código e dependência oculta. Após algumas mudanças, acabamos com as mesmas quantidades de linhas, mas acabamos nossa dependência nos IDs. Isso não é legal?</p>

<h2>Dividindo a Execução</h2>

<p>Já acabamos com o arquivo <code>RunnerFunctions.php</code>? Bem, se pudermos encontrar um <code>if()</code> é porque existe alguma lógica. Se existir alguma lógica é necessário teste unitário para verificá-la. E temos um <code>if()</code> no laço <code>do-while()</code> do nosso método <code>run()</code> loop. É hora de usarmos a ferramenta de extração de método da nossa IDE e realizar alguns testes.</p>

<p>Mas, que trecho de código devemos extrair? A primeira vista, extrair apenas o condicional parece uma boa ideia. Isso nos leva ao código abaixo.</p>

<pre class="brush: php">function run() {
	$notAWinner;

	$aGame = new Game();

	$aGame-&gt;add("Chet");
	$aGame-&gt;add("Pat");
	$aGame-&gt;add("Sue");

	do {
		$dice = rand(0, 5) + 1;
		$aGame-&gt;roll($dice);

		$notAWinner = getNotWinner($aGame);

	} while ($notAWinner);
}

function getNotWinner($aGame) {
	if (isCurrentAnswerCorrect()) {
		$notAWinner = $aGame-&gt;wasCorrectlyAnswered();
		return $notAWinner;
	} else {
		$notAWinner = $aGame-&gt;wrongAnswer();
		return $notAWinner;
	}
}</pre>

<p>Embora parece bom o suficiente para algo gerado por uma ferramenta de nossa IDE, tem algo que me incomoda. O objeto <code>aGame</code> é usdo tanto pelo <code>do-while</code> quanto no método extraído. Que tal fazermos isso?</p>

<pre class="brush: php">function run() {
	$notAWinner;

	$aGame = new Game();

	$aGame-&gt;add("Chet");
	$aGame-&gt;add("Pat");
	$aGame-&gt;add("Sue");

	do {
		$dice = rand(0, 5) + 1;
		$notAWinner = getNotWinner($aGame, $dice);

	} while ($notAWinner);
}

function getNotWinner($aGame, $dice) {
	$aGame-&gt;roll($dice);

	if (isCurrentAnswerCorrect()) {
		$notAWinner = $aGame-&gt;wasCorrectlyAnswered();
		return $notAWinner;
	} else {
		$notAWinner = $aGame-&gt;wrongAnswer();
		return $notAWinner;
	}
}
</pre>

<p>Essa solução remove o objeto <code>aGame</code> do laço. Entretanto, introduz outros tipos de problemas. A contagem de parâmetros aumenta. Agora, precisamos enviar <code>$dice</code>. Embora seja poucos parâmetros, dois apenas, o que não levanta maiores preocupações, precisamos nos preocupar sobre como esses parâmetros são usados no método em si. O parâmetro <code>$dice</code> é usado apenas quando invocamos o método <code>roll()</code> do objeto <code>aGame</code>. Embora o método <code>roll()</code> tenha um grande significado dentro da classe <code>Game</code>, não é aquele que decide se temos um vencedor ou não. Ao analizamos a classe <code>Game</code>, podemos concluir que o estado de vencedor só pode ser alcançado ao invocarmos <code>wasCorrectlyAnswered()</code>. Isso é estranho e destaca alguns problemas sérios de nomeação na classe <code>Game</code>, que precisamos corrigir em classes futuras.</p>

<p>Com base em todas essas observações, o mais correto é seguir com a primeira versão do nosso método extraído.</p>

<pre class="brush: php">function getNotWinner($aGame) {
	if (isCurrentAnswerCorrect()) {
		$notAWinner = $aGame-&gt;wasCorrectlyAnswered();
		return $notAWinner;
	} else {
		$notAWinner = $aGame-&gt;wrongAnswer();
		return $notAWinner;
	}
}</pre>

<p>Podemos acreditar na nossa IDE e, apenas olhando para o código, podemos ter certeza que nada saiu errado. Se estiver incerto disso, basta executar o <em>resultado esperado</em>. Agora, foquemos na criação de alguns testes para esse lindo método.</p>

<pre class="brush: php">function testItCanTellIfThereIsNoWinnerWhenACorrectAnswerIsProvided() {}</pre>

<p>Cheguei a esse nome, mostrando no nome do método aquilo que queria testar. É muito importante nomear seus testes em relação aos comportamentos que eles deveriam testar e não em relação aquilo que eles farão. Isso ajuda outras pessoas, ou você mesmo futuramente, entenderem o que aquele pequeno trecho de código deveria fazer.</p>

<p>Mas temos um problema. Nossos métodos precisam de um objeto. Precisamos executá-lo mais ou menos assim:</p>

<pre class="brush: php">function testItCanTellIfThereIsNoWinnerWhenACorrectAnswerIsProvided() {
	$aGame = ???
	getNotWinner($aGame);
}</pre>

<p>Precisamos de um objeto <code>$aGame</code> do tipo <code>Game</code>. Mas estamos realizando um teste unitário, não queremos criar e usar a classe <code>Game</code> real, complexa e mal entendida. Isso nos leva ao novo capítulo de testes, que falaremos uma outra lição: <em>Simulação, Substituição e Imitação</em>. Elas todas são técnicas para criar e testar objetos, usando outros objetos que se comportam de maneira pré-definida. Embora usar um <em>framework</em> ou mesmo as capacidades embutidas do PHPUnit possa ajudar, com nosso conhecimento atual, para nosso simples teste, podemos realizar algo bem simples que muitas pessoas esquecem.</p>

<p>Bastar criar uma classe parecida com <code>Game</code>, dentro do nosso arquivo de testes e definir nela apenas os dois métodos que estamos interessados. É muito simples.</p>

<pre class="brush: php">class RunnerFunctionsTest extends PHPUnit_Framework_TestCase {

	// ... //

	function testItCanTellIfThereIsNoWinnerWhenACorrectAnswerIsProvided() {
		$aGame = new FakeGame();
		getNotWinner($aGame);
	}

	// ... //

}

class FakeGame {

	function wasCorrectlyAnswered() {

	}

	function wrongAnswer() {

	}
}
</pre>

<p>Isso permite nosso teste passar e ainda estamos na zona dos milissegundos. Perceba que os dois testes pulados são os responsáveis pelo <em>resultado esperado</em>.</p>

<pre class="brush: bash">Time: 43 ms, Memory: 3.00Mb

OK, but incomplete or skipped tests!
Tests: 5, Assertions: 10, Skipped: 2.</pre>

<p>Mesmo que tenhamos nomeado nossa classe com um nome diferente de <code>Game</code>, uma vez que não podemos declarar uma mesma classe duas vezes, o código é bem simples. Apenas definimos os dois métodos que estamos interessados. O próximo passo é retornar algo de verdade e testá-lo. Mas isso pode ser um pouco mais difícil por conta dessa linha de código:</p>

<pre class="brush: php">if (isCurrentAnswerCorrect())</pre>

<p>Nosso método invoca <code>isCurrentAnswerCorrect()</code> sem qualquer parâmetro. Isso é ruim para nós. Não podemos controlar seu retorno. Ele, simplesmente, gerará números aleatórios. Precisamos refatorar nosso código um pouco para podermos continuar. Precisamos mover a invocação desse método para dentro do laço e passar seu resultado como parâmetro para <code>getNotWinner()</code>. Isso permitirá controlar o resultado da expressão na declaração <code class="inline">if</code> acima, controlando, assim, o caminho pelo qual nosso código passará. Para nosso primeiro teste, precisamos que ele acesse o <code class="inline">if</code> e invoque o método <code>wasCorrectlyAnswered()</code>.</p>

<pre class="brush: php">function run() {

	// ... //

	do {
		$dice = rand(0, 5) + 1;
		$aGame-&gt;roll($dice);

		$notAWinner = getNotWinner($aGame, isCurrentAnswerCorrect());

	} while ($notAWinner);
}

function getNotWinner($aGame, $isCurrentAnswerCorrect) {
	if ($isCurrentAnswerCorrect) {
		$notAWinner = $aGame-&gt;wasCorrectlyAnswered();
		return $notAWinner;
	} else {
		$notAWinner = $aGame-&gt;wrongAnswer();
		return $notAWinner;
	}
}</pre>

<p>Agora que temos controle, todas as dependências estão separadas. É hora dos testes.</p>

<pre class="brush: php">function testItCanTellIfThereIsNoWinnerWhenACorrectAnswerIsProvided() {
	$aGame = new FakeGame();
	$isCurrentAnswerCorrect = true;
	$this-&gt;assertTrue(getNotWinner($aGame, $isCurrentAnswerCorrect));
}</pre>

<p>Este teste passou. Isso é ótimo. Retornamos <code>true</code> do método sobrescrito, claro.</p>

<pre class="brush: php">function wasCorrectlyAnswered() {
	return true;
}</pre>

<p>Precisamos testar o outro caminho do <code>if()</code> também.</p>

<pre class="brush: php">function testItCanTellIfThereIsNoWinnerWhenAWrongAnswerIsProvided() {
	$aGame = new FakeGame();
	$isCurrentAnswerCorrect = false;
	$this-&gt;assertFalse(getNotWinner($aGame, $isCurrentAnswerCorrect));
}</pre>

<p>Apenas precisamos testar por um valor <code class="inline">false</code>, para que possamos diferenciar entre os coisos de forma mais fácil.</p>

<pre class="brush: php">class FakeGame {

	function wasCorrectlyAnswered() {
		return true;
	}

	function wrongAnswer() {
		return false;
	}
}</pre>

<p>E nossa classe <code>FakeGame</code> foi modificada de acordo.</p>

<h2>Limpeza Final</h2>

<h3>Refatorando o Método Extraído</h3>

<p>Estamos quase prontos. Desculpe por tornar esse tutorial tão extenso, espero que esteja curtindo e não tenha dormido. Precisamos de algumas mudanças finais antes de concluirmos o arquivo <code>RunnerFunctions.php</code> e seus testes.</p>

<pre class="brush: php">function getNotWinner($aGame, $isCurrentAnswerCorrect) {
	if ($isCurrentAnswerCorrect) {
		$notAWinner = $aGame-&gt;wasCorrectlyAnswered();
		return $notAWinner;
	} else {
		$notAWinner = $aGame-&gt;wrongAnswer();
		return $notAWinner;
	}
}</pre>

<p>Há algumas atribuições em nosso método e deveríamos reduzi-las. Nossos testes unitários devem tornar essas mudanças bem mais fáceis.</p>

<pre class="brush: php">function getNotWinner($aGame, $isCurrentAnswerCorrect) {
	if ($isCurrentAnswerCorrect) {
		return $aGame-&gt;wasCorrectlyAnswered();
	} else {
		return $aGame-&gt;wrongAnswer();
	}
}</pre>

<p>Aplicamos a refatoração de variável em linha e acabamos com as atribuições. Os testes ainda passam e ainda estamos abaixo dos 100ms para todos os testes unitários juntos. Digo que isso é bem legal.</p>

<h3>Refatorando Testes (De Novo e Outra Vez)</h3>

<p>Sim, sim, também podemos tornar nossos testes um pouco melhores. Uma vez que temos apenas algumas poucas linhas de código, nossas refatorações serão bem fáceis. O problema está no código abaixo.</p>

<pre class="brush: php">function testItCanTellIfThereIsNoWinnerWhenACorrectAnswerIsProvided() {
	$aGame = new FakeGame();
	$isCurrentAnswerCorrect = true;
	$this-&gt;assertTrue(getNotWinner($aGame, $isCurrentAnswerCorrect));
}

function testItCanTellIfThereIsNoWinnerWhenAWrongAnswerIsProvided() {
	$aGame = new FakeGame();
	$isCurrentAnswerCorrect = false;
	$this-&gt;assertFalse(getNotWinner($aGame, $isCurrentAnswerCorrect));
}</pre>

<p>Duplicamos código ao invocar <code>new FakeGame()</code> em cada método. Hora para refatoração de extração de método.</p>

<pre class="brush: php">function testItCanTellIfThereIsNoWinnerWhenACorrectAnswerIsProvided() {
	$aGame = $this-&gt;aFakeGame();
	$isCurrentAnswerCorrect = true;
	$this-&gt;assertTrue(getNotWinner($aGame, $isCurrentAnswerCorrect));
}

function testItCanTellIfThereIsNoWinnerWhenAWrongAnswerIsProvided() {
	$aGame = $this-&gt;aFakeGame();
	$isCurrentAnswerCorrect = false;
	$this-&gt;assertFalse(getNotWinner($aGame, $isCurrentAnswerCorrect));
}</pre>

<p>Isso torna a variável <code>$aGame</code> totalmente inútil. Hora da variável em linha.</p>

<pre class="brush: php">function testItCanTellIfThereIsNoWinnerWhenACorrectAnswerIsProvided() {
	$isCurrentAnswerCorrect = true;
	$this-&gt;assertTrue(getNotWinner($this-&gt;aFakeGame(), $isCurrentAnswerCorrect));
}

function testItCanTellIfThereIsNoWinnerWhenAWrongAnswerIsProvided() {
	$isCurrentAnswerCorrect = false;
	$this-&gt;assertFalse(getNotWinner($this-&gt;aFakeGame(), $isCurrentAnswerCorrect));
}</pre>

<p>Isso tornou nosso código menor e mais expressivo ao mesmo tempo. Ao lermos as assertivas, parece ser uma prosa. Confirme que recebemos <code>true</code> ao tentarmos obter o não vencedor, usando nossa falsa classe com a resposta correta provida. O que eu ainda não gosto é que usamos a mesma variável para atribuir <code>true</code> ou <code>false</code>, dependendo do teste. Acredito que deve haver uma forma mais expressiva de fazê-lo. </p>

<pre class="brush: php">function testItCanTellIfThereIsNoWinnerWhenACorrectAnswerIsProvided() {
	$this-&gt;assertTrue(getNotWinner($this-&gt;aFakeGame(), $this-&gt;aCorrectAnswer()));
}

function testItCanTellIfThereIsNoWinnerWhenAWrongAnswerIsProvided() {
	$this-&gt;assertFalse(getNotWinner($this-&gt;aFakeGame(), $this-&gt;aWrongAnswer()));
}</pre>

<p>Uau! Nossos testes estão em apenas uma linha e eles, realmente, expressam o que estamos testando. Todos os detalhes estão escondidos em métodos privados, lá no final do teste. Em 99% dos casos, você não se preocupara sobre a implementação deles e quando eles o fazem, você pode, simplesmente, apertar <strong>CTRL+clique</strong> no nome do método e a IDE irá até a implementação do mesmo.</p>

<h3>De Volta para o Código de Produção</h3>

<p>Se visualizarmos nosso laço, podemos ver que há uma outra variável que podemos nos livrar, em um piscar de olhos.</p>

<pre class="brush: php">function run() {
	$notAWinner;

	$aGame = new Game();

	$aGame-&gt;add("Chet");
	$aGame-&gt;add("Pat");
	$aGame-&gt;add("Sue");

	do {
		$dice = rand(0, 5) + 1;
		$aGame-&gt;roll($dice);

		$notAWinner = getNotWinner($aGame, isCurrentAnswerCorrect());

	} while ($notAWinner);
}</pre>

<p>Que virará isso:</p>

<pre class="brush: php">function run() {

	$aGame = new Game();

	$aGame-&gt;add("Chet");
	$aGame-&gt;add("Pat");
	$aGame-&gt;add("Sue");

	do {
		$dice = rand(0, 5) + 1;
		$aGame-&gt;roll($dice);

	} while (getNotWinner($aGame, isCurrentAnswerCorrect()));
}</pre>

<p>Até nunca mais, variável <code>$notAWinner</code>. Porém, o nome do nosso método é horrível. Sabemos que devemos, sempre, preferis nomenclatura e comportamento positivo para, então negá-lo onde for necessário nos condicionais. E que tal essa nomenclatura?</p>

<pre class="brush: php">do {
	$dice = rand(0, 5) + 1;
	$aGame-&gt;roll($dice);

} while (didSomebodyWin($aGame, isCurrentAnswerCorrect()));</pre>

<p>Mas, com essa nomenclatura, precisamos negá-lo no <code>while()</code> além de alterar seu comportamento. Começaremos alterando nossos testes.</p>

<pre class="brush: php">class FakeGame {

	function wasCorrectlyAnswered() {
		return false;
	}

	function wrongAnswer() {
		return true;
	}
}</pre>

<p>Na verdade, alterar apenas nosso objeto <em>fake game</em> é melhor. Ele mantem os testes bem legíveis, com os novos nomes dos métodos.</p>

<pre class="brush: php">function testItCanTellIfThereIsNoWinnerWhenACorrectAnswerIsProvided() {
	$this-&gt;assertTrue(didSomebodyWin($this-&gt;aFakeGame(), $this-&gt;aCorrectAnswer()));
}

function testItCanTellIfThereIsNoWinnerWhenAWrongAnswerIsProvided() {
	$this-&gt;assertFalse(didSomebodyWin($this-&gt;aFakeGame(), $this-&gt;aWrongAnswer()));
}</pre>

<h4>Fazendo os Testes Passarem</h4>

<p>Claro que os testes estão falhando, agora. Precisamos alterar a implementação do método.</p>

<pre class="brush: php">function didSomebodyWin($aGame, $isCurrentAnswerCorrect) {
	if ($isCurrentAnswerCorrect) {
		return ! $aGame-&gt;wasCorrectlyAnswered();
	} else {
		return ! $aGame-&gt;wrongAnswer();
	}
}</pre>

<h4>Corrigindo o <em>Resultado Esperado</em></h4>

<p>Os Testes Unitários estão passando, mas ao executar o <em>resultado esperado</em> teremos uma falha. Precisamos negar o <em>login</em> na declaração do laço <code>while</code>.</p>

<pre class="brush: php">do {
	$dice = rand(0, 5) + 1;
	$aGame-&gt;roll($dice);

} while (!didSomebodyWin($aGame, isCurrentAnswerCorrect()));</pre>

<h4>Feito!</h4>

<p>Agora, o <em>resultado esperado</em> voltou a passar e nosso laço <code>do-while</code> parece uma prosa bem escrita. É hora de parar por aqui. Até a próxima e obrigado pela leitura.</p>