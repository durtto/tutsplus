<h1>Refatorando Código Legado: Parte 6 - Atacando Métodos Complexos</h1>

<p>Código velho. Código feio. Código complicado. Código macarrônico. Código sem sentido. Em outras palavras, <em>Código Legado</em>. Esta é uma série que ajudará você a trabalhar e lidar com esse tipo de código).</p>

<p>Nas últimas cinco lições, investimos bastante tempo no entendimento do nosso sistema legado e na escrita de testes para qualquer trecho testável que pudéssemos encontrar. Chegamos a um ponto que já temos vários métodos testados, mas ainda evitamos os métodos com lógica difícil, de alta complexidade. É hora para o trabalho pesado de codificação.</p>

<h2>Compreendendo o Método <code>roll()</code></h2>

<p>Nosso primeiro candidato é o método <code>roll()</code>. Como ele não retorna valor, parece incerto o que ele faz e como testá-lo. Quando não tenho certo por onde começar a testar algum trecho de código, tento lê-lo linha por linha para compreendê-lo, passo-a-passo. Algumas vezes, isso é possível, outras vezes o código, simplesmente, é muito complicado.</p>

<p>Enquanto estou nesse processo de leitura e aprendizado, tento realizar algumas refatorações que tenho certeza que minha IDE é capaz de fazer sem problemas. A maioria delas são renomeações de variáveis e de método que acredito ser capaz de entender e que quero torná-los óbvios para mim e para leitores futuros. E, em um segundo caso, nosso <em>resultado esperado</em> sempre estará lá para algum teste ocasional.</p>

<p>Olha a assinatura do método, <code>roll($roll)</code>, pergunto-me: para que serve o parâmetro <code>$roll</code>? Ele é um objeto? É uma ação? É um número? Minha IDE pode ser bem útil, agora. Apenas posicionando o cursos sobre o parâmetro <code>$roll</code>, todos os seus usos serão destacados, levemente, com uma cor azulada.</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/21522/image/roll-parameter-highlighted.png"/>
</figure>

<p>Podemos perceber a variável <code>$roll</code> destacada nas linhas 63, 67 e 71. E essas são as únicas aparições que são possíveis de ver na tela. Mesmo que haja inúmeras outras abaixo, essas três aparições são ótimas candidata a nos auxiliar na descoberta do papel da variável <code>$roll</code>.</p>

<p>Na linha 63, ela é usada para imprimir texto na tela. <code>echoln("Eles rolaram um " . $roll);</code>. Essa linha é bem simples de entendermos, além de ser bastante útil para nós. Ela nos diz que algum jogador obteve um "$roll". Mas, o que você obtem numa jogada de dados? Um número. Poderíamos renomear <code>$roll</code> para <code>$number</code>. Isso fará com que a assinatura do nosso método pareça bem natural: <code>roll($number)</code>.</p>

<p>E em relação a linha 67? A declaração condicional ainda tem algum sentido no contexto da função, caso renomeemos <code>$roll</code> em <code>$number</code>?</p>

<pre class="brush: php">if ($this-&gt;isOdd($number)) { ... }</pre>

<p>Não gosto muito disso. Se eu olhar apenas para esse trecho de código, não sou capaz de entender para que serve a variável <code>$number</code>. A definição do método está cinco linhas acima. Talvez eu o tenha perdido ou talvez nem tenha lido. Além disso, estamos no terceiro nível de indentação, nosso contexto inicial já mudou bastante. Talvez um nome mais descritivo seja preciso. Que tal <code>$rolledNumber</code>? Isso explicaria o fato de ser um número e também manteria sua fonte no próprio nome. Sabemos que ele é um número obtido pelo jogador. Sabemos que pode seu valor pode ser de um a seis. Isso é importante? Talvez. No final das contas, estamos tentando entender um sistema legado.</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/21522/image/roll-rename.png"/>
</figure>

<p>Agora que resolvemos o problema da nomeação de parâmetros, e entendemos que as duas outras linhas estão apenas retornando texto, podemos continuar e analizar nossa primeira declaração if. Também há uma atribuição de variável, logo antes dele, mas não nos preocuparemos com isso, ainda.</p>

<p>A primeira parte da declaração <code>if</code> é bem grande. Mais precisamente, 20 linhas de tamanho, indo da linha 66 até a linha 86. É bastante informação para lidar. Talvez a parte do <code class="inline">else</code> seja menor. Podemos rolar a barra para ver se ele é fácil o bastante para ser entendido. Essa outra parte possui de 10 a 12 linhas, apenas. E, metade delas, são de impressão de coisas, ou vazias, de modo que podemos perceber que não há tanta lógica nele. Talvez seja o melhor a ser analizado, agora. </p>

<pre class="brush: php">} else {

	$this-&gt;places[$this-&gt;currentPlayer] = $this-&gt;places[$this-&gt;currentPlayer] + $rolledNumber;
	if ($this-&gt;playerShouldStartANewLap()) {
		$this-&gt;places[$this-&gt;currentPlayer] = $this-&gt;places[$this-&gt;currentPlayer] - $boardSize;
	}

	echoln($this-&gt;players[$this-&gt;currentPlayer]
		. " está na nova posição "
		. $this-&gt;places[$this-&gt;currentPlayer]);
	echoln("A categoria é " . $this-&gt;currentCategory());
	$this-&gt;askQuestion();
}</pre>

<p>A primeira linha da declaração <code>if</code> parece posicionar o jogador atual em um novo lugar do tabuleiro. Ele avança o jogador com base no número obtido. Isso é bem típido de jogos de tabuleiros e parece bem lógico.</p>

<p>Então, temos outro condicional, apenas um simples <code>if</code>, verificando se algum jogador está iniciando uma nova volta. Caso positivo, posicionamos o jogador atual para a posição em questão. Você se lembra quando simplificamos uma declaração <code>if</code>, extraímos um método e chamamos de <code>playerShouldStartANewLap()</code>? Faz um bom tempo, não é? Pois bem, o quão útil não foi aquele passo para entendermos a lógica do negócio, hein?</p>

<p>Finalmente, algumas coisas são apresentadas e a pergunta é feita na última linha de código.</p>

<p>Wow. Acabei de perceber que posso explicar o que está acontecendo, em apenas uma sentença: <em>"O jogador é posicionado com base no número obtido, alguma informação é dita ao jogador e fazemos uma pergunta"</em>. Quando sou capaz de fazer isso, sinto uma urgência em criar, rapidamente, um método para cada parte identificada. Três métodos simples já estão zanzando na minha mente. Embora eu possa apenas depender da capacidade da minha IDE em extrair método, estarei muito mais confortável tendo testes para essa parte do código. Podemos, de alguma forma, criar um objeto <code>game</code>, apenas com os jogadores certos, de modo que a segunda parte da declaração <code>if</code> seja ativada?</p>



<h2>Testando a Segunda Parte de <code>roll()</code></h2>

<p>Uma das maiores dificuldades em testar código legado é conseguir deixar o Sistema Sob Testes no estado apropriado, para que possamos verificar o estado que estamos interessados. Já sabemos que inicializar uma classe <code>Game</code> é bem fácil. Não é preciso de parâmetros para o construtor. Então, se olharmos a lista de variáveis da classe, veremos que elas foram definidas usando a palavra chave class is easy. No constructor parameters are required. Then, if we look at the list of class variables. They are simply defined using <code>var</code>. No PHP, elas são consideradas variáveis públicas. E já usamos a variável <code>currentPlayer</code> em nossos testes anteriores, então, podemos ter certeza que podemos acessar as variáveis de fora do objeto.</p>

<p>A essa altura, gosto de começar a criar testes. Não um teste completo, mas o suficiente para que possa descobrir como exercitar todo o sistema sob testes.</p>

<pre class="brush: php">function testSecondPartOfRollLogic() {
	$this-&gt;game-&gt;currentPlayer = 0;
	$this-&gt;game-&gt;players[$this-&gt;game-&gt;currentPlayer] = 'John';
	$this-&gt;game-&gt;inPenaltyBox[$this-&gt;game-&gt;currentPlayer] = false;

	$this-&gt;game-&gt;roll(1);
}</pre>

<p>O nome do teste ainda não é bem específico. Descobrimos três coisas estão acontecendo dentro da parte <code>else</code> da declaração <code>if</code>, mas ainda não está muito claro como definimos isso em apenas duas ou três palavras. Então, por hora, podemos usar algo para descrever o trecho de código que queremos exercitar. Teremos tempo para refatorar o nome posteriormente, se necessário.</p>

<p>Então, configuramos as variáveis requeridas pelo código. Basicamente, copiei e colei as variáveis e adicionei <code>game</code> após cada <code>$this-&gt;</code>. Então invoquei <code>roll()</code> com um número. O número é irrelevante a essa altura, escolha uma número arbitrariamente. </p>

<p>Embora esse código não possua qualquer assertiva, podemos descobrir qual parte do código é executa, apenas olhando para o retorno.</p>

<pre class="brush: bash">John é o jogador atual
Eles rolaram um 1
John está na nova posição 1
A categoria é Ciências
Pergunta sobre Ciências 0</pre>

<p>Podemos observar que "John" é o nosso jogador atual, exatamente como definimos em nosso teste, algumas linhas acima. Então, podemos identificar os pontos chaves que só estão presentes na parte <code>else</code> da declaração <code>if</code>: "a nova posição é".</p>

<p>Assim, o retorno nos ajudou a ter certeza que estamos onde deveríamos estar. O próximo passo é descobrir o que deveríamos verificar dentro de nosso teste.</p>

<p>Poderíamos verificar a próxima posição do jogador de quando ele <strong>não</strong> inicia uma nova volta.</p>

<pre class="brush: php">function testSecondPartOfRollLogic() {
	$currentPlace = 2;
	$rolledNumber = 1;

	$this-&gt;game-&gt;currentPlayer = 0;
	$this-&gt;game-&gt;players[$this-&gt;game-&gt;currentPlayer] = 'John';
	$this-&gt;game-&gt;inPenaltyBox[$this-&gt;game-&gt;currentPlayer] = false;
	$this-&gt;game-&gt;places[$this-&gt;game-&gt;currentPlayer] = $currentPlace;

	$this-&gt;game-&gt;roll($rolledNumber);

	$this-&gt;assertEquals('3', $this-&gt;game-&gt;places[$this-&gt;game-&gt;currentPlayer], 'Esperava-se que o jogador estivesse na posição 3');
}</pre>

<p>Certo. Escrevemos várias linhas ali. Primeiro de tudo, definimos o jogador atual e rolamos alguns valores. Depois, configuramos a posição atual do jogador no tabuleiro, de acordo com a posição especificada acima. Após a rolagem, podemos verificar a nova posição do jogador, que é quando o jogador não precisa começar uma nova volta, é a soma de dois números.</p>

<p>Como nossos testes estão passando, é hora de realizar alguma refatoração. Não podemos fazer muito no código de produção, ainda, mas nossos testes precisam de um pouco de atenção.</p>

<pre class="brush: php">function testSecondPartOfRollLogic() {
	$currentPlace = 2;
	$rolledNumber = 1;

	$this-&gt;setAPlayerThatIsNotInThePenaltyBox();
	$this-&gt;setCurrentPlayersPosition($currentPlace);

	$this-&gt;game-&gt;roll($rolledNumber);

	$this-&gt;assertEquals('3', $this-&gt;getCurrentPlayersPosition(), 'Esperava-se que o jogador estivesse na posição 3');
}</pre>

<p>Nada demais, por hora, apenas alguns métodos extraídos para esconder as horrorosas chamadas de parâmetros que lotavam nossa classe. Agora está mais fácil de entender e, se precisarmos alterar a forma como a informação é configurada ou lida a partir do objeto <code>Game</code>, não precisaremos modificar o método de teste. Modificaremos o método privado, apenas. </p>

<p>Próxima pergunta é: "O que mais podemos testar a partir desse código de produção?" Não queremos entrar na declaração <code>if</code> de quando um jogador precisa começar uma nova volta. Isso será o tópico de outro teste. As duas declarações <code>echoln()</code> enviam dados para o retorno padrão. Há pouquíssima coisa que podemos testar sobre eles. Podemos capturar o retorno e testá-los, mas isso envolviria a parte da apresentação. Podemos sentir o peso da camada de apresentação integrada à lógica de negócios aqui, mas não podemos ver, claramente, como extraí-la. Por hora, apenas a deixemos ali, sem testes. Por fim, a uma invocação ao método <code>askQuestion()</code>. Precisamos verificar <em>o que</em> esse método faz e se podemos testá-lo de alguma forma.</p>

<p>O método <code>askQuestion()</code> verifica a categoria atual e retorna uma cadeia de caracteres para o usuário, com pergunta para ele. A categoria atual é determinada pelo método <code>currentCategory()</code>, que apenas verifica a posição atual e se ela corresponder a um determinado número, uma categoria relacionada será selecionada. O número três que usamos em nosso teste, corresponde à categoria "Rock". O método <code>askQuestion()</code> apenas retorna algo para a tela. Outra coisa relacionada à apresentação que não queremos testar ainda. Mas o método <code>currentCategory()</code> retorna uma cadeia de caracteres, uma que é essencial para o método <code>askQuestion()</code>. Talvez possmos invocar <code>currentCategory()</code> e garantir que a categoria correta foi retornada?</p>

<pre class="brush: php">function testSecondPartOfRollLogic() {
	$currentPlace = 2;
	$rolledNumber = 1;

	$this-&gt;setAPlayerThatIsNotInThePenaltyBox();
	$this-&gt;setCurrentPlayersPosition($currentPlace);

	$this-&gt;game-&gt;roll($rolledNumber);

	$this-&gt;assertEquals('3', $this-&gt;getCurrentPlayersPosition(), 'Esperava-se que o jogador estivesse na posição 3');
	$this-&gt;assertEquals('Rock', $this-&gt;game-&gt;currentCategory());
}</pre>

<p>A última linha que adicionamos faz, exatamente, isso. Parece que conseguimos testar toda a funcionalidade do nosso trecho de código alvo. Agora, podemos começar a refatorar nosso código de produção.</p>

<p>Mas, espere! E o caso de quando precisamos iniciar uma nossa volta? Não deveríamos testá-lo também, antes de tocar no código de produção? Acredito que seja uma boa ideia continuar com os testes por hora e deixar para refatorar o código de produção, apenas estivermos mais certos possível, para não precisamos quebrar algo.</p>

<pre class="brush: php">function testAPlayerWillStartANewLapWhenNeeded() {
	$currentPlace = 11;
	$rolledNumber = 2;

	$this-&gt;setAPlayerThatIsNotInThePenaltyBox();
	$this-&gt;setCurrentPlayersPosition($currentPlace);

	$this-&gt;game-&gt;roll($rolledNumber);

	$this-&gt;assertEquals('1', $this-&gt;getCurrentPlayersPosition(), 'Esperava-se que o jogador estivesse na posição 3');
	$this-&gt;assertEquals('Rock', $this-&gt;game-&gt;currentCategory());
}</pre>

<p>Copiamos e colamos o teste anterior, renomeamo-os de acordo e especificamos lugares diferentes e um número rolado. Sabemos que o tamanho do tabuleiro é de 12 lugares. Obtemos dois com posição 11, de modo que terminamos na posição um. A numeração do tabuleiros começa com a posição zero.</p>

<p>Mas nossa segunda assertiva falha. A categoria é "Ciências". Esse teste destacou alguns problemas em nossa abordagem: 1) Precisamos renomar nosso primeiro teste, e 2) Precisamos testar a categoria em um teste diferente. É hora de refatorar novamente.</p>

<pre class="brush: php">function testAPlayersNextPositionIsCorrectlyDeterminedWhenNoNewLapIsInvolved() {
	// ... //
	$this-&gt;assertEquals('3', $this-&gt;getCurrentPlayersPosition(), 'Esperava-se que o jogador estivesse na posição 3');
}

function testAPlayerWillStartANewLapWhenNeeded() {
	// ... //
	$this-&gt;assertEquals('1', $this-&gt;getCurrentPlayersPosition(), 'Esperava-se que o jogador estivesse na posição 3');
}

function testRockCategoryCanBeDetermined() {
	$currentPlaces = [3];

	foreach($currentPlaces as $currentPlace) {
		$this-&gt;setAPlayerThatIsNotInThePenaltyBox();
		$this-&gt;setCurrentPlayersPosition($currentPlace);
		$foundCategory = $this-&gt;game-&gt;currentCategory();
		$this-&gt;assertEquals('Rock', $foundCategory,
			'Esperava-se a categoria sobre rock para a posição ' . $currentPlace .
			', mas obtivemos ' . $foundCategory);
	}
}

function testScienceCategoryCanBeDetermined() {
	$currentPlaces = [1];

	foreach($currentPlaces as $currentPlace) {
		$this-&gt;setAPlayerThatIsNotInThePenaltyBox();
		$this-&gt;setCurrentPlayersPosition($currentPlace);
		$foundCategory = $this-&gt;game-&gt;currentCategory();
		$this-&gt;assertEquals('Ciências', $foundCategory,
			'Esperava-se a categoria sobre rock para a posição ' . $currentPlace .
			', mas obtivemos ' . $foundCategory);
	}
}</pre>

<p>Renomeamos o primeiro teste para refletir exatamente o que estávamos verificando. Em ambos os testes, removemos a verificação de categoria. Sabemos que temos duas categorias diferentes e duas posições. Com base em nosso conhecimento e na estrutura do método <code>currentCategory()</code>, podemos deduzir que há diversos lugares para várias categorias. Primeiro, definimos os lugares em vetores e, então, esperamos os dois valroes diferentes para nossas categorias.</p>

<p>Por hora, nosso alvo não é testar o método <code>currentCategory()</code>. Poderíamos parar nosso processo atual e escrever testes para todas as combinações de lugares e categorias. Contudo, não quero fazer isso ainda. Agora, precisamos matermo-nos focados no método <code class="inline">roll</code> e em nosso pequeno trecho de código. Ainda podemos remover a duplicação entre os dois testes, além de extrair a verificação em um método privado. Isso nos ajudará no futuro, quando escrevermos os testes para <code>currentCategory()</code>.</p>

<pre class="brush: php">function testRockCategoryCanBeDetermined() {
	$currentPlaces = [3];
	$expectedCategory = 'Rock';
	$this-&gt;assertCorrectCategoryForGivenPlaces($expectedCategory, $currentPlaces);
}

function testScienceCategoryCanBeDetermined() {
	$currentPlaces = [1];
	$expectedCategory = 'Ciências';
	$this-&gt;assertCorrectCategoryForGivenPlaces($expectedCategory, $currentPlaces);
}</pre>



<h2>Refatorando a Segunda Parte de <code>roll()</code></h2>

<p>Now that all of our tests are beautifully written and passing, modifying the source code is the next logical step. The <code>if</code> statement with the player-moving logic must go first.</p>

<pre class="brush: php">} else {

	$this-&gt;movePlayer($boardSize, $rolledNumber);

	echoln($this-&gt;players[$this-&gt;currentPlayer]
		. " está na nova posição "
		. $this-&gt;places[$this-&gt;currentPlayer]);
	echoln("A categoria é " . $this-&gt;currentCategory());
	$this-&gt;askQuestion();
}</pre>

<p>It seems like our method will need two parameters at least. The board's size and the rolled number. The rest of the used information is from class variables, so they don't need to be passed along as parameters. However, the board's size also looks like a value that belongs to the method, rather than to the game class. Later, we'll see if we can move it into the method.</p>

<pre class="brush: php">} else {
	$this-&gt;movePlayer($boardSize, $rolledNumber);
	$this-&gt;displayPlayersNewLocation();
	$this-&gt;displayCurrentCategory();
	$this-&gt;askQuestion();
}</pre>

<p>Next, the lines displaying things for the user must go into their own small specialized methods. We could have put all the display stuff into a single method, but it would have been difficult to name it. It is preferable to have better named and smaller methods.</p>

<pre class="brush: php">private function displayPlayersNewLocation() {
	echoln($this-&gt;players[$this-&gt;currentPlayer] . " está na nova posição " . $this-&gt;places[$this-&gt;currentPlayer]);
}

private function displayCurrentCategory() {
	echoln("A categoria é " . $this-&gt;currentCategory());
}</pre>

<p>With that, we are done with this part of the code. But what about the rest of the <code>roll()</code> method?</p>



<h2>Two Programmers, Two Different Threads</h2>

<p>Up until now, this tutorial has focused on small pieces of code. Our level of zoom was very close to the code. We did a lot of things thinking about eight to ten lines of code or less. We concentrated on small things like variable names or moving one to two lines of code, from one place to another.</p>

<p>We at Syneto do a lot of pair programming. Basically every time there is at least a moderately difficult task to be done, we do it as a pair. And refactoring is quite a difficult task, so most of the time there are two pairs of eyes looking at the code. This allows us to understand and think about what we are doing by looking at the code from two different zoom levels. While one programmer does the tiny changes and concentrates on character or line-level details, the other one can see the code from a distance.</p>

<p>While the format of these webpages does not allow a lot of horizontal space, in reality, any programmer should have at least a 25" display, with a decent resolution that permits the view of the code from a higher zoom level. Here is how I see the <code>roll()</code> method on my 27" inch display.</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/21522/image/roll-full-view.png"/>
</figure>

<p>At this level, a person can observe form, indentation, and relief.</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/21522/image/roll-full-view-relief.png"/>
</figure>

<p>This person can think about complexity, code design, and possible methods that could be extracted. This person can evaluate the complexity of <em>logic</em>, while the other person doing the small changes can deal with the complexity of <em>code</em>. The higher view can also highlight duplication quite effectively.</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/21522/image/roll-full-view-duplicate-code.png"/>
</figure>

<p>Isn't that cool? Did you observe the huge duplication before this image? Were you able to concentrate both on tiny details and on a high level view? Maybe you were. Some people have a natural talent to understand code, but most of us can't concentrate effectively on more than one level.</p>

<p>And the best part of it? <em>You can do it alone also!</em> That is, if you don't have the opportunity to pair with another programmer, you can still zoom in and out. But you have to do it sequentially in order to be effective. Something like this is what we did at the beginning. We looked at the method from a higher level, we identified the small piece of code we could attack, and we zoomed in. The change of focus effectively switched our mindset and our way of thinking. We stayed in this zoomed in state, without thinking about the rest of the code until we finished refactoring it. Now we can zoom out again, change our mindset again and continue.</p>



<h2>Refactoring the First Part of <code>roll()</code></h2>

<p>Some people change mindsets and views easily, in less than a minute. Others need more time to "forget" the details and zoom out, or vice versa, to give up on thinking about form and start reading the code one character at a time. If you need ten or 15 minutes, it's not as uncommon as you may think. Try to organize your work in a way that will allow you to take your next ten minute break just between zooms.</p>

<p>And again, change of mindset, we need to zoom in on the first part of the <code>if</code> statement, when the user is in the penalty box.</p>

<p>This code starts with another <code>if()</code> statement checking if the rolled number is odd. If it is, it does something complicated. If it is an even number, it does something much simpler. It just keeps the player in the penalty box.</p>

<pre class="brush: php">} else {
	echoln($this-&gt;players[$this-&gt;currentPlayer] . " não está saindo da caixa de penalidades");
	$this-&gt;isGettingOutOfPenaltyBox = false;
}</pre>

<p>That should be easy to test and it will also force us to define ways of setting up our SUT.</p>

<pre class="brush: php">function testAPlayerWhoIsPenalizedAndRollsAnEvenNumberWillStayInThePenaltyBox() {
	$rolledNumber = 2;
	$this-&gt;setAPlayerThatIsInThePenaltyBox();

	$this-&gt;game-&gt;roll($rolledNumber);

	$this-&gt;assertFalse($this-&gt;game-&gt;isGettingOutOfPenaltyBox);
}</pre>

<p>Yes. It was easy. A nice four line long test method. And the <code>setAPlayerThatIsInThePenaltyBox()</code> method is very similar with its counterpart. The only difference being the penalty box state.</p>

<p>We can now start building the test, or tests, for the first part of the if, when the rolled number is odd.</p>

<pre class="brush: php">function testAPlayerWhoIsPenalizedAndRollsAnOddNumberWillGetOutOfThePenaltyBox() {
	$rolledNumber = 1;
	$this-&gt;setAPlayerThatIsInThePenaltyBox();

	$this-&gt;game-&gt;roll($rolledNumber);

	$this-&gt;assertTrue($this-&gt;game-&gt;isGettingOutOfPenaltyBox);
}</pre>

<p>That's a promising start. The first line: tested. The rest will be similar to the tests for the <code>else</code> part of the first level <code>if</code>.</p>



<h2>Pairs Should Be Pairs Till the End</h2>

<p>One dilemma my colleagues and I at Syneto faced when doing paired programming or refactorings like this, was that when the task becomes clear and comes close to being finished, one of the programmers is tempted to leave. </p>

<p>If you are the one concentrating on writing tests and moving small pieces of code, your pair may be tempted to think that his role is over. He saw the high level problems, communicated them to you, now it's your turn to fix the code. When he tries to leave, stop him. Tell him all tasks started as a pair should be finished as a pair. Tell him to help you think about the tests, names, structures, so you can concentrate on the procedures and steps required by the refactoring techniques that need to be used, the steps we learned in previous lessons.</p>

<p>For example, he could think of test names, while you are occupied with copy/pasting and modifying the previous tests, to force the entry on this part of the if.</p>

<pre class="brush: php">function testPlayerGettingOutOfPenaltyNextPositionWithoutNewLap() {
	$currentPlace = 2;
	$numberRequiredToGetOutOfPenaltyBox = 1;

	$this-&gt;setAPlayerThatIsInThePenaltyBox();
	$this-&gt;setCurrentPlayersPosition($currentPlace);

	$this-&gt;game-&gt;roll($numberRequiredToGetOutOfPenaltyBox);

	$this-&gt;assertEquals('3', $this-&gt;getCurrentPlayersPosition(), 'Esperava-se que o jogador estivesse na posição 3');
}

function testPlayerGettingOutOfPenaltyNextPositionWithNewLap() {
	$currentPlace = 11;
	$numberRequiredToGetOutOfPenaltyBox = 3;

	$this-&gt;setAPlayerThatIsInThePenaltyBox();
	$this-&gt;setCurrentPlayersPosition($currentPlace);

	$this-&gt;game-&gt;roll($numberRequiredToGetOutOfPenaltyBox);

	$this-&gt;assertEquals('2', $this-&gt;getCurrentPlayersPosition(), 'Esperava-se que o jogador estivesse na posição 3');
}</pre>

<p>On the other hand, if your pair decides that after discovering all the duplication and cool high level problems, he should be entitled to write the tests and refactor the code, you may feel that you have nothing else to do. But you are wrong. You can stay and help him with naming, low level duplication, and other small things. You can also help him when he stumbles or misses some small steps or when he remains stuck at failing tests because of a stupid little typo.</p>

<p>This is how tests will be named well, like <code>testPlayerGettingOutOfPenaltyNextPositionWithNewLap()</code> and variables will express what they represent for the current test and not what they did for the previous test that you copied over: <code>$numberRequiredToGetOutOfPenaltyBox</code>.</p>

<pre class="brush: php">function  roll($rolledNumber) {
	echoln($this-&gt;players[$this-&gt;currentPlayer] . " é o jogador atual");
	echoln("Eles rolaram um " . $rolledNumber);

	$boardSize = 12;
	if ($this-&gt;inPenaltyBox[$this-&gt;currentPlayer]) {
		if ($this-&gt;isOdd($rolledNumber)) {
			$this-&gt;isGettingOutOfPenaltyBox = true;
			$this-&gt;movePlayer($boardSize,$rolledNumber);
			$this-&gt;displayPlayersNewLocation();
			$this-&gt;displayCurrentCategory();
			$this-&gt;askQuestion();
		} else {
			echoln($this-&gt;players[$this-&gt;currentPlayer] . " não está saindo da caixa de penalidades");
			$this-&gt;isGettingOutOfPenaltyBox = false;
		}

	} else {
		$this-&gt;movePlayer($boardSize, $rolledNumber);
		$this-&gt;displayPlayersNewLocation();
		$this-&gt;displayCurrentCategory();
		$this-&gt;askQuestion();
	}

}</pre>

<p>Isn't that better than before? All unit tests are passing. But I feel we've moved around a lot of code that is responsible for the presentation. Maybe we should run our golden master test?</p>



<h2>Taking a Step Backward</h2>

<pre class="brush: bash">PHPUnit_Framework_ExpectationFailedException : Failed asserting that false is true.
Time: 18.93 seconds, Memory: 112.50Mb

FAILURES!
Tests: 20, Assertions: 33, Failures: 1, Skipped: 1.</pre>

<p>And it fails. It has been quite some time since we ran our golden master tests, but all of our modifications were localized in the <code>roll()</code> method. So the worst thing that can happen is that we revert our changes.</p>

<p>Let's start with a small step back. I suspect that where we saw duplication in the output, there was a small difference. Maybe a letter or a space we did not observe. We could revert the outputting in the first part of <code>roll()</code> and see if it works.</p>

<pre class="brush: php">function  roll($rolledNumber) {
	echoln($this-&gt;players[$this-&gt;currentPlayer] . " é o jogador atual");
	echoln("Eles rolaram um " . $rolledNumber);

	$boardSize = 12;
	if ($this-&gt;inPenaltyBox[$this-&gt;currentPlayer]) {
		if ($this-&gt;isOdd($rolledNumber)) {
			$this-&gt;isGettingOutOfPenaltyBox = true;
			$this-&gt;movePlayer($boardSize,$rolledNumber);
			echoln($this-&gt;players[$this-&gt;currentPlayer]
				. " está na nova posição "
				. $this-&gt;places[$this-&gt;currentPlayer]);
			echoln("A categoria é " . $this-&gt;currentCategory());
			$this-&gt;askQuestion();
		} else {
			echoln($this-&gt;players[$this-&gt;currentPlayer] . " não está saindo da caixa de penalidades");
			$this-&gt;isGettingOutOfPenaltyBox = false;
		}

	} else {
		$this-&gt;movePlayer($boardSize, $rolledNumber);
		$this-&gt;displayPlayersNewLocation();
		$this-&gt;displayCurrentCategory();
		$this-&gt;askQuestion();
	}

}</pre>

<p>That still fails. As our first suspicion was wrong, we may want to take a bigger step back. Did our golden master pass before we started our work? Maybe next time we should start by running it. Now we need to take our changes, put them in a safe place and revert all the code to verify our hypothesis.</p>

<p>The reverting to the original state of <code>roll()</code> makes the golden master pass. Good to know. So we broke it. But when? Where?</p>

<p>Now that our code is reverted to the original, we could observe the output, put it in a text file and compare it with the refactored one.</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/21522/image/test-output-orig-vs-refactored-diff-lines.png"/>
</figure>

<p>As we can immediately observe, we missed some lines in the refactored version. The strings telling us that the player está saindo da caixa de penalidades are missing. Hmm...</p>

<p>Let's take a look at the code that we started with, again. Aha!!! There it is!</p>

<pre class="brush: php">echoln($this-&gt;players[$this-&gt;currentPlayer] . " está saindo da caixa de penalidades");
$this-&gt;places[$this-&gt;currentPlayer] = $this-&gt;places[$this-&gt;currentPlayer] + $roll;
if ($this-&gt;playerShouldStartANewLap()) {
	$this-&gt;places[$this-&gt;currentPlayer] = $this-&gt;places[$this-&gt;currentPlayer] - $boardSize;
}</pre>

<p>An <code>echoln()</code> stuck at the top of the moving logic. An honest, simple mistake. We didn't observe it and just took all that block of code and replaced it with the method call.</p>

<pre class="brush: php">function  roll($rolledNumber) {
	echoln($this-&gt;players[$this-&gt;currentPlayer] . " é o jogador atual");
	echoln("Eles rolaram um " . $rolledNumber);

	$boardSize = 12;
	if ($this-&gt;inPenaltyBox[$this-&gt;currentPlayer]) {
		if ($this-&gt;isOdd($rolledNumber)) {
			$this-&gt;isGettingOutOfPenaltyBox = true;
			echoln($this-&gt;players[$this-&gt;currentPlayer] . " está saindo da caixa de penalidades");
			$this-&gt;movePlayer($boardSize,$rolledNumber);
			$this-&gt;displayPlayersNewLocation();
			$this-&gt;displayCurrentCategory();
			$this-&gt;askQuestion();
		} else {
			echoln($this-&gt;players[$this-&gt;currentPlayer] . " não está saindo da caixa de penalidades");
			$this-&gt;isGettingOutOfPenaltyBox = false;
		}

	} else {
		$this-&gt;movePlayer($boardSize, $rolledNumber);
		$this-&gt;displayPlayersNewLocation();
		$this-&gt;displayCurrentCategory();
		$this-&gt;askQuestion();
	}

}</pre>

<p>This makes all the tests pass. Thank goodness that I had a pair to help me figure this out. Even though mine was a teddy bear, as I write these articles alone, many times it helps just to tell someone your problem. It will make your mind replay all the thoughts and remake the process. More than not, this makes you realize stupid mistakes and observe things you would otherwise miss.</p>



<h2>Adding the Final Touch</h2>

<p>Before we conclude this tutorial, we should make sure we leave our <code>roll()</code> method in the best shape that we can. First, all the <code>echoln()</code> calls can go into private methods.</p>

<pre class="brush: php">function  roll($rolledNumber) {
	$this-&gt;displayCurrentPlayer();
	$this-&gt;displayRolledNumber($rolledNumber);

	$boardSize = 12;
	if ($this-&gt;inPenaltyBox[$this-&gt;currentPlayer]) {
		if ($this-&gt;isOdd($rolledNumber)) {
			$this-&gt;isGettingOutOfPenaltyBox = true;
			$this-&gt;displayPlayerGettingOutOfPenaltyBox();
			$this-&gt;movePlayer($boardSize,$rolledNumber);
			$this-&gt;displayPlayersNewLocation();
			$this-&gt;displayCurrentCategory();
			$this-&gt;askQuestion();
		} else {
			$this-&gt;displayPlayerStaysInPenaltyBox();
			$this-&gt;isGettingOutOfPenaltyBox = false;
		}

	} else {
		$this-&gt;movePlayer($boardSize, $rolledNumber);
		$this-&gt;displayPlayersNewLocation();
		$this-&gt;displayCurrentCategory();
		$this-&gt;askQuestion();
	}

}</pre>

<p>The above is a step in the right direction, but my pair says we can do better.</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/21522/image/20140620_232541_HDR.jpg"/>
</figure>

<p>We can group the consecutive display functions into other display functions.</p>

<pre class="brush: php">function  roll($rolledNumber) {
	$this-&gt;displayStatusAfterRoll($rolledNumber);

	$boardSize = 12;
	if ($this-&gt;inPenaltyBox[$this-&gt;currentPlayer]) {
		if ($this-&gt;isOdd($rolledNumber)) {
			$this-&gt;isGettingOutOfPenaltyBox = true;
			$this-&gt;movePlayer($boardSize,$rolledNumber);
			$this-&gt;displayStatusAfterPlayerGettingOutOfPenaltyBox();
			$this-&gt;askQuestion();
		} else {
			$this-&gt;displayPlayerStaysInPenaltyBox();
			$this-&gt;isGettingOutOfPenaltyBox = false;
		}
	} else {
		$this-&gt;movePlayer($boardSize, $rolledNumber);
		$this-&gt;displayStatusAfterNonPenalizedPlayerMove();
		$this-&gt;askQuestion();
	}
}</pre>

<p>Isn't that better? Only one display call with each path our method can follow.</p>

<p>Do you remember <code>$boardSize</code>? Can we move it inside <code>movePlayer()</code> now? Yes we can. So, let's do it.</p>

<pre class="brush: php">function  roll($rolledNumber) {
	$this-&gt;displayStatusAfterRoll($rolledNumber);

	if ($this-&gt;inPenaltyBox[$this-&gt;currentPlayer]) {
		if ($this-&gt;isOdd($rolledNumber)) {
			$this-&gt;isGettingOutOfPenaltyBox = true;
			$this-&gt;movePlayer($rolledNumber);
			$this-&gt;displayStatusAfterPlayerGettingOutOfPenaltyBox();
			$this-&gt;askQuestion();
		} else {
			$this-&gt;displayPlayerStaysInPenaltyBox();
			$this-&gt;isGettingOutOfPenaltyBox = false;
		}
	} else {
		$this-&gt;movePlayer($rolledNumber);
		$this-&gt;displayStatusAfterNonPenalizedPlayerMove();
		$this-&gt;askQuestion();
	}
}</pre>

<p>Our code's getting pretty minimal. But still, this method is 18 lines long. That's a lot. Do you remember Robert C. Martin's teachings or the "Magic number seven plus minus two"? Our methods would be better if they would contain only about four lines of code.</p>

<p>The first step in this direction, is to reduce it to a single function call for each possible path.</p>

<pre class="brush: php">function  roll($rolledNumber) {
	$this-&gt;displayStatusAfterRoll($rolledNumber);

	if ($this-&gt;inPenaltyBox[$this-&gt;currentPlayer]) {
		if ($this-&gt;isOdd($rolledNumber)) {
			$this-&gt;getPlayerOutOfPenaltyBoxAndPlayNextMove($rolledNumber);
		} else {
			$this-&gt;keepPlayerInPenaltyBox();
		}
	} else {
		$this-&gt;playNextMove($rolledNumber);
	}
}</pre>

<p>We are now down to 12 lines of code. But we can do even better. The innermost <code>if</code> can go into its own method.</p>

<pre class="brush: php">function  roll($rolledNumber) {
	$this-&gt;displayStatusAfterRoll($rolledNumber);
	if ($this-&gt;inPenaltyBox[$this-&gt;currentPlayer]) {
		$this-&gt;playNextMoveForPlayerInPenaltyBox($rolledNumber);
	} else {
		$this-&gt;playNextMove($rolledNumber);
	}
}</pre>

<h2>We're Finished!</h2>

<p>With that we're down to seven lines of code in our method. Only five inside the method, with only four actually doing some kind of logic. Now this is a reasonable looking method, and it's at a point at which, I would feel good about stopping at. Also, this is not just an example. This is <em>"Extract till you drop"</em> and is how most of our methods look in our projects at Syneto. This is a real life example and is where you should end up, day by day, in all of your code. This is also where we stop for this lesson.</p>

<p>Stay tuned for the next tutorial, where we will talk about layers and we will start to separate concerns.</p>