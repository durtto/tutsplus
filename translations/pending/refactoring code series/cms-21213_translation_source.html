<h1>Refatorando Código Legado: Parte 5 - Os Métodos Testáveis do Jogo</h1>

<p>Código velho. Código feio. Código complicado. Código macarrônico. Código sem sentido. Em outras palavras, <em>Código Legado</em>. Esta é uma série que ajudará você a trabalhar e lidar com esse tipo de código.</p>

<p>No artigo anterior, testamos as funções do nosso executador (<em>Runner</em>). Neste artigo, daremos continuidade de onde paramos, criando testes para nossa classe <code>Game</code>. Ao começamos com um código tão grande quanto temos agora, é tentador testá-lo de cima a baixo, método a método. Na maior parte do tempo, isso é impossível. É muito melhor começar a testá-lo pelos seus métodos menores, pelos métodos mais testáveis. E é isso o que faremos neste artigo: encontraremos e testaremos esses testes menores e mais fáceis.</p>

<h2>Criando um Jogo</h2>

<p>Para testarmos uma classe, precisamos iniciar um objeto daquele tipo específico. Podemos considerar que nosso primeiro teste é a criação desse novo objeto. Você ficará surpreso com quantos segredos um construtor pode esconder.</p>

<pre class="brush: php">require_once __DIR__ . '/../trivia/php/Game.php';

class GameTest extends PHPUnit_Framework_TestCase {

	function testWeCanCreateAGame() {
		$game = new Game();
	}

}</pre>

<p>Para nossa surpresa, um objeto <code>Game</code> pode ser criado facilmente. Não ocorre problemas ao executar apenas <code>new Game()</code>. Nada quebra. Esse é um bom começo, especialmente, se considerarmos que o construtor do objeto <code>Game</code> é bem grande e realiza várias tarefas.</p>

<h2>Encontrando o Primeiro Método Testável</h2>

<p>É tentador buscarmos a simplificação do construtor agora. Porém, apenas temos o "resultado esperado" para garantir que nada mais está errado. Antes de irmos ao construtor, precisamos testar a maior parte do resto da classe. Então, onde deveríamos começar?</p>

<p>Procure pelo primeiro método que retorna um valor e pergunte-se, "Posso invocar e controlar o valor retornado por esse método?". Se a resposta for sim, então, esse método é um ótimo candidato para nosso teste.</p>

<pre class="brush: php">function isPlayable() {
	$minimumNumberOfPlayers = 2;
	return ($this-&gt;howManyPlayers() &gt;= $minimumNumberOfPlayers);
}</pre>

<p>Que tal esse método? Ele parece um bom candidato. Apenas duas linhas e retorna um valor booleano. Mas, espere, ele invoca outro método, o <code>howManyPlayers()</code>.</p>

<pre class="brush: php">function howManyPlayers() {
	return count($this-&gt;players);
}</pre>

<p>Basicamente, este é apenas um método que conta os elementos do vetor <code>players</code> da classe. Então, se não quisermos adicionar qualquer jogador, ele deveria ser zero. O método <code>isPlayable()</code> deve retornar falso. Vejamos se nossa suposição está correta.</p>

<pre class="brush: php">function testAJustCreatedNewGameIsNotPlayable() {
	$game = new Game();
	$this-&gt;assertFalse($game-&gt;isPlayable());
}</pre>

<p>Renomeamos nosso método de testes anterior para refletir aquilo que ele realmente quer testar. Então, afirmamos que o jogo não é possível ser jogado. O teste passou. Mas, casos de falsos positivos são bem comuns. Para desencargo de consciência, podemos afirmar que o jogo é possível ser jogado e garantir que o teste falha.</p>

<pre class="brush: php">$this-&gt;assertTrue($game-&gt;isPlayable());</pre>

<p>E ele falhou!</p>

<pre class="brush: bash">PHPUnit_Framework_ExpectationFailedException :
Failed asserting that false is true.</pre>

<p>Até agora, tudo parece bastante promissor. Conseguimos testar o retorno inicial do método, o valor representado pelo <em>estado</em> inicial da classe <code>Game</code>. Atente para a palavra enfatizada: "estado". Precisamos encontrar uma forma de controlar o estado do jogo. Precisamos alterá-lo, de modo que tenha um número mínimo de jogadores.</p>

<p>Se analisarmos o método <code>add()</code> da classe <code>Game</code>, veremos que ele adiciona elementos ao nosso vetor.</p>

<pre class="brush: php">array_push($this-&gt;players, $playerName);</pre>

<p>Nossa suposição é garantida pela forma como o método <code>add()</code> é usado no arquivo <code>RunnerFunctions.php</code>.</p>

<pre class="brush: php">function run() {

	$aGame = new Game();
	$aGame-&gt;add("Chet");
	$aGame-&gt;add("Pat");
	$aGame-&gt;add("Sue");

	// ... //
}</pre>

<p>Com base nessas observações, podemos concluir que ao usar o método <code>add()</code> duas vezes, somos capazes de deixar nossa classe <code>Game</code> em um <em>estado</em> com dois jogadores.</p>

<pre class="brush: php">function testAfterAddingTwoPlayersToANewGameItIsPlayable() {
	$game = new Game();
	$game-&gt;add('Primeiro Jogador');
	$game-&gt;add('Segundo Jogador');
	$this-&gt;assertTrue($game-&gt;isPlayable());
}</pre>

<p>Ao adicionar esse segundo teste, podemos garantir que o método <code>isPlayable()</code> retorna verdadeiro, caso as condições sejam as corretas.</p>

<p>Talvez você ache que isso não seja bem um teste unitário. Nós usamos o método <code>add()</code>! Exercitamos mais que o mínimo de código necessário. Poderíamos, apenas, adicionar elementos ao vetor <code>$players</code> ao invés de depender do método <code>add()</code>.</p>

<p>Bom, a resposta para isso é <em>sim</em> e <em>não</em>. Poderíamos fazer isso, numa perspectiva técnica. Teríamos a vantagem do controle direto sobre o vetor. Contudo, teríamos a desvantagem da duplicação de código entre o código de produção e os testes. Então, escolha uma das possibilidades <em>ruins</em> e aceite. Pessoalmente, prefiro reusar métodos, como no caso do <code>add()</code>.</p>

<h3>Refatorando Testes</h3>

<p>Estamos no verde, então refatoramos. Podemos melhorar nossos testes? Sim, podemos. Poderíamos transformar nosso primeiro teste de modo que ele verifique todas as condições da não existência de jogadores suficientes.</p>

<pre class="brush: php">function testAGameWithNotEnoughPlayersIsNotPlayable() {
	$game = new Game();
	$this-&gt;assertFalse($game-&gt;isPlayable());
	$game-&gt;add('Um Jogador');
	$this-&gt;assertFalse($game-&gt;isPlayable());
}</pre>

<p>Talvez não tenha ouvido sobre o conceito de "Uma assertiva por teste". Na maioria das vezes, concordo com isso, porém, se você tem um teste que verifica um único conceito e que requer múltiplas assertivas para completar sua verificação, acredito que é aceitável usar mais de uma assertiva. Essa visão é bastante promovida por Robert C. Martin em seus ensinamentos.</p>

<p>E em relação ao nosso segundo método? Está bom o suficiente? Não creio.</p>

<pre class="brush: php">$game-&gt;add('Primeiro Jogador');
$game-&gt;add('Segundo Jogador');</pre>

<p>Essas duas invocações incomodam um pouco. Elas são implementações sem qualquer explicação em nosso método. Por que não extraí-las em um método privado?</p>

<pre class="brush: php">function testAfterAddingEnoughPlayersToANewGameItIsPlayable() {
	$game = new Game();
	$this-&gt;addEnoughPlayers($game);
	$this-&gt;assertTrue($game-&gt;isPlayable());
}

private function addEnoughPlayers($game) {
	$game-&gt;add('Primeiro Jogador');
	$game-&gt;add('Segundo Jogador');
}</pre>

<p>Isso está muito melhor e nos leva a outro conceito que deixamos passar. Em ambos os testes, de uma forma ou de outra, expressamos o conceito de "jogadores o suficiente". Mas, o quanto é suficiente? Dois? Sim, por hora é. Mas, queremos que nossos testes falhem caso a lógica da classe <code>Game</code> requeira ao menos três jogadores? Não queremos que isso aconteça. Podemos incluir um campo público e estático na classe.</p>

<pre class="brush: php">class Game {
	static $minimumNumberOfPlayers = 2;

	// ... //

	function  __construct() {
		// ... //
	}

	function isPlayable() {
		return ($this-&gt;howManyPlayers() &gt;= self::$minimumNumberOfPlayers);
	}

	// ... //
}</pre>

<p>Isso nos permitirá usá-lo em nossos testes.</p>

<pre class="brush: php">private function addEnoughPlayers($game) {
	for($i = 0; $i &lt; Game::$minimumNumberOfPlayers; $i++) {
		$game-&gt;add('Um Jogador');
	}
}</pre>

<p>Nosso pequeno método apenas adicionar jogadores até a quantidade suficiente seja alcançada. Podemos até criar outro método para nossos primeiros testes, para que adicionemos quase a quantidade suficiente de jogadores.</p>

<pre class="brush: php">function testAGameWithNotEnoughPlayersIsNotPlayable() {
	$game = new Game();
	$this-&gt;assertFalse($game-&gt;isPlayable());
	$this-&gt;addJustNothEnoughPlayers($game);
	$this-&gt;assertFalse($game-&gt;isPlayable());
}

private function addJustNothEnoughPlayers($game) {
	for($i = 0; $i &lt; Game::$minimumNumberOfPlayers - 1; $i++) {
		$game-&gt;add('Um Jogador');
	}
}</pre>

<p>Mas isso introduzirá um pouco de duplicação. Nossos dois métodos auxiliares são bem parecidos. Não podemos extrair um terceiro método a partir dos dois?</p>

<pre class="brush: php">private function addEnoughPlayers($game) {
	$this-&gt;addManyPlayers($game, Game::$minimumNumberOfPlayers);
}

private function addJustNothEnoughPlayers($game) {
	$this-&gt;addManyPlayers($game, Game::$minimumNumberOfPlayers - 1);
}

private function addManyPlayers($game, $numberOfPlayers) {
	for ($i = 0; $i &lt; $numberOfPlayers; $i++) {
		$game-&gt;add('Um Jogador');
	}
}</pre>

<p>Está melhor, mas introduziu um problema diferente. Reduzimos a duplicação nos métodos, mas nosso objeto <code>$game</code> precisa ser passado em até três níveis. É hora de inicializarmos esse objeto no método <code>setUp()</code> para que possa ser reusado.</p>

<pre class="brush: php">class GameTest extends PHPUnit_Framework_TestCase {

	private $game;

	function setUp() {
		$this-&gt;game = new Game;
	}

	function testAGameWithNotEnoughPlayersIsNotPlayable() {
		$this-&gt;assertFalse($this-&gt;game-&gt;isPlayable());
		$this-&gt;addJustNothEnoughPlayers();
		$this-&gt;assertFalse($this-&gt;game-&gt;isPlayable());
	}

	function testAfterAddingEnoughPlayersToANewGameItIsPlayable() {
		$this-&gt;addEnoughPlayers($this-&gt;game);
		$this-&gt;assertTrue($this-&gt;game-&gt;isPlayable());
	}

	private function addEnoughPlayers() {
		$this-&gt;addManyPlayers(Game::$minimumNumberOfPlayers);
	}

	private function addJustNothEnoughPlayers() {
		$this-&gt;addManyPlayers(Game::$minimumNumberOfPlayers - 1);
	}

	private function addManyPlayers($numberOfPlayers) {
		for ($i = 0; $i &lt; $numberOfPlayers; $i++) {
			$this-&gt;game-&gt;add('Um Jogador');
		}
	}

}</pre>

<p>Muito melhor. Todo código irrelevante está em algum método privado, o objeto <code>$game</code> foi inicializado no método <code>setUp()</code> e muito da poluição foi removida dos métodos dos testes. Contudo, tivemos de nos comprometer aqui. Em nosso primeiro teste, começamos com uma assertiva. Presumimos que o método <code>setUp()</code> sempre criará um jogo vazio. Isso está certo, por hora. Mas, ao final do dia, você deve perceber que não há tal coisa, como um código perfeito. Apenas há código com compromissos que você está disposto a conviver.</p>

<h2>O Segundo Método Testável</h2>

<p>Se escanearmos a classe <code>Game</code> do começo ao fim, o próximo método em nossa lista é o <code>add()</code>. Sim, o mesmo método usado nos testes do parágrafo anterior. Mas, podemos testá-lo?</p>

<pre class="brush: php">function testItCanAddANewPlayer() {
	$this-&gt;game-&gt;add('Um Jogador');
	$this-&gt;assertEquals(1, count($this-&gt;game-&gt;players));
}</pre>

<p>Essa é uma forma diferente de testar objetos. Invocamos nosso método e, então, verificamos o estado dele. Como o método <code>add()</code> sempre retorna <code>true</code>, não há alguma forma de testar o retorno. Mas, podemos começar com um objeto <code>Game</code> vazio e, então, verificar se há algum usuário após inserirmos o primeiro. Mas, isso é o suficiente de verificação?</p>

<pre class="brush: php">function testItCanAddANewPlayer() {
	$this-&gt;assertEquals(0, count($this-&gt;game-&gt;players));
	$this-&gt;game-&gt;add('Um Jogador');
	$this-&gt;assertEquals(1, count($this-&gt;game-&gt;players));
}</pre>

<p>Também não seria melhor verificar se não há jogadores antes de invocarmos <code>add()</code>? Bem, pode parecer um pouco demais, mas, como pode ver pelo código, poderíamos fazê-lo sim. E, toda vez que você não tem certeza do estado inicial, você deve criar uma assertiva. Isso também o protege de futuras mudanças no código que talvez alterem o estado inicial do seu objeto.</p>

<p>Mas, testaremos todas as coisas que o método <code>add()</code> faz? Diria que não. Além da adição de um usuário, ele também configura várias coisas. Também deveríamos checá-las.</p>

<pre class="brush: php">function testItCanAddANewPlayer() {
	$this-&gt;assertEquals(0, count($this-&gt;game-&gt;players));
	$this-&gt;game-&gt;add('Um Jogador');
	$this-&gt;assertEquals(1, count($this-&gt;game-&gt;players));
	$this-&gt;assertEquals(0, $this-&gt;game-&gt;places[1]);
	$this-&gt;assertEquals(0, $this-&gt;game-&gt;purses[1]);
	$this-&gt;assertFalse($this-&gt;game-&gt;inPenaltyBox[1]);
}</pre>

<p>Está melhor. Verificamos cada ação que o método <code>add()</code> realiza. Desta vez, preferi testar diretamente o vetor <code>$players</code>. Por que? Poderíamos ter usado o método <code>howManyPlayers()</code>, que, basicamente, faz a mesma coisa, certo? Bem, neste caso, consideramos que é mais importante descrever nossas assertivas pelos efeitos que o método <code>add()</code> tem sobre o estado do objeto. Se precisarmos alterar o método <code>add()</code>, podemos esperar que o teste que verifica pelo seu comportamento restrito acabe falhando. Já passei por debates infinitos com meus colegas na Syneto, sobre isso. Especialmente porque esse tipo de teste produz um forte acoplamento entre o testes e a implementação do método <code>add()</code>. Então, se você preferir testá-lo de outra forma, não significará que suas ideias estão erradas.</p>

<p>Podemos ignorar com segurança o teste do retorno, as linhas <code>echoln()</code>. Eles apenas retornam o conteúdo para a tela. Não queremos tocar nesses métodos, ainda. Nosso <em>resultado esperado</em> depende desse retorno.</p>

<h3>Refatorando Testes (Novamente)</h3>

<p>Temos outro método testado com um teste completamente novo e passando. É hora de refatorar ambos, só um pouco. Comecemos com nossos testes. As três últimas assertivas não estão um pouco confusas? Elas não parece relacionar-se estritamente à adição de jogadores. Vamos mudá-las:</p>

<pre class="brush: php">function testItCanAddANewPlayer() {
	$this-&gt;assertEquals(0, count($this-&gt;game-&gt;players));
	$this-&gt;game-&gt;add('Um Jogador');
	$this-&gt;assertEquals(1, count($this-&gt;game-&gt;players));
	$this-&gt;assertDefaultPlayerParametersAreSetFor(1);
}</pre>

<p>Melhor. O método, agora, está mais abstrato, reusável, com um nome mais expressivo e esconde todos os detalhes não importantes.</p>

<h3>Refatorando o Método <code>add()</code></h3>

<p>Podemos fazer algo parecido em nosso código de produção.</p>

<pre class="brush: php">function add($playerName) {
	array_push($this-&gt;players, $playerName);
	$this-&gt;setDefaultPlayerParametersFor($this-&gt;howManyPlayers());

	echoln($playerName . " foi adicionado");
	echoln("Eles são o jogador número " . count($this-&gt;players));
	return true;
}</pre>

<p>Extraímos os detalhes não importantes para <code>setDefaultPlayerParametersFor()</code>.</p>

<pre class="brush: php">private function setDefaultPlayerParametersFor($playerId) {
	$this-&gt;places[$playerId] = 0;
	$this-&gt;purses[$playerId] = 0;
	$this-&gt;inPenaltyBox[$playerId] = false;
}</pre>

<p>Na verdade, essa ideia surgiu depois de ter escrito o teste. Este é um outro ótimo exemplo de como os testes nos forçam a pensar sobre nosso código em uma perspectiva diferente. Esse ângulo diferente do nosso problema, é o que devemos explorar e deixar nossos testes guiar o projeto do nosso código de produção.</p>

<h2>O Terceiro Método Testável</h2>

<p>É hora de buscarmos nosso terceiro método candidato para teste. O método <code>howManyPlayers()</code> é muito simples e, indiretamente, já foi testado, o método <code>roll()</code> é muito complexo para ser testado diretamente. Além disso, ele retorna <code>null</code>. O método <code>askQuestions()</code> para ser interessante, à primeira vista, porém, é só apresentação, sem valor de retorno.</p>

<p>O método <code>currentCategory()</code> é testável, mas <em>bastante</em> difícil de fazê-lo. É um seletor gigantesco com dez condições. Precisamos de um teste com dez linhas e também precisaremos refatorar o método, e também os testes, provavelmente. Devemos criar uma nota sobre esse método e retornar posteriormente, após terminarmos com os mais fáceis. Para nós, isso significa que o veremos no próximo artigo.</p>

<p>O método <code>wasCorrectlyAnswered()</code> também é complicado. Precisaremos extrair dele alguns pequenos trechos de códigos que serão testáveis. Contudo, o método <code>wrongAnswer()</code> parece ser promissor. Ele retorna coisas para a tela, mas também alterar o estado do objeto. Vejamos se podemos controlá-lo e testá-lo.</p>

<pre class="brush: php">function testWhenAPlayerEntersAWrongAnswerItIsSentToThePenaltyBox() {
	$this-&gt;game-&gt;add('Um Jogador');
	$this-&gt;game-&gt;currentPlayer = 0;
	$this-&gt;game-&gt;wrongAnswer();
	$this-&gt;assertTrue($this-&gt;game-&gt;inPenaltyBox[0]);
}</pre>

<p>ARGH... Foi muito difícil escrever esse método de teste. O método <code>wrongAnswer()</code> depende de <code>$this-&gt;currentPlayer</code> para sua lógica de comportamento, mas também usa <code>$this-&gt;players</code> na parte de apresentação. Um exemplo feito do porque você não misturar lógica e apresentação. Lidaremos com isso em um tutorial futuro. Por hora, já testamos que o usuário entra na caixa de penalidades. Também devemos observar uma condição que ainda não testamos, uma vez que apenas temos um único jogador e, assim, não satisfizemos a condição inicial. Poderíamos testar o valor final de <code>$currentPlayer</code>, contudo. Mas, adicionando essa linha de código ao teste fará ele falhar.</p>

<pre class="brush: php">$this-&gt;assertEquals(1, $this-&gt;game-&gt;currentPlayer);</pre>

<p>Uma olhada no método privado <code>shouldResetCurrentPlayer()</code> revela o problema. Se o índice do jogador atual for igual ao número de jogadores, ele será reiniciado a zero. Aaaahhh! Agora entramos no condicional <code>if()</code>!</p>

<pre class="brush: php">function testWhenAPlayerEntersAWrongAnswerItIsSentToThePenaltyBox() {
	$this-&gt;game-&gt;add('Um Jogador');
	$this-&gt;game-&gt;currentPlayer = 0;
	$this-&gt;game-&gt;wrongAnswer();
	$this-&gt;assertTrue($this-&gt;game-&gt;inPenaltyBox[0]);
	$this-&gt;assertEquals(0, $this-&gt;game-&gt;currentPlayer);
}

function testCurrentPlayerIsNotResetAfterWrongAnswerIfOtherPlayersDidNotYetPlay() {
	$this-&gt;addManyPlayers(2);
	$this-&gt;game-&gt;currentPlayer = 0;
	$this-&gt;game-&gt;wrongAnswer();
	$this-&gt;assertEquals(1, $this-&gt;game-&gt;currentPlayer);
}</pre>

<p>Bom. Criamos um segundo teste, para verificar o caso específico de existir jogadores que ainda não participaram do jogo. Não nos preocupamos com o estado <code>inPenaltyBox</code> para o segundo teste. Estamos apenas interessados no índice do jogador atual.</p>

<h2>O Último Método Testável</h2>

<p>O último método que podemos testar e refatorar é o método <code>didPlayerWin()</code>.</p>

<pre class="brush: php">function didPlayerWin() {
	$numberOfCoinsToWin = 6;
	return !($this-&gt;purses[$this-&gt;currentPlayer] == $numberOfCoinsToWin);
}</pre>

<p>Podemos observar, imediatamente, que sua estrutura de código é bastante similar a <code>isPlayable()</code>, o método que testamos no começo. Nossa solução será algo similar. Quando seu código é tão pequeno, apenas duas ou três linhas, realizar mais que um passo não é tão arriscado. No pior dos casos, você precisará desfazer três linhas de código. Então, façamos isso em apenas um passo.</p>

<pre class="brush: php">function testTestPlayerWinsWithTheCorrectNumberOfCoins() {
	$this-&gt;game-&gt;currentPlayer = 0;
	$this-&gt;game-&gt;purses[0] = Game::$numberOfCoinsToWin;
	$this-&gt;assertTrue($this-&gt;game-&gt;didPlayerWin());
}</pre>

<p>Espere! Isso causa uma falha. Como é possível? Não deveria passar? Provemos o número correto de moedas. Se estudarmos o método, descobriremos um pequeno fato enganador.</p>

<pre class="brush: php">return !($this-&gt;purses[$this-&gt;currentPlayer] == $numberOfCoinsToWin);</pre>

<p>O valor retornado, na verdade, é negado. Então, o método não está nos dizendo se um jogador ganhou, eles nos dizem que um jogador não ganhou o jogo! Poderíamos seguir e encontrar lugares onde esse método é usado e negar seu valor lá. Mas ela é usada no método <code>wasCorrectlyAnswered()</code>, um método que ainda não testamos. Talvez, por hora, uma simples renomeação para destacar a funcionalidade correta, seja o necessário.</p>

<pre class="brush: php">function didPlayerNotWin() {
	return !($this-&gt;purses[$this-&gt;currentPlayer] == self::$numberOfCoinsToWin);
}</pre>

<h2>Ideias &amp; Conclusão</h2>

<p>Então, é hora de resumir este tutorial. Embora não gostemos da negação no nome, esse é um acordo que podemos aceitar, por hora. Esse nome, com certeza, mudará ao começarmos a refatorar outras partes do código. Adicionalmente, se você der uma olhada nos testes, eles parecem estranhos, agora:</p>

<pre class="brush: php">function testTestPlayerWinsWithTheCorrectNumberOfCoins() {
	$this-&gt;game-&gt;currentPlayer = 0;
	$this-&gt;game-&gt;purses[0] = Game::$numberOfCoinsToWin;
	$this-&gt;assertFalse($this-&gt;game-&gt;didPlayerNotWin());
}</pre>

<p>Ao testar por falso em um método negado, buscando um valor que sugere vir um resultado verdadeiro, introduzimos uma baita confusão na legibilidade de nosso código. Mas, está bom, por enquanto. Uma vez que precisamos para um pouco, não é?</p>

<p>Em nosso próximo artigo, começaremos a trabalhar em algum dos métodos mais difíceis na classe <code>Game</code>. Obrigado pela leitura.</p>