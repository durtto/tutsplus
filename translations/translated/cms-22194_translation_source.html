<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>
<body>
  <h1>Construindo Com a API do Twitter: Usando Fluxos de Tempo Real</h1>

<p>Enquanto a <a href="https://dev.twitter.com/rest/public" target="_self">API REST do Twitter</a> é ótima para várias aplicações, se quiser atualizações imediatas e acesso a um conjunto maior de notificações, a <a href="https://dev.twitter.com/streaming/overview" target="_self">API de Fluxos do Twitter</a> (<em>Twitter Streaming API</em>) é essencial. Por exemplo, somente a API de fluxos dirá que outro usuário favoritou um de seus <em>tweets</em>.</p>

<p>Para usar a API de Fluxos é preciso uma conexão ativa e persistente (<em>keep-alive</em>) entre seu servidor e o Twitter. Esse tipo de implementação pode ser bem estranha para vários programadores PHP. Assim que um <em>tweet</em> é realizado, o Twitter notifica seu servidor em tempo real, permitindo você guardá-lo em sua base de dados sem o atraso da fila da API REST. O uso da API de fluxos também não está sujeito ao limite de uso da API do Twitter.</p>

<p>Eis uma visualização de como o processo funciona:</p>

<figure class="post_image">
  <img alt="How the Twitter Streaming API works" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/317/posts/22194/image/streaming-intro-2_1.png"/>
</figure>

<p>Há três variações da API de Fluxos do Twitter:</p>

<ol>
  <li><a href="https://dev.twitter.com/streaming/public" target="_self">O Fluxo Público</a>. Essa daqui permite que sua aplicação monitore dados públicos no Twitter, como <em>tweets</em> públicos, filtros de <em>tags</em>, etc.; </li>
  <li><a href="https://dev.twitter.com/streaming/userstreams" target="_self">O Fluxo do Usuário</a>. Essa permite você rastrear o fluxo de <em>tweets</em> de um usuário, em tempo real. A parte três desta série focará no fluxo do usuário. </li>
  <li><a href="https://dev.twitter.com/streaming/sitestreams" target="_self">Fluxos de Site</a>. Fluxos de site permitem sua aplicação monitorar os <em>feeds</em> de Twitter de vários usuários, em tempo real. </li>
</ol>

<p>O trabalho da sua implementação de fluxo é registrar os eventos que chegam tão logo eles apareçam e processá-los em plano de fundo, usando a API REST quando necessário, para obter mais dados. Fluxos de Site requerem <a href="https://dev.twitter.com/streaming/sitestreams#applyingforaccess" target="_self">aprovação prévia do Twitter</a>, que, geralmente, é reservada para grandes empresas e desenvolvedores.</p>

<p>Felizmente, há uma pequena biblioteca de código aberto, chamada <a href="https://github.com/tutsplus/phirehose" target="_self">Phirehose</a>, que implementa a maioria dos requerimentos da API de fluxos. Esse tutorial descreverá como integrar a Phirehose em sua aplicação de código aberto, Birdcage.</p>

<h2>A Biblioteca Phirehose</h2>

<p>A Phirehose é uma implementação fantástica em PHP e de código aberto dos requerimentos da API de Fluxos do Twitter, escrita por <a href="https://github.com/fennb" target="_self">Fenn Bailey</a>. Como descrito por ele, a Phirehose serve para:</p>

<ul class="task-list">
  <li>prover uma interface simples para a API de Fluxos do Twitter, para aplicações em PHP;</li>
  <li>obedecer as recomendações de manipulação de erros, reconexão, etc., da API de Fluxos;</li>
  <li>encorajar bons comportamentos de clientes da API de Fluxos</li>
  <li>operar independente de extensões PHP (por exemplo: <em>shared memory</em>, PCNTL, etc.)</li>
</ul>

<p>Pelo meu uso, ela opera praticamente sem erros. Veja a <a href="https://github.com/fennb/phirehose/wiki/Introduction" target="_self">documentação da Phirehose aqui</a>.</p>

<p>Ela foi criada para manter a conexão com o Twitter e responder ao <em>feed</em> de dados do Twitter enquanto opera de forma indefinida, sem interrupções. Não foi criada para processar dados minuciosos de <em>tweets</em> ou hidratação de dados, que foram descritos na <a href="http://code.tutsplus.com/tutorials/building-with-the-twitter-api-oauth-reading-and-posting--cms-22193" target="_self">parte dois desta série</a>. Isso pode ser feito separadamente.</p>

<h2>Executando a Phirehose Indefinidamente</h2>

<p>Geralmente, você não pode executar uma tarefa <em>cron</em> da web como uma operação persistente por tempo indefinido. É melhor criar um <em>daemon</em> de linha de comando.</p>

<p>Uma das poderosas funcionalidades que o <em>framework</em> <a href="http://code.tutsplus.com/articles/introduction-to-the-yii-framework--cms-20948" target="_self">Yii</a> oferece é a possibilidade de executar aplicações de linha de comando. Isso nos permitirá executar aplicações de linha de comando persistentes, criadas por nós, e que utilizam o <em>framework</em> PHP Birdcage e MySQL.</p>

<h3>Construindo uma Comando para Linha de Comando no Yii</h3>

<p>No diretório <code class="inline">/app/</code>, fora da pasta raiz acessível pela web, adicionaremos um arquivo <code class="inline">stream.php</code> que executará nosso comando de fluxo com o Phirehose, na linha de comando:</p>

<pre class="brush: php">&lt;?php
defined('YII_DEBUG') or define('YII_DEBUG',true);
$yii=dirname(__FILE__).'/../framework/yii.php';
$config=dirname(__FILE__).'/protected/config/main.php';
require_once($yii);
Yii::createConsoleApplication($config)-&gt;run();</pre>

<p>O próximo passo é construirmo o arquivo de comando, <code class="inline">StreamCommand.php</code>, no diretório <code class="inline">/app/protected/commands</code>:</p>

<pre class="brush: php">&lt;?php
class StreamCommand extends CConsoleCommand
{
    // teste com o Fluxo ./app/stream.php
    public function run($args)
    {
        // obtem as chaves de usuário do Twitter
        $result = Account::model()-&gt;findByPk(1);
        $c = new Consumer($result['oauth_token'],$result['oauth_token_secret'],Phirehose::METHOD_USER);
        // carrega as chaves do app do Twitter
        $app = UserSetting::model()-&gt;loadPrimarySettings();
        $c-&gt;consumerKey = $app['twitter_key'];
        $c-&gt;consumerSecret = $app['twitter_secret'];
        $c-&gt;consume();
    }
}</pre>

<p>Ele lançará o processo do Phirehose, o Consumer, usando nossas chaves de aplicação e usuário do Twitter.</p>

<p><i>Nota: Para o exemplo do fluxo do Birdcage, assumiremos que apenas uma conta de Twitter foi registrado e está fixa no código (account_id = 1).</i></p>

<h3>Integrando o Phirehose</h3>

<p>Para integrar o Phirehose no Birdcage, movi os arquivos <code class="inline">OAuthPhirehose.php</code> e <code class="inline">UserstreamPhirehose.php</code> para o diretório <code class="inline">/app/protected/components</code>. No meu arquivo de configuração, <code class="inline">main.php</code>, adicionei o <code class="inline">phirehose</code> à lista de componentes carregados:</p>

<pre class="brush: php">'preload'=&gt;array(
    'log',
    'bootstrap',
    'mailgun',
    'phirehose',
      'advanced'
    ),
</pre>

<p>Então, criei uma migração para a base de dados, criando uma tabela para gravar os dados originais do fluxo do Twitter:</p>

<pre class="brush: php">class m140919_193106_create_stream_table extends CDbMigration
{
 protected $MySqlOptions = 'ENGINE=InnoDB CHARSET=utf8 COLLATE=utf8_unicode_ci';
     public $tablePrefix;
     public $tableName;

     public function before() {
       $this-&gt;tablePrefix = Yii::app()-&gt;getDb()-&gt;tablePrefix;
       if ($this-&gt;tablePrefix &lt;&gt; '')
         $this-&gt;tableName = $this-&gt;tablePrefix.'stream';
     }

       public function safeUp()
    {
      $this-&gt;before();
      $this-&gt;createTable($this-&gt;tableName, array(
               'id' =&gt; 'pk',
               'tweet_id' =&gt; 'bigint(20) unsigned NOT NULL',
               'code' =&gt; 'text  NULL',
               'is_processed' =&gt; 'tinyint default 0',
               'created_at' =&gt; 'DATETIME NOT NULL DEFAULT 0',
               'modified_at' =&gt; 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP',
                 ), $this-&gt;MySqlOptions);
                 $this-&gt;createIndex('tweet_id', $this-&gt;tableName , 'tweet_id', true);

    }</pre>

<p>Também criei um modelo chamado <code class="inline">Consumer.php</code> que estende <code class="inline">OauthPhirehose</code> com o método <code class="inline">enqueueStatus</code> obrigatório. </p>

<p>Queremos minimizar a quantidade de processamento que a resposta em tempo real precisa realizar. Essencialmente, apenas queremos guardar os dados recebidos do Twitter em nossa base de dados e nada mais. Também podemos realizar outros processamentos em nossas próprias tarefas de plano de fundo sem atrapalhar a conexão do Phirehose. Minha função apenas pega os dados do <em>tweet</em> e o guarda na tabela <em>stream</em>:</p>

<pre class="brush: plain">&lt;?php
  class Consumer extends OauthPhirehose
  {
// Essa função é chamada automaticamente pela classe Phirehose
    // Quando um novo tweet é recebido com os dados JSON em $status
    public function enqueueStatus($status) {
      $stream_item = json_decode($status);
      if (!(isset($stream_item-&gt;id_str))) { return;}
      $s = new Stream;
      $s-&gt;tweet_id = $stream_item-&gt;id_str;
      $s-&gt;code = base64_encode(serialize($stream_item));
      $s-&gt;is_processed=0;
      $s-&gt;created_at = new CDbExpression('NOW()');
      $s-&gt;modified_at =new CDbExpression('NOW()');
      $s-&gt;save();
      var_dump($stream_item);
    }
  }
  ?&gt;
</pre>

<p>Nós dependeremos das tarefas de plano de fundo executadas pelo nosso <code class="inline">DaemonController</code> para processar os dados no modelo de <em>Tweet</em> do Bircdcage. Isso será descrito logo abaixo.</p>

<h3>Ativando o Phirehose</h3>

<p>Você pode testar o Pirehose usando o terminal de comandos do PHP:</p>

<p><code class="inline">php ./app/stream.php Stream</code></p>

<p>O Twitter enviará o fluxo informação de seguidores da conta do usuário, seguida pelos dados em tempo real, assim que chegar.</p>

<p>Para ativar o Phirehose como um comando de terminal sempre ativo e intermitente, usaremos o <a href="http://manpages.ubuntu.com/manpages/hardy/man1/nohup.1.html" target="_self">comando nohup</a>, por exemplo sem espera e redirecionamento do retorno para dev/null:</p>

<p><code class="inline">nohup php ./app/stream.php Stream &gt; /dev/null 2&gt;&amp;1&amp;</code></p>

<p>O Ubuntu retornará o id do seu processo para futuros monitoramento e finalização:</p>

<p><code class="inline">[1] 9768</code></p>

<p>Se quiser verificar se o processo está em execução, escaneie a lista de tarefas pelo id do processo:</p>

<p><code class="inline">ps -e all | grep 9768</code></p>

<p>Você deve ver algo mais ou menos assim:</p>

<p><code class="inline">0  1000  9768  9743  20   0 273112 16916 poll_s S    pts/0      0:00 php ./app/stream.php Stream</code></p>

<p>E você também pode finalizar o Phirehose eliminando-o através do id do processo:</p>

<p><code class="inline">kill 9768</code></p>

<p>Pela minha experiência, o Phirehose funcionou perfeitamente com essa técnica, operando sem interrupções durante as duas últimas semanas.</p>

<h2>Processando os Dados do Fluxo</h2>

<p>Também precisamos criar um processo de plano de fundo no Birdcage que processará os dados do fluxo das tabelas <em>Tweet</em>, <em>Mention</em>, <em>URL</em> e <em>Hashtag</em>—como se tivessem vindo da API REST.</p>

<p>Altere seu arquivo de configuração <code class="inline">twitter.ini</code> para que ele use os fluxos:</p>

<pre class="brush: bash">twitter_stream = true</pre>

<p>E podemos usar a mesma tarefa <em>cron</em> da parte dois, para executar essa operação:</p>

<pre class="brush: bash"># Para definir o temp, você proverá valores reais para
# minutos (m), horas (h), dia do mês (dom), mês (mon),
# e dia da semana (dow) ou usar '*' nesses campos (para 'qualquer um').#
# Perceba que as tarefas serão inicializadas de acordo a noção de tempo e
# fuso horários do sistema de daemon.
#
# Por exemplo, você pode executar um backup de todas as contas de usuário
# às 5 da manhã a cada semana:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
#
# m h  dom mon dow   command
*/5 * * * * wget -O /dev/null http://birdcage.yourdomain.com/daemon/index</pre>

<p>Assim, quando o DaemonController for chamado, ele ativará o método de processo <code class="inline">model()</code> de Stream:</p>

<pre class="brush: php">public function actionIndex() {
    // Se não usar fluxos do twitter, processaremos pela API REST
    if (!Yii::app()-&gt;params['twitter_stream']) {
      Tweet::model()-&gt;getStreams();
    } else {
      Stream::model()-&gt;process();
    }
  }</pre>

<p>O método do processo descompacta os dados de fluxo codificados e analisa cada entrada, da mesma forma que fizemos com a API REST:</p>

<pre class="brush: php">public function process() {
    // obtem tweets não processados da máquina de fluxos
    $account_id = 1;
    $items = Stream::model()-&gt;unprocessed()-&gt;findAll();
    foreach ($items as $i) {
      $tweet = unserialize(base64_decode($i['code']));
      Tweet::model()-&gt;parse($account_id,$tweet);
      $this-&gt;setStatus($i['id'],self::STREAM_PROCESSED);
    }
  }</pre>

<p>Atualmente, o Birdcage ignora os dados do fluxo que não seja um tweet, por exemplo, notificações, mensagens diretas, etc. Deixarei essa parte como tarefa para você—ou você pode verificar minha aplicação expandida, <a href="http://jeffreifman.com/birdhouse" target="_self">Birdhouse</a>.</p>

<h2>Finalizando</h2>

<p>Espero que tenha achado essa série em três partes sobre a API do Twitter bem informativa e útil. Você deve ter aprendido sobre OAuth, a API REST, a API de Fluxos, a construir uma base de dados para o Twitter, processar a linha do tempo com ambos os tipos de API, contar corretamente a quantidade de caracteres em um tweet e publicá-lo, e mais.</p>

<p>Deixe quaisquer comentários, correções ou ideias a mais. Você pode navegar todos os meus outros tutoriais no Tuts+ em <a href="http://tutsplus.com/authors/jeff-reifman" target="_self">minha página daqui</a> ou seguir-me no  <a href="https://twitter.com/intent/user?screen_name=reifman" target="_self">Twitter, em @reifman</a>.</p>
</body>
</html>