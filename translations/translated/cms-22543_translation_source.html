  <h1>Autenticação com Tokens Usando AngularJS &amp; NodeJS</h1>

<p>Uma das partes mais importantes de uma aplicação é sua autenticação. Neste tutorial, discutiremos sobre os sistemas de autenticação com <em>tokens</em> e como eles diferem dos sistemas tradicionais de <em>login</em>. Ao fim deste tutorial, você terá um aplicativo de demonstração totalmente funcional, criado com AngularJS e NodeJS</p>

<h2>Sistemas de Autenticação Tradicionais</h2>

<p>Antes de seguirmos para o sistema de autenticação com <em>tokens</em>, é bom entendermos melhor os sistemas de autenticação tradicionais primeiro.</p>

<ol>
  <li>O usuário provê um <strong>nome de usuário</strong> e uma <strong>senha</strong> através do formulário de <em>login</em> e clica em um botão de <strong>Login</strong>;</li>
  <li>Assim que a requisição é feita valida-se o usuário no <em>back-end</em>, consultando sua existência na base de dados. Se a requisição for válida, cria-se uma sessão usando a informação obtida da base de dados para, então, retornar a informação da sessão no cabeçalho da resposta, de modo que o ID da sessão seja salvo no navegador;</li>
  <li>Provê-se informação da sessão para ter acesso a áreas restritas da aplicação;</li>
  <li>Se a informação da sessão for válida, permite-se que o usuário acesse a área restrita especificado, retornando o HTML apropriado para a requisição;</li>
</ol>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/487/posts/22543/image/traditional-authentication-system-png.png" title="Image: https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/487/posts/22543/image/traditional-authentication-system-png.png"/>
</figure>

<p>Tudo corre bem até esse ponto. A aplicação web funciona muito bem e é capaz de autenticar os usuários para que tenham acesso às áreas restritas. Contudo, o que acontece quando se cria outro sistema cliente, um aplicativo para Android, por exemplo? Você será capaz de usar a aplicação atual para autenticar os usuários do aplicativo cliente móvel e servir o conteúdo restrito? Da forma atual, não. E existem dois motivos para isso:</p>

<ol>
  <li>Sessões e <em>cookies</em> não fazem sentido no contexto de aplicações móveis. Você não pode compartilhar sessões e <em>cookies</em> criados no lado do servidor com clientes móveis;</li>
  <li>Na aplicação atual, retorna-se o HTML gerado. Em um cliente móvel, você precisa que um JSON ou XML seja incluído na resposta;</li>
</ol>

<p>Neste caso, você precisa de uma aplicação que seja independente do cliente.</p>

<h2>Autenticação com <em>Tokens</em></h2>

<p>Na autenticação com <em>tokens</em>, não usaremos <em>cookies</em> nem sessões. Um <em>token</em> será usado para autenticar o usuário em cada requisição ao servidor. Reprojetemos nosso primeiro cenário de modo que use a autenticação com <em>tokens</em>.</p>

<p>Ela terá o seguinte controle de fluxo:</p>

<ol>
  <li>O usuário provê um <strong>nome de usuário</strong> e uma <strong>senha</strong> no formulário de <em>login</em> e clica no botão <strong>Login</strong>;</li>
  <li>Assim que a requisição é feita valida-se o usuário no <em>back-end</em>, consultando sua existência na base de dados. Se a requisição for válida, cria-se um <em>token</em>, usando a informação do usuário obtida da base de dados e o retornamos no cabeçalho de resposta, para que possamos guardá-lo no navegador usando armazenamento local;</li>
  <li>Provê-se o <em>token</em> em cada cabeçalho de requisição para áreas protegidas na aplicação;</li>
  <li>Se o <em>token</em> obtido no cabeçalho da requisição for válido, permite-se o acesso à área restrita requisitada, com retornando a resposta em formato JSON ou XML;</li>
</ol>

<p>Neste caso, não temos quaisquer <em>cookies</em> ou sessões retornadas bem como quaisquer conteúdo HTML. Isso significa que podemos usar essa arquitetura para qualquer cliente que a aplicação precisar. Você pode ver o esquema da arquitetura logo abaixo:</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/487/posts/22543/image/token-based-authentication-system-png.png"/>
</figure>

<p>O que seria esse JWT?</p>

<h2>JWT</h2>

<p>JWT significa <strong>JSON Web Token</strong> (em português, <em>Token</em> da Web em formato JSON) e é um formato de <em>token</em> usado em cabeçalhos de autorização. Esse <em>token</em> auxilia você no projeto de comunicação segura entre sistemas. Neste tutorial, chamaremos o JWT de "<em>token</em> do portador". Um <em>token</em> do portador consiste de três partes: cabeçalho, carga e assinatura.</p>

<ul>
  <li>O cabeçalho é a parte do <em>token</em> em que se guarda o tipo e método de criptografia, o qual também é criptografado com o método de base-64;</li>
  <li>A carga inclui a informação em si. Você pode colocar qualquer tipo de informação, como dados do usuário, informações de produtos e coisas do tipo, tudo guardado e criptografado em base-64;</li>
  <li>A assinatura consiste na combinação do cabeçalho, da carga e de uma chave secreta. A chave secreta deve ser mantida segura no lado do servidor;</li>
</ul>

<p>Você pode ver o esquema do JWT e um <em>token</em> exemplo logo abaixo:</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/487/posts/22543/image/jwt-schema-png.png"/>
</figure>

<p>Você não precisa implementar um gerador de <em>token do portador</em> uma vez que é possível encontrar versões existentes para várias linguagens de programação. Você pode ver várias delas logo abaixo:</p>

<table>
  <thead>
    <tr>
      <th>Linguagem</th>
      <th>URL da Biblioteca</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>NodeJS</td>
      <td><a href="http://github.com/auth0/node-jsonwebtoken">http://github.com/auth0/node-jsonwebtoken</a></td>
    </tr>
    <tr>
      <td>PHP</td>
      <td><a href="http://github.com/firebase/php-jwt">http://github.com/firebase/php-jwt</a></td>
    </tr>
    <tr>
      <td>Java</td>
      <td><a href="http://github.com/auth0/java-jwt">http://github.com/auth0/java-jwt</a></td>
    </tr>
    <tr>
      <td>Ruby</td>
      <td><a href="http://github.com/progrium/ruby-jwt">http://github.com/progrium/ruby-jwt</a></td>
    </tr>
    <tr>
      <td>.NET</td>
      <td><a href="http://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet">http://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet</a></td>
    </tr>
    <tr>
      <td>Python</td>
      <td><a href="http://github.com/progrium/pyjwt/">http://github.com/progrium/pyjwt/</a></td>
    </tr>
  </tbody>
</table>

<h2>Exemplo Prático</h2>

<p>Agora que já sabemos um pouco sobre autenticação com <em>tokens</em>, podemos continuar com um exemplo prático. Veja o esquema abaixo, o qual analisaremos em instantes:</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/487/posts/22543/image/real-life-architecture-png.png"/>
</figure>

<ol>
  <li>As requisições à API são realizadas por vários clientes, como aplicação web, cliente móveis, etc, para um propósito específico;</li>
  <li>As requisições são feitas à um serviço como <code><a href="https://api.suaaplicacaoexemplo.com">https://api.suaaplicacaoexemplo.com</a></code>. Se várias pessoas usam a aplicação, vários servidores podem ser necessários para servir a operação requisitada;</li>
  <li>Aqui, um balanceador de carga é usado para equilibrar as requisições de modo que use da melhor forma os servidores da aplicação no lado do servidor. Ao fazer uma requisição a <code><a href="https://api.suaaplicacaoexemplo.com">https://api.suaaplicacaoexemplo.com</a></code>, o balanceador de carga lidará com a requisição primeiro e então redirecionará o cliente para um servidor específico;</li>
  <li>Há uma aplicação e essa aplicação é implantada em vários servidores (server-1, server-2, ..., server-n). Toda vez que uma requisição é realizada a  <code><a href="https://api.suaaplicacaoexemplo.com">https://api.suaaplicacaoexemplo.com</a></code>, a aplicação do lado do servidor interceptará o cabeçalho de autorização da requisição e extrairá a informação do <em>token</em>. Uma consulta à base de dados será feita usando este <em>token</em>. Se ele for válido e possuir a permissão necessário para acessar a área requisitada, tudo continuará. Caso contrário, será retornado um código de resposta do tipo 403 (que indica um estado de acesso proibido);</li>
</ol>

<h2>Vantagens</h2>

<p>Autenticação com <em>tokens</em> tem várias vantagens que resolvem vários problemas. Seguem alguns deles:</p>

<ul>
  <li><strong>Serviços Independentes de Clientes:</strong> Na autenticação com <em>tokens</em>, um <em>token</em> é transferido através dos cabeçalhos de requisição ao invés de manter a informação de requisição em <em>cookies</em> e/ou sessões. Isso significa que não há qualquer estado. Você pode realizar requisições ao servidor a partir de qualquer cliente que seja capaz de realizar requisições HTTP;</li>
  <li><strong>CDN.</strong> Nas aplicações mais recentes, visões são geradas no <em>back-end</em> e o conteúdo HTML é retornado para o navegador. Lógica do <em>front-end</em> depende de código <em>back-end</em>. Não há necessidade em se fazer isso. Por exemplo, se estiver trabalhando em uma agência de <em>design</em> que codifica seu HTML, CSS e JavaScript, você precisará pegar parte desse código <em>front-end</em> e migrá-lo para o <em>back-end</em> para que possa gerá-lo usando dados do servidor. Após algum tempo, seu HTML gerado diferirá bastante daquilo que a agência codificou. Em autenticação com <em>tokens</em>, você pode desenvolver o <em>front-end</em> de um projeto de forma separada do código <em>back-end</em>. Seu código <em>back-end</em> retornará JSON ao invés de algum HTML gerado no servidor e você colocará a versão comprimida (com gzip) do código <em>front-end</em> em um CDN. Ao acessar sua página, o conteúdo HTML será servido do CDN e o conteúdo da página será populado a partir dos serviços de API usando os cabeçalhos de autenticação com <em>tokens</em>;</li>
  <li><strong>Sem Cookie e/ou Sessões (ou Nada de CSRF).</strong> CSRF (<em>Cross-site Request Forgery</em>) é um dos grandes problema na segurança de aplicações web, porque não se verifica se uma requisição é confiável ou não. Para resolver esse problema, uma pilha de <em>tokens</em> é usada para ser enviada em cada requisição de formulários. Na autenticação com <em>tokens</em>, um <em>token</em> é usado no cabeçalho de autorização e o CSRF não inclui essa informação;</li>
  <li><strong>Gravação Pesistente de <em>Token</em>.</strong> Quanto uma operação de leitura, escrita ou remoção de sessão é feita na aplicação, ela realizará uma ação com arquivos no sistema de arquivos do sistema operacional no diretório <code class="inline">temp</code>, pelo menos na primeira vez. Digamos que você possui vários servidores e uma sessão é criada no primeiro servidor. Ao realizar outra requisição, ela é enviada para outro servidor, onde a informação de sessão não existe e você receberá uma resposta de "não autorização". Certo, é possível resolver esse problema com uma sessão persistente. Contudo, na autenticação com <em>tokens</em>, esse caso sequer existe. Não há necessidade de sessões persistentes, porque o <em>token</em> de requisição é interceptado em cada requisição de qualquer servidor;</li>
</ul>

<p>Essas são as vantagens mais comuns de autenticação e comunicação com <em>tokens</em>. Esse é o fim do papo teórico sobre o assunto. É hora de um exemplo prático.</p>

<h2>Exemplo de Aplicação</h2>

<p>Veremos duas aplicações para demonstrar a autenticação com <em>tokens</em>:</p>

<ol>
  <li>token-based-auth-back-end</li>
  <li>token-based-auth-front-end</li>
</ol>

<p>No projeto <em>back-end</em>, termos implementações de serviços e os retornos destes serão no formato JSON. Não será retornada qualquer visão pelos serviços. No projeto <em>front-end</em>, teremos códigos em AngularJS e HTML, o qual será populado pelos serviços em AngularJS que farão requisições ao serviços do projeto <em>back-end</em>.</p>

<h3>token-based-auth-back-end</h3>

<p>No projeto <em>back-end</em> temos três arquivos principais:</p>

<ul>
  <li><code class="inline">package.json</code> para a administração de dependências;</li>
  <li><code class="inline">models\User.js</code> conterá um modelo de usuários, User, que será usado para realizar as operações na base de dados sobre os usuários;</li>
  <li><code class="inline">server.js</code> é para inicialização e manipulação de requisições;</li>
</ul>

<p>E é isso! Esse projeto é bem simples, assim você poderá entender o conceito base facilmente, sempre precisarmos irmos mais a fundo.</p>

<pre class="brush: javascript">{
"name": "angular-restful-auth",
  "version": "0.0.1",
  "dependencies": {
    "express": "4.x",
    "body-parser": "~1.0.0",
    "morgan": "latest",
    "mongoose": "3.8.8",
    "jsonwebtoken": "0.4.0"
  },
  "engines": {
    "node": "&gt;=0.10.0"
  }
}</pre>

<p>O arquivo <code class="inline">package.json</code> contém as dependências do projeto: <code class="inline">express</code> para a estrutura em MVC, <code class="inline">body-parser</code> para simular simular a manipulação de requisição POST no NodeJS, <code class="inline">morgan</code> para registro de requisições, <code class="inline">mongoose</code> para que nosso <em>framework</em> ORM possa conectar-se ao MongoDB, e o <code class="inline">jsonwebtoken</code> para a criação de <em>tokens</em> JWT a partir de nossos modelos <code class="inline">User</code>. Também há um atributo chamado <code class="inline">engines</code> que especifica que o projeto usa o NodeJS de versão maior ou igual a 0.10.0. Isso é útil para serviços PaaS, como o Heroku. Também falaremos desse tópico em outra seção.</p>

<pre class="brush: javascript">var mongoose = require('mongoose');
var Schema       = mongoose.Scema;

var UserSchema   = new Schema({
    email: String,
    password: String,
    token: String
});

module.exports = mongoose.model('User', UserSchema);</pre>

<p>Dissemos que geraríamos um <em>token</em> usando o conteúdo do modelo <code class="inline">User</code>. Esse modelo nos ajudará a realizar operações sobre o MongoDB. No arquivo <code class="inline">User.js</code>, definimos o esquema do usuário e o modelo <code class="inline">User</code>, este último utilizando um modelo do <code class="inline">mongoose</code>. Este modelo está pronto para operações com a base de dados.</p>

<p>Nossas dependências estão definidas e nosso modelo <code class="inline">User</code> também, então, combinemos eles para construir um serviço para manipular requisições específicas.</p>

<pre class="brush: javascript">// Módulos Obrigatórios
var express= require("express");
var morgan     = require("morgan");
var bodyParser = require("body-parser");
var jwt        = require("jsonwebtoken");
var mongoose   = require("mongoose");
var app        = express();</pre>

<p>No NodeJS, você pode incluir um módulo em seu projeto usando a função <code class="inline">require</code>. Primeiro, precisamos importar os módulos necessários para dentro do projeto:</p>

<pre class="brush: javascript">var port = process.env.PORT || 3001;
var User = require('./models/User');

// Conecta-se o Banco de Dados
mongoose.connect(process.env.MONGO_URL);</pre>

<p>Nossos serviços serão servidos através de uma porta específica. Se alguma porta nas variáveis do ambiente do sistema for indicada, você pode usá-la. Em nosso caso, preferimos definir a porta <code class="inline">3001</code>. Logo depois, o modelo <code class="inline">User</code> é incluído e a conexão com a base de dados é estabelecida para que possamos realizar algumas operações em relação ao modelo. Não esqueça de definir uma variável de ambiente—<code class="inline">MONGO_URL</code>—para a URL da conexão com a base de dados.</p>

<pre class="brush: javascript">app.use(bodyParser.urlencoded({ extended: true }));
app.use(bodyParser.json());
app.use(morgan("dev"));
app.use(function(req, res, next) {
res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST');
    res.setHeader('Access-Control-Allow-Headers', 'X-Requested-With,content-type, Authorization');
    next();
});</pre>

<p>Na seção acima, criamos algumas configurações para a simulação de manipulação de requisições HTTP no NodeJS usando Express. Nós demos permissão de requisições que venham de domínios diferentes para que possamos criar um sistema independente de cliente. Se não quiser permitir isso, você se deparará com um erro CORS (<em>Cross Origin Request Sharing</em>) no navegador.</p>

<ul>
  <li><code class="inline">Access-Control-Allow-Origin</code> permitido para todos os domínios;</li>
  <li>Você pode realizar requisições <code class="inline">POST</code> e <code class="inline">GET</code> para este serviço;</li>
  <li>Cabeçalhos <code class="inline">X-Requested-With</code> e <code class="inline">content-type</code> são permitidos;</li>
</ul>

<pre class="brush: javascript">app.post('/authenticate', function(req, res) {
User.findOne({email: req.body.email, password: req.body.password}, function(err, user) {
        if (err) {
            res.json({
                type: false,
                data: "Error occured: " + err
            });
        } else {
            if (user) {
               res.json({
                    type: true,
                    data: user,
                    token: user.token
                });
            } else {
                res.json({
                    type: false,
                    data: "Incorrect email/password"
                });
            }
        }
    });
});</pre>

<p>Importamos todos os módulos necessários e definimos nossa configuração, assim, é hora de definir os manipuladores de requisição. No código acima, toda vez que você realização uma requisição <code class="inline">POST</code> ao endereço <code class="inline">/authenticate</code> com um nome de usuário e senha, você receberá um <em>token</em> <code class="inline">JWT</code>. Primeiro, a base de dados consultará pelo nome de usuário e senha. Se o usuário existir, os dados do usuário serão retornado com o <em>token</em>. Mas, e se não existir qualquer usuário para o conjunto de nome de usuário e senha informados??</p>

<pre class="brush: javascript">app.post('/signin', function(req, res) {
User.findOne({email: req.body.email, password: req.body.password}, function(err, user) {
        if (err) {
            res.json({
                type: false,
                data: "Error occured: " + err
            });
        } else {
            if (user) {
                res.json({
                    type: false,
                    data: "User already exists!"
                });
            } else {
                var userModel = new User();
                userModel.email = req.body.email;
                userModel.password = req.body.password;
                userModel.save(function(err, user) {
                    user.token = jwt.sign(user, process.env.JWT_SECRET);
                    user.save(function(err, user1) {
                        res.json({
                            type: true,
                            data: user1,
                            token: user1.token
                        });
                    });
                })
            }
        }
    });
});</pre>

<p>Ao realizar uma requisição <code class="inline">POST</code> para <code class="inline">/signin</code> com um nome de usuário e senha, um novo usuário será criado usando os dados informados. Na linha <code class="inline">19</code>, você pode ver que um novo <em>token</em> JSON é gerado usando o módulo <code class="inline">jsonwebtoken</code>, o qual foi atribuído à variável <code class="inline">jwt</code>. A parte de autenticação está pronta. E se quisermos acessar alguma área restrita? Como administrar o acesso a essas áreas?</p>

<pre class="brush: javascript">app.get('/me', ensureAuthorized, function(req, res) {
User.findOne({token: req.token}, function(err, user) {
        if (err) {
            res.json({
                type: false,
                data: "Error occured: " + err
            });
        } else {
            res.json({
                type: true,
                data: user
            });
        }
    });
});</pre>

<p>Ao realizar um requisição <code class="inline">GET</code> para <code class="inline">/me</code>, você obterá informação do usuário atual, mas antes de retorná-la, a função <code class="inline">ensureAuthorized</code> será executada.</p>

<pre class="brush: javascript">function ensureAuthorized(req, res, next) {
var bearerToken;
    var bearerHeader = req.headers["authorization"];
    if (typeof bearerHeader !== 'undefined') {
        var bearer = bearerHeader.split(" ");
        bearerToken = bearer[1];
        req.token = bearerToken;
        next();
    } else {
        res.send(403);
    }
}</pre>

<p>Nesta função, cabeçalhos de requisição são interceptados e o cabeçalho <code class="inline">authorization</code> é extraído. Se o <em>token</em> do portador existir nesse cabeçalho, ele será atribuído a <code class="inline">req.token</code> para que seja utilizado durante a requisição e a requisição pode continuar, apenas chamando a função <code class="inline">next()</code>. Se um <em>token</em> não existir, você receberá uma resposta 403 (Acesso Proibido). Voltemos ao manipulador <code class="inline">/me</code> e usemos a propriedade <code class="inline">req.token</code> para buscar os dados do usuário deste <em>token</em>. Toda vez que você cria um novo usuário, um <em>token</em> é gerado e salvo no modelo <code class="inline">User</code> correspondente da base de dados. Esses <em>tokens</em> são únicos.</p>

<p>Só teremos três manipuladores para esse projeto, que é bem simples. Após isso, você verá;</p>

<pre class="brush: javascript">process.on('uncaughtException', function(err) {
console.log(err);
});</pre>

<p>O aplicativo NodeJS pode parar se algum erro acontecer. Com o código acima, prevenimos essa parada e registramos esse erro na <em>linha de comando</em>. Finalmente, podemos iniciar o servidor, usando o trecho de código a seguir. </p>

<pre class="brush: javascript">// Start Server
app.listen(port, function () {
console.log( "Servidor Express observando a porta " + port);
});</pre>

<p>Resumindo:</p>

<ul>
  <li>Módulos são importados;</li>
  <li>Configuração são criadas;</li>
  <li>Manipuladores de requisição são definidos;</li>
  <li>Um mediador é definido para interceptar e proibir acesso a áreas restritas;</li>
  <li>O servidor é inicializado;</li>
</ul>

<p>E terminamos o serviço <em>back-end</em>. Para que ele seja usado por vários clientes, você pode implantá-lo em seus servidores ou, quem sabe, enviá-lo para o Heroku. Há um arquivo chamado <code class="inline">Procfile</code> no diretório raiz do projeto. Implantemos nosso serviço no Heroku.</p>

<h4>Implantando no Heroku</h4>

<p>Você pode clonar o projeto <em>back-end</em> deste <a href="http://github.com/cubuzoa/token-based-auth-back-end" target="_self">repositório do GitHub</a>.</p>

<p>Não discutirei sobre como criar um aplicativo no Heroku; você pode acessar <a href="http://devcenter.heroku.com/articles/creating-apps" rel="external" target="_blank">esse artigo</a> e verificar como criar um aplicativo no Heroku caso não o tenha feito antes. Após criar seu aplicativo no Heroku, você pode adicionar um destino para seu projeto atual, usando o comando a seguir:</p>

<pre class="brush: bash">git remote add heroku &lt;your_heroku_git_url&gt;</pre>

<p>Você clonou e adicionou um destino ao seu projeto. Após executar <code class="inline">git add</code> e <code class="inline">git commit</code>, você pode enviar seu código para o Heroku executando o comando <code class="inline">git push heroku master</code>. Se o envio for bem sucedido, o Heroku executará o comando <code class="inline">npm install</code> para baixar todas as dependências no diretório <code class="inline">temp</code> do Heroku. Após isso, ele iniciará sua aplicação e poderá usar seu serviço usando o protocolo HTTP.</p>

<h3>token-based-auth-front-end</h3>

<p>No projeto <em>front-end</em>, você verá um projeto criado com AngularJS. Só mencionarei aqui as principais partes do projeto <em>front-end</em>, porque o AngularJS não é algo que pode ser visto em apenas um tutorial.</p>

<p>Você pode clonar o projeto a partir <a href="https://github.com/cubuzoa/token-based-auth-front-end" target="_self">deste repositório do GitHub</a>. Nesse projeto, você verá a estrutura de diretório a seguir:</p>

<figure class="post_image">
  <img alt="Folder Structure" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/487/posts/22543/image/folder structure.png"/>
</figure>

<p>A <code class="inline">ngStorage.js</code> é uma biblioteca que permite o AngularJS realizar operações de manipulação de armazenamento local. Além disso, temos o <em>layout</em> principal <code class="inline">index.html</code> e os parciais que estendem o <em>layout</em> principal e se encontram dentro do diretório <code class="inline">partials</code>. O arquivo <code class="inline">controllers.js</code> é para definirmos as ações do nosso controlador <em>front-end</em>. O arquivo <code class="inline">services.js</code> é para realizar requisições de serviço ao nosso projeto recém criado. Temos uma espécie de arquivo de inicialização, <code class="inline">app.js</code>, que contém as configurações e importações de módulos. Finalmente, temos o arquivo <code class="inline">client.js</code> para servir os arquivos HTML estáticos (ou só o arquivo <code class="inline">index.html</code>, neste caso); isso ajudará a servir arquivos HTML estáticos ao implantar em um lugar sem o servidor web Apache ou algo do tipo.</p>

<pre class="brush: html">...
&lt;script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js"&gt;&lt;/script&gt;
&lt;script src="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"&gt;&lt;/script&gt;
&lt;script src="//cdnjs.cloudflare.com/ajax/libs/angular.js/1.2.20/angular.min.js"&gt;&lt;/script&gt;
&lt;script src="//cdnjs.cloudflare.com/ajax/libs/angular.js/1.2.20/angular-route.min.js"&gt;&lt;/script&gt;
&lt;script src="/lib/ngStorage.js"&gt;&lt;/script&gt;
&lt;script src="/lib/loading-bar.js"&gt;&lt;/script&gt;
&lt;script src="/scripts/app.js"&gt;&lt;/script&gt;
&lt;script src="/scripts/controllers.js"&gt;&lt;/script&gt;
&lt;script src="/scripts/services.js"&gt;&lt;/script&gt;
&lt;/body&gt;</pre>

<p>No arquivo HTML do <em>layout</em> principal, todos os arquivos JavaScript necessários são incluídos, sejam eles biblioteca relacionadas ao AngularJS ou nossos controladores, serviços e arquivo <code class="inline">app</code> customizados.</p>

<pre class="brush: javascript">'use strict';

/* Controladores */

angular.module('angularRestfulAuth')
.controller('HomeCtrl', ['$rootScope', '$scope', '$location', '$localStorage', 'Main', function($rootScope, $scope, $location, $localStorage, Main) {

        $scope.signin = function() {
            var formData = {
                email: $scope.email,
                password: $scope.password
            }

            Main.signin(formData, function(res) {
                if (res.type == false) {
                    alert(res.data)
                } else {
                    $localStorage.token = res.data.token;
                    window.location = "/";
                }
            }, function() {
                $rootScope.error = 'Falha ao tentar acessar';
            })
        };

        $scope.signup = function() {
            var formData = {
                email: $scope.email,
                password: $scope.password
            }

            Main.save(formData, function(res) {
                if (res.type == false) {
                    alert(res.data)
                } else {
                    $localStorage.token = res.data.token;
                    window.location = "/"
                }
            }, function() {
                $rootScope.error = 'Falha ao registrar-se';
            })
        };

        $scope.me = function() {
            Main.me(function(res) {
                $scope.myDetails = res;
            }, function() {
                $rootScope.error = 'Falha ao buscar os dados';
            })
        };

        $scope.logout = function() {
            Main.logout(function() {
                window.location = "/"
            }, function() {
                alert("Falha ao sair!");
            });
        };
        $scope.token = $localStorage.token;
    }])</pre>

<p>No código acima, o controlador <code class="inline">HomeCtrl</code> é criado e alguns módulos necessários são injetados, como o <code class="inline">$rootScope</code> e <code class="inline">$scope</code>. Injeção de Dependência é uma das funcionalidades mais fortes do AngularJS. A <code class="inline">$scope</code> é a variável que interliga os controladores e visões no AngularJS e isso significa que você pode usar <code class="inline">test</code> em alguma visão se o tiver definido em algum controlador, assim <code class="inline">$scope.test=....</code> </p>

<p>Neste controlador, algumas funções utilitárias são definidas, como:</p>

<ul>
  <li><code class="inline">signin</code> para configurar o botão de acesso no formulário de acesso</li>
  <li><code class="inline">signup</code> para a manipulação do formulário de cadastro</li>
  <li><code class="inline">me</code> para lidar com o botão <code class="inline">Me</code> no <em>layout</em></li>
</ul>

<p>No <em>layout</em> principal, na lista do menu principal, você pode ver o atributo <code class="inline">data-ng-controller</code> com o valor <code class="inline">HomeCtrl</code>. Isso significa que o elemento <code class="inline">dom</code> deste menu pode compartilhar seu escopo com o controlador <code class="inline">HomeCtrl</code>. Ao clicar no botão de acesso no formulário, a função de acesso (<code class="inline">signin</code>) no controlador será executada, e nesta função o serviço de cadastro será usado a partir do serviço principal, <code class="inline">Main</code>, que já estará injetado no controlador. </p>

<p>A estrutura principal é <code class="inline">visão -&gt; controlador -&gt; serviço</code>. Este serviço torna bem simples as requisições Ajax ao projeto <em>back-end</em> para obter dados.</p>

<pre class="brush: javascript">'use strict';

angular.module('angularRestfulAuth')
.factory('Main', ['$http', '$localStorage', function($http, $localStorage){
        var baseUrl = "a_url_do_seu_servico";
        function changeUser(user) {
            angular.extend(currentUser, user);
        }

        function urlBase64Decode(str) {
            var output = str.replace('-', '+').replace('_', '/');
            switch (output.length % 4) {
                case 0:
                    break;
                case 2:
                    output += '==';
                    break;
                case 3:
                    output += '=';
                    break;
                default:
                    throw 'Cadeia de caracteres base64url inválida!';
            }
            return window.atob(output);
        }

        function getUserFromToken() {
            var token = $localStorage.token;
            var user = {};
            if (typeof token !== 'undefined') {
                var encoded = token.split('.')[1];
                user = JSON.parse(urlBase64Decode(encoded));
            }
            return user;
        }

        var currentUser = getUserFromToken();

        return {
            save: function(data, success, error) {
                $http.post(baseUrl + '/signin', data).success(success).error(error)
            },
            signin: function(data, success, error) {
                $http.post(baseUrl + '/authenticate', data).success(success).error(error)
            },
            me: function(success, error) {
                $http.get(baseUrl + '/me').success(success).error(error)
            },
            logout: function(success) {
                changeUser({});
                delete $localStorage.token;
                success();
            }
        };
    }
]);</pre>

<p>No trecho de código acima, você pode ver que as funções do serviço gostam de realizar requisições para autenticação. Você deve ter visto no arquivo controller.js que há funções como <code class="inline">Main.me</code>. Esse serviço <code class="inline">Main</code> foi injetado no controlador. Enquanto no controlador, os serviços pertencentes a este serviço podem ser chamados diretamente. </p>

<p>Essas funções são simples requisições Ajax para nosso serviço, que criamos mais cedo. Não esqueça de alterar a url na variável <code class="inline">baseUrl</code> no código acima. Ao implantar o serviço no Heroku, você receberá um URL no estilo <code class="inline">nome-do-aplicativo.herokuapp.com</code>. No trecho acima, você atribuirá essa URL dessa forma <code class="inline">var baseUrl = "appname.herokuapp.com"</code>. </p>

<p>Nas partes de cadastro ou acesso da aplicação, recebemos um <em>token</em> de portador que é salvo no armazenamento local. Toda vez que realizamos uma requisição ao serviço no <em>back-end</em>, precisamos passar esse <em>token</em> nos cabeçalhos. Você pode fazer isso através dos interceptadores do AngularJS.</p>

<pre class="brush: javascript">$httpProvider.interceptors.push(['$q', '$location', '$localStorage', function($q, $location, $localStorage) {
        return {
                'request': function (config) {
                    config.headers = config.headers || {};
                    if ($localStorage.token) {
                        config.headers.Authorization = 'Portador ' + $localStorage.token;
                    }
                    return config;
                },
                'responseError': function(response) {
                    if(response.status === 401 || response.status === 403) {
                        $location.path('/signin');
                    }
                    return $q.reject(response);
                }
            };
        }]);</pre>

<p>No trecho de código acima, cada requisição é interceptada e um cabeçalho de autorização e seu valor são colocados inseridos.</p>

<p>No projeto <em>front-end</em>, temos algumas páginas parciais como <code class="inline">signin</code>, <code class="inline">signup</code>, <code class="inline">detalhes do perfil</code> e <code class="inline">vb</code>. Essas páginas parciais estão relacionadas a controladores específicos. Você pode ver essa relação no arquivo <code class="inline">app.js</code>:</p>

<pre class="brush: javascript">angular.module('angularRestfulAuth', [
'ngStorage',
    'ngRoute'
])
.config(['$routeProvider', '$httpProvider', function ($routeProvider, $httpProvider) {

    $routeProvider.
        when('/', {
            templateUrl: 'partials/home.html',
            controller: 'HomeCtrl'
        }).
        when('/signin', {
            templateUrl: 'partials/signin.html',
            controller: 'HomeCtrl'
        }).
        when('/signup', {
            templateUrl: 'partials/signup.html',
            controller: 'HomeCtrl'
        }).
        when('/me', {
            templateUrl: 'partials/me.html',
            controller: 'HomeCtrl'
        }).
        otherwise({
            redirectTo: '/'
        });</pre>

<p>É bem fácil entender o código acima. Ao acessar a URL <code class="inline">/</code> do seu serviço, a página <code class="inline">home.html</code> será gerada. Outro exemplo: se você acessar a URL <code class="inline">/signup</code>, a página <code class="inline">signup.html</code>será gerada. Essa operação de geração da página será realizada no navegador, não no lado do servidor.</p>

<h2>Conclusão</h2>

<p>Você pode ver os projetos que discutimos aqui, em pleno funcionamento, acessando <a href="http://token-based-auth.herokuapp.com/" target="_self">esse projeto de demonstração</a>.</p>

<p>Sistemas de autenticação com <em>tokens</em> ajudam a construir sistemas de autenticação/autorização e, ao mesmo tempo, criar serviços independentes de clientes. Usando essa tecnologia, você apenas focará em seus serviços (ou APIs). </p>

<p>A parte de autenticação/autorização será manipulada pelo sistema de autenticação com <em>tokens</em>, na forma de uma camada antes dos seus serviços. Você pode acessar e usar seus serviços a partir de quaisquer clientes, como navegadores, aplicativos Android, aplicativos iOS ou de um cliente <em>desktop</em>.</p>