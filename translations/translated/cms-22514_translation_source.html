<h1>Focando no Trabalho em Equipe Com Git</h1>

<p>O Git traz inúmeros benefícios para um desenvolvedor, mas também brilha quando se trata de colaboração em equipe.</p>

<p>A comunicação é a chave para criar um ótimo fluxo de trabalho em equipe com o Git. O Git é versátil, flexível e acomoda uma variedade de padrões de uso. Decidir de antemão as "regras de uso" para o fluxo de trabalho ajudará a eliminar problemas e confusões, e permitirá que a equipe aproveite o que o Git faz de melhor: aumentar a produtividade.</p>

<p>Dito isso, não teríamos um tutorial se esse artigo não provesse um fluxo de trabalho para equipes, baseado no Git e tangível, para você conhecer. O exemplo a seguir é baseado no famoso fluxo de trabalho com Git, criado por Vincent Driessen e chamado de <a href="http://nvie.com/posts/a-successful-git-branching-model/" rel="external" target="_blank">Git-Flow</a>, embora ele seja um pouco diferente em alguns aspectos chaves. Há inúmeros fluxos de trabalho disponíveis para o Git pela web&mdash;sugiro que você leia o máximo que puder e escolha o conjunto que melhor se encaixa em seu trabalho.</p>

<p>Comecemos sua pesquisa com o fluxo de trabalho a seguir:</p>

<h2>A Regra Máxima</h2>

<p>O ramo <code class="inline">master</code> sempre será publicável. <em>Sempre.</em></p>

<p>Um ramo <code class="inline">master</code> publicável é importante por vários motivos. Primeiro, permite que qualquer pessoa nova no projeto possa obtê-lo e executá-lo sem erros, imediatamente. Nada é mais frustrante que não ser capaz de executar um projeto que não somos familiarizados.</p>

<p>Segundo, o <code class="inline">master</code> mostra o estado atual do código para produção ou do código lançado. Se ajustes precisarem ser feitos, fica claro de onde devemos criar novas ramificações.</p>

<p>Por último, um <code class="inline">master</code> publicável é retorno garantido. Se o <code class="inline">master</code> sempre for publicável, sempre poderemos publicar sem medo. Medo causa estresse e estresse causa indigestão. Ninguém precisa disso.</p>

<h2>Estratégias de Ramificação</h2>

<p>O ramo <code class="inline">develop</code> deve ser o principal ramo do desenvolvimento corrente. Ramificações de funcionalidades são criadas e fundidas de volta (<em>merged</em>) no ramo <code class="inline">develop</code>, e o ramo <code class="inline">develop</code> representa o estado mais avançado do código.</p>

<p>Uma vez que os ramos <code class="inline">master</code> e <code class="inline">develop</code> são permanentes e bastante trafegados, nunca se deve trabalhar diretamente neles. Ao invés disso, todo o trabalho deve ser realizado em ramificações de funcionalidades. Ao implementar uma nova funcionalidade, ramifique a partir do <code class="inline">develop</code> e crie o código que implementa a funcionalidade.</p>

<h2>E O Que Tem o Nome?</h2>

<p>Não há regras fixas para a nomeação de ramificações, principalmente para ramos de funcionalidades. Agora, se o ramo é de ajustes, é costume utilizar o prefixo "fix-". Se o ramo é de lançamento, geralmente é encorajado seguir o formato: "release-X.X.X".</p>

<p>No geral, nomes de ramos devem ser descritivos. Até divertidos. Uma piadinha ocasional e na hora certa, jamais será esquecida.</p>

<h2>Você diz “Merge”, Eu digo “Rebase”</h2>

<p>Assim que sua nova funcionalidade estiver codificada, é hora de colocá-la de volta ao ramo compartilhado (assumamos que fundiremos ao ramo <code class="inline">develop</code>). Mas, antes de fundir ao ramo <code class="inline">develop</code>, tenha certeza que sua ramificação possui as últimas atualizações do ramo <code class="inline">develop</code>, já que pode haver conflitos.</p>

<p>Todas as soluções de conflito devem ser realizadas na sua ramificação. Se você ramificou para realizar algum ajuste pequeno e <em>não enviou para o ramo remoto</em>, ajuste o ramo <code class="inline">develop</code> como a base da sua ramificação, usando <em>rebase</em> e, só então, funda-a com o ramo <code class="inline">develop</code>. Envie para o ramo remoto e sinta-se livre para apagar sua ramificação local.</p>

<p>Se tiver enviado sua ramificação para o ramo remoto, primeiro funda o ramo <code class="inline">develop</code> em sua ramificação (resolvendo os conflitos) e, depois, funda sua ramificação no ramo <code class="inline">develop</code> novamente. Envie para o ramo remoto e sinta-se livre para apagar sua ramificação local.</p>

<p>Ao usar o <em>rebase</em>, tenha em mente que é um comando <em>destrutivo</em>. Então, tenha cuidado! O <em>rebase</em> é bastante útil para limpar históricos de <em>envio de códigos</em>, mas não se quer reescrever o histórico de qualquer coisa que tenha sido compartilhado com outra pessoa.</p>

<p>Eis algumas regras para se ter em mente ao utilizar o <em>rebase</em>:</p>

<ul>
  <li>Nunca utilize <em>rebase</em> que tenha sido enviado para o ramo remoto. A ramificação que está trabalhando está <em>somente</em> local? Então é perfeito para usar o <em>rebase</em>. Caso contrário, <em><strong>não</strong> use rebase</em>.</li>
  <li>Use <em>rebase</em> com ramos compartilhados e ramificações locais. O ramo <code class="inline">develop</code> é um ramo compartilhado. A ramificação <code class="inline">my-awesome-feature</code> é local. Já estou pronto para fundir <code class="inline">my-awesome-feature</code> no ramo <code class="inline"> develop</code>, mas quero ter certeza que todas as mudanças que surgiram no ramo <code class="inline">develop</code> sejam fundidas primeiro à minha ramificação:</li>
</ul>

<pre class="brush: bash">git checkout my-awesome-feature
git rebase develop
git checkout develop
git merge my-awesome-feature</pre>

<h2>Una-se A Um Amigo</h2>

<p>Criamos a ramificação, codificamos a funcionalidade, fundimos/fizemos <em>rebase</em> do <code class="inline">develop</code> e estamos prontos para fundir nosso código de volta no <code class="inline">develop</code>. Mas, será que devemos mesmo? Talvez alguém devesse revisar nossas alterações primeiro...</p>

<p>Revisões de código são algo bom! Elas permitem você obter críticas bastante construtivas no trabalho que você fez e&mdash;se nada mais acontecer&mdash;aumentam a probabilidade de erros serem achados e ajustados.</p>

<p>É aqui onde as <em>pull requests</em>/requisições de envio do Git (e a interface do <a href="https://bitbucket.org" rel="external" target="_blank">Bitbucket</a>) são úteis (Para mais informações sobre abrir e administrar requisições de envio no Bitbucket, veja a segunda parte desta série, <a href="http://code.tutsplus.com/tutorials/using-pull-requests-as-code-reviews--cms-21959" rel="external" target="_blank">Usando Requisições de Envio e Revisões de Código</a>). Requisições de envio servem muito mais que simplesmente para revisão de código. Uma vez que as requisições de envio são próprias para cada serviço, elas podem tornar-se tópicos próprios para discussão e colaboração de funcionalidades. Você pode embutir fotos para compartilhar projetos, comentar diretamente em linhas de código e até usar GIFs e emojis para descontrair um pouco.</p>

<p>Quando chega a hora de fundir a requisição de envio, é preferível que ela seja fundida pelo mesmo autor da requisição, que costuma ser a mesma pessoa que escreveu o código. Para que isso aconteça, os revisores devem deixar um comentário aprovando o código, mas sem apertar o botão de fundir. Uma vez que algum colega disser que o código está bom, através de um “sinal de ok” (seja figurativamente ou literalmente, através do emoji <code class="inline">:thumbsup:</code>), o responsável pela requisição pode fundir o código. Revisão de código e registros limpos&mdash;que coisa maravilhosa!</p>

<h2>Eu Publico Muito, Muito!</h2>

<p>Uma vez o ramo <code class="inline">develop</code> pronto para lançamento, funda-o ao ramo <code class="inline">master</code>:</p>

<pre class="brush: bash">git checkout master
git merge --no-ff develop</pre>

<p>Notou o semáforo <code class="inline">--no-ff</code>? Isso garantirá que a fundição não será do tipo <em>fast-forward</em>, isso é, não combinará os históricos, indicando que será um envio totalmente novo. Por que queremos isso? Para que possamos rotulá-lo (<em>tag</em>). Rotule o envio como uma nova versão:</p>

<pre class="brush: bash">git tag -a vX.X.X -m 'Versão X.X.X'</pre>

<p>E, então, funda o <code class="inline">master</code> de volta ao <code class="inline">develop</code> de modo que o ramo <code class="inline">develop</code> tenha o versionamento do envio.</p>

<p>Por falar em versões, deveríamos usar o <a href="http://semver.org/" rel="external" target="_blank">versionamento semântico</a>. Que seria algo como <code class="inline">MAIOR.MENOR.ATUALIZAÇÃO</code> (<em>MAJOR.MINOR.PATCH</em>). No geral, <code class="inline">MAIOR</code> é um número de versão totalmente novo&mdash;usado para mudanças muito grandes ou marcos. Aqui, é permitido criar código que não seja retro compatível. <code class="inline">Menor</code> é usado para novas funcionalidades. Não deveria quebrar a retrocompatibilidade. <code class="inline">ATUALIZAÇÃO</code> é para pequenas mudanças ou ajustes e nunca devem quebrar a retrocompatibilidade. Devemos manter nosso código em pré-lançamento (<code class="inline">0.x.x</code>) até que possamos lança-lo sem problemas.</p>

<h2>Ajuste O Máximo Que Puder</h2>

<p>Nunca deveríamos lançar erros.</p>

<p>...mas, quando fazemos, é melhor ajustá-los rápido. Uma vez que o ramo <code class="inline">develop</code> pode conter funcionalidades não finalizadas, ajustes devem ser feitos a partir do ramo do atual lançamento&mdash;que é o ramo <code class="inline">master</code> (uma vez que o ramo <code class="inline">master</code> sempre é publicável!).</p>

<p>Para realizar um ajuste, ramifique o <code class="inline">master</code>, crie o ajuste e funda sua atualização de forma <strong>não</strong> <em>fast-forward</em> no ramo <code class="inline">master</code>. Rotule-o, e funda o ramo <code class="inline">master</code> de volta no <code class="inline">develop</code> (já que queremos que o ramo <code class="inline">develop</code> tenha o ajuste também). Sinta-se livre para apagar o ramo do ajuste da sua máquina.</p>

<h2>É Hora do Comprometimento</h2>

<p>Falemos um pouco sobre o Git e as mensagens de envio de código. Aderir a um formato comum tornará a leitura dos registros muito mais fácil. Eis algumas boas regras:</p>

<ul>
  <li>Mensagens de envio de código devem ser escritas na forma imperativa: "Ajuste erro..." ao invés de "Erro ajustado..." ou "Ajusta erro...";</li>
  <li>A primeira linha (ou linha do assunto) deve ser um resumo rápido do propósito do envio de código (preferivelmente, 50 caracteres ou menos) com a primeira letra da primeira palavra em maiúsculo;</li>
  <li>Se o resumo precisar de mais conteúdo, você pode fazê-lo. Deixe uma linha em branco e escreva uma descrição completa. A descrição deve vir em formas de parágrafo, com pontuação, gramática e ortografia corretas;</li>
  <li>As mensagens sobre os envios de código devem tomar, no máximo, 72 colunas, de modo que elas tenham uma boa aparência em nossas janelas de linha de comando.</li>
</ul>

<p>Se quiser ler mais sobre uma escrita apropriada de mensagens para envio de código, veja o <a href="http://tbaggery.com/2008/04/19/a-note-about-git-envio de código-messages.html" rel="external" target="_blank">artigo</a> de Tim Pope.</p>

<h2>Personalize-o</h2>

<p>Veja bem, o fluxo de trabalho mostrado acima serve como um guia, não como um conjunto fixo de regras a ser seguido estritamente por você e sua equipe. Se gostar de todas as regras, ótimo! Use-as. Agora, se algo não parece interessante, faça seus próprios ajustes! </p>

<p>O mais importante é que sua equipe concorde com um fluxo de trabalho para o Git e se mantenha fiel a ele. Uma vez alcançado isso, colaboração aparecerá, e você aproveitará dos benefícios que o Git tem a oferecer para uma equipe.</p>

<p>Veja algumas alternativas ao fluxo de trabalho <em>Git-Flow</em> no <a href="https://www.atlassian.com/git/tutorials/comparing-workflows/centralized-workflow" rel="external" target="_blank">guia de fluxos de trabalho para Git da Atlassian</a>.</p>