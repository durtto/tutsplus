<h1>Refatorando Código Legado: Parte 7 - Identificando a Camada de Apresentação</h1>

<p>Código velho. Código feio. Código complicado. Código macarrônico. Código sem sentido. Em outras palavras, <em>Código Legado</em>. Esta é uma série que ajudará você a trabalhar e lidar com esse tipo de código.</p>

<p>Usaremos um tipo diferente de refatoração nesta sétima parte da nossa série. Nas partes anteriores, observamos que há código da parte da apresentação misturado por todo o resto do código legado. Tentaremos identificar todos os códigos relativos à parte de apresentação que pudermos e tomaremos os passos necessários para separá-los da lógica de negócios.</p>

<h2>A Força Motriz</h2>

<p>Toda vez que realizar alguma alteração por conta da refatoração em nosso código, fazemos guiados por alguns princípios. Esses princípios e regras ajudam-nos a identifica os problemas e, em vários casos, elas nos apontam na direção correta para deixarmos o código melhor.</p>

<h3>O Princípio da Responsabilidade Única (<em>SRP</em>)</h3>

<p>O Princípio da Responsabilidade Única é um dos princípios SOLID que falamos em mais detalhes em um tutorial anterior: <a href="http://code.tutsplus.com/pt/tutorials/solid-part-1-the-single-responsibility-principle--net-36074">Princípios SOLID Parte 1 - O Princípio da Responsabilidade Única</a>. Se quiser saber mais detalhes, recomendo que leia o artigo, caso contrário, continue a leitura e veja o resumo desse princípio logo abaixo.</p>

<p>O <em>SRP</em>, basicamente, afirma que qualquer módulo, classe ou método deve ter apenas uma única responsabilidade. Tal responsabilidade é definida como o eixo para mudança. Então, o <em>SRP</em> diz que nossa classe só pode ter um único motivo para mudar.</p>

<p>Embora isso pareça bem simples, como podemos definir "um motivo para mudar"? Temos de pensar nisso do ponto de vista dos usuários do nosso código, tanto os normais quantos outros departamentos relacionados a programação. Esses usuários podem ser representados como atores. Quando um ator quer que alteremos nosso código, o motivo de alteração que determinará o eixo da mudança. Tal requerimento só deverá afetar apenas um de nossos módulos, classes ou mesmo métodos, se possível.</p>

<p>Um exemplo bem óbvio seria se nossa equipe de <em>design</em> de Interfaces de Usuário requisitasse todas as informações necessárias para apresentação, de forma que nossa aplicação pudesse ser entregue na forma de uma página HTML, ao invés da atual interface de linha de comando.</p>

<p>Como nosso código está hoje, poderíamos apenas enviar todo o texto para algum objeto inteligente externo, que o transformaria em HTML. Mas isso pode funcionar porque o HTML é, basicamente, texto. E se nossa equipe de <em>design</em> decidir criar uma interface de usuário para <em>desktop</em> do nosso jogo, com janelas, botões e várias tabelas?</p>

<p>E se nossos usuários quiserem ver o jogo em um tabuleiro de virtual, com cidades e ruas, e os jogadores andando pelos quarteirões?</p>

<p>Poderíamos identificar essas pessoas como um Ator de Interface. E devemos perceber que, da forma que nosso código está hoje, precisaríamos alterar nossa classe principal e praticamente todos os seus métodos. Faz sentido modifica o método <code>wasCorrectlyAnswered()</code> da classe <code>Game</code> se eu quiser corrigir um erro de digitação no texto apresentado, ou se eu quiser colocar o jogo em um tabuleiro virtual? Não. Absolutamente, não. </p>

<h3>Arquitetura Limpa</h3>

<p>Arquitetura Limpa é um conceito bastante promovido por Robert C. Martin. Basicamente, ele diz que nossa lógica de negócios deveria ser bem definida e com separação bem delimitada de outros módulos não relacionados à funcionalidade principal do sistema. Isso leva a um código altamente dissociado e testável.</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/21593/image/High-Level-Clean-Architecture.png"/>
</figure>

<p>Talvez tenha visto esse desenho em meus outros tutoriais e cursos. Considero ele tão importante, que nunca codifico ou escrevo sobre programação sem pensar nele. Ele mudou totalmente o modo que programo na Syneto, e como nossos projetos são. Antes, todo nosso código usava um <em>framework</em> MVC com a lógica de negócios atrelada aos modelos. Isso tanto era difícil de entender quanto difícil de testar. Além disso, a lógica do negócio estava totalmente atrelada àquele <em>framework</em> MVC. Embora possa funcionar para projetos pequenos, quando se trata de projetos grandes, dos quais o futuro da empresa depende, incluindo o futuro de todos os funcionários nesse meio, você deve começar a pensar como organizar seu código. Uma vez feito isso, e feito certo, não precisará voltar a arquiteturar seus projetos como antes.</p>

<h2>Observando a União</h2>

<p>Já começamos a separar nossa lógica de negócios da parte de apresentação nos artigos anteriores. Algumas vezes, percebemos a existência de algumas funções de impressão e as extraímos em métodos privados, dentro da classe <code>Game</code>. Essa guerra era inconsciente, fazendo-nos separar a apresentação da lógica de negócios no nível do método.</p>

<p>Agora, é hora de analisar e observar.</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/21593/image/all-functions.png"/>
</figure>

<p>Essas é a lista de todas as variáveis, métodos e funções de nosso arquivo <code>Game.php</code>. Aquilo marcado com um "f" laranja, são variáveis. Os marcados com um "m" vermelho, são métodos. Se for seguido por um cadeado verde, significa que é público. Se for seguido por um cadeado vermelho, significa que é privado. E, dessa lista, temos interesse é na seguinte parte:</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/21593/image/display-functions.png"/>
</figure>

<p>Todos os métodos selecionados tem algo em comum. Todos eles tem uma nomeação parecida, começando com "display". Eles são métodos relacionados à impressão de coisas na tela. Identificamos todos nos tutoriais anteriores e extraídos um a um. Agora, devemos observar que eles são um grupo de métodos que devem ficar juntos. Um grupo que realiza algo específico, satisfaz o princípio da responsabilidade única: imprimir informação na tela.</p>

<h2>A Refatoração Através da Extração de Classe</h2>

<p>Apesar de ser melhor exemplificado e explicado no livro <a href="https://www.goodreads.com/book/show/44936.Refactoring">Refactoring - Improving the Design of Existing Code</a>, de Martin Fowler, a ideia básica da Refatoração da Extração de Classe é que, após ver que sua classe funciona, o trabalho dela deveria ser dividido entre duas outras classes. Há meios específicos para isso, como explicado na citação abaixo, retirada do livro mencionado mais acima.</p>

<ul>
  <li>Decida como dividir as responsabilidades entre as duas classes;</li>
  <li>Crie uma nova classe que expresse a responsabilidade extraída;
		<ul>
			<li>Se as responsabilidades da classe anterior não corresponder ao seu nome, renomeie a classe;</li>
		</ul>
	</li>
  <li>Crie um elo entre a classe antiga e a nova;
		<ul>
			<li>Talvez precise de um elo de mão dupla. Mas não crie o elo de retorno até ter certeza que precisará dele;</li>
		</ul>
	</li>
  <li>Use o processo de Movimentação de Campo em cada campo que desejar mover para nova classe;</li>
  <li>Compile e teste a cada movimentação;</li>
  <li>Use a movimentação de Métodos para mover os métodos da classe antiga para a nova. Comece por métodos de baixo nível (os invocados ao invés dos que invocam) e construa o nível mais alto;</li>
  <li>Compile e teste após cada movimentação;</li>
  <li>Revise e reduza as interfaces de cada classe;
		<ul>
			<li>Se você tinha elos de mão dupla, veja se tem como deixar um elo de mão única, apenas;</li>
		</ul>
	</li>
  <li>Decida o que expor da nova classe. Se expuser a classe, decida se deve expô-la como uma referência de objeto ou um objeto de valor imutável.</li>
</ul>

<h2>Aplicando a Extração de Classe</h2>

<p>Infelizmente, até o momento da escrita deste artigo, não há qualquer IDE para PHP que seja capaz de extrair uma classe a partir da seleção de alguns métodos e do uso de algumas opções em algum menu.</p>

<p>Como não mata saber o mecanismo do processo, realizaremos os passos descritos acima, um por um, e aplicaremos a extração de classe em nosso código.</p>

<h3>Decidindo Como Dividir as Responsabilidades</h3>

<p>Nós já sabemos isso. Queremos separar a apresentação da lógica de negócios. Queremos pegar as funções de impressão e outros códigos do tipo, e movê-las para outro lugar.</p>

<h3>Crie uma Nova Classe</h3>

<p>Nossa primeira ação é criar uma nova classe vazia.</p>

<pre class="brush: php">class Display {

} </pre>

<p>Sim. Isso é tudo por hora. E encontrar um nome apropriado para ela também foi bem fácil. <code>Display</code> é uma palavra que começa o nome de todos os métodos que estamos interessados. É o denominador comum dos nomes deles. É uma sugestão muito importante sobre o comportamento comum deles, comportamento que usamos para nomear nossa classe.</p>

<p>Se preferir e sua linguagem de programação der suporte (o PHP suporta), você pode criar uma classe dentro do mesmo arquivo da classe antiga. Ou, você pode criar um novo arquivo para ela e começar do zero. Pessoalmente, nunca achei uma resposta definitiva para escolher um dos dois caminhos em detrimento do outro. Então, cabe a você escolher um.</p>

<h3>Ligando a Classe Antigo à Nova Classe</h3>

<p>Esse passo talvez não pareça tão familiar. O que queremos fazer é declarar uma variável de classe na classe antiga e atribuí-la uma instância da nova classe.</p>

<pre class="brush: php">require_once __DIR__ . '/Display.php';

function echoln($string) {
	echo $string . "\n";
}

class Game {
	static $minimumNumberOfPlayers = 2;
	static $numberOfCoinsToWin = 6;

	private $display;

	// ... //

	function  __construct() {

		//...//

		$this-&gt;display = new Display();
	}

	// ... todos os outros métodos ... //
}</pre>

<p>Simples, não é? No construtor da classe <code>Game</code>, apenas inicializamos uma variável privada de classe que nomeamos igual à nova classe, <code>display</code>. Também tivemos de incluir o arquivo <code>Display.php</code> em nosso arquivo <code>Game.php</code>. Ainda não usamos um auto carregador. Talvez, em um tutorial futuro, introduzamos um, se precisarmos.</p>

<p>Como de costume, não esqueça de executar seus testes. Testes unitários são o suficiente nesse ponto, só para ter certeza que não há qualquer erro de digitação no código recém adicionado.</p>

<h3>A Movimentação de Campo e a Compilação/Teste</h3>

<p>Tomemos esses dois passos de uma só vez. Que campos podemos identificar que deveriam sair da classe <code>Game</code> e pertencer à <code>Display</code>?</p>

<p>Ao verificar a lista...</p>

<pre class="brush: php">static $minimumNumberOfPlayers = 2;
static $numberOfCoinsToWin = 6;

private $display;

var $players;
var $places;
var $purses;
var $inPenaltyBox;

var $popQuestions;
var $scienceQuestions;
var $sportsQuestions;
var $rockQuestions;

var $currentPlayer = 0;
var $isGettingOutOfPenaltyBox;
</pre>

<p>... não pudemos encontrar qualquer variável/campo que deva pertencer à classe <code>Display</code>. Talvez algum venha a surgir. Então, não há o que fazer para esse passo. E sobre os testes, nós já o executamos segundos atrás. Hora de seguir. </p>

<h3>Movimentação de Métodos para a Nova Classe</h3>

<p>Por si só, isso é outra refatoração. Você pode fazê-la de diversas formas e encontrar uma ótima definição sobre ela no livro mencionado masi cedo.</p>

<p>Como dito acima, devemos começar pelos métodos de mais baixo nível. Aqueles que não invocam outros métodos, mas, sim, são apenas invocados.</p>

<pre class="brush: php">private function displayPlayersNewLocation() {
	echoln($this-&gt;players[$this-&gt;currentPlayer] . " está em um novo local: " . $this-&gt;places[$this-&gt;currentPlayer]);
}</pre>

<p>O método <code>displayPlayersNewLocation()</code> parece ser um bom candidato. Analisemos o que ele faz.</p>

<p>Podemos ver que ele não invoca quaisquer outros métodos da classe <code>Game</code>. Ao invés disso, ela usa três campos: <code>players</code>, <code>currentPlayer</code> e <code>places</code>. Eles podem virar dois ou três parâmetros. Por enquanto, tudo bacana. E em relação ao <code>echoln()</code>, a única chamada de método dentro deste método? De onde vem este <code>echoln()</code>? </p>

<p>Ele está no topo do nosso arquivo <code>Game.php</code>, fora da classe <code>Game</code> em si.</p>

<pre class="brush: php">function echoln($string) {
	echo $string . "\n";
}</pre>

<p>Ele realmente faz o que diz. Imprime uma nova cadeia de caracteres com um caractere de nova linha ao final. E isso é pura apresentação. Ele dever ir para a classe <code>Display</code>. Então, extraiamos para a nova classe.</p>

<pre class="brush: php">class Display {

	function echoln($string) {
		echo $string . "\n";
	}

}</pre>

<p>Executemos nossos testes novamente. Podemos manter o <em>resultado esperado</em> desabilitado até que terminemos de extrair toda a parte de apresentação para a classe <code>Display</code>. A qualquer momento, se achar que o retorno foi modificado, torne a executar os testes do <em>resultado esperado</em>. Neste momento, os testes provarão que não adicionamos qualquer erro de digitação ou declarações de funções duplicadas ou quaisquer outros erros, ao copiar uma funçãod e um lugar para outro.</p>

<p>Agora, vá e remover o método <code>echoln()</code> do arquivo <code>Game.php</code>, execute os testes e tenha certeza que eles falharão.</p>

<pre class="brush: bash">PHP Fatal error:  Call to undefined function echoln() in /.../Game.php on line 55</pre>

<p>Legal! Nossos testes unitários são de grande ajuda. Eles executam bem rápido e nos dizem a exata posição do problema. Hora de ir à linha 55.</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/21593/image/line-55.png"/>
</figure>

<p>Veja! há uma invocação ao método <code>echoln()</code> aqui. Os testes nunca mente. Ajustemos isso, fazendo uma invocação a <code>$this-&gt;dipslay-&gt;echoln()</code>.</p>

<pre class="brush: php">function add($playerName) {
	array_push($this-&gt;players, $playerName);
	$this-&gt;setDefaultPlayerParametersFor($this-&gt;howManyPlayers());

	$this-&gt;display-&gt;echoln($playerName . " foi adicionado");
	echoln("Eles são o jogador número " . count($this-&gt;players));
	return true;
}</pre>

<p>Isso faz com que o teste passe pela linha 55 e pare na linha 56.</p>

<pre class="brush: bash">PHP Fatal error:  Call to undefined function echoln() in /.../Game.php on line 56</pre>

<p>E a solução é óbvia. Esse é um processo tedioso, porém, bem fácil.</p>

<pre class="brush: php">function add($playerName) {
	array_push($this-&gt;players, $playerName);
	$this-&gt;setDefaultPlayerParametersFor($this-&gt;howManyPlayers());

	$this-&gt;display-&gt;echoln($playerName . " foi adicionado");
	$this-&gt;display-&gt;echoln("Eles são o jogador número " . count($this-&gt;players));
	return true;
}</pre>

<p>Isso faz os três primeiros três testes passarem e também nos aponta o próximo lugar onde deveríamos alterar.</p>

<pre class="brush: bash">PHP Fatal error:  Call to undefined function echoln() in /.../Game.php on line 169</pre>

<p>É lá no método <code>wrongAnswer()</code>.</p>

<pre class="brush: php">function wrongAnswer() {
	echoln("Question was incorrectly answered");
	echoln($this-&gt;players[$this-&gt;currentPlayer] . " foi enviado para a caixa de penalidades");
	$this-&gt;inPenaltyBox[$this-&gt;currentPlayer] = true;

	$this-&gt;currentPlayer++;
	if ($this-&gt;shouldResetCurrentPlayer()) {
		$this-&gt;currentPlayer = 0;
	}
	return true;
}</pre>

<p>Ajustando essas duas invocações, leva a um erro na linha 228.</p>

<pre class="brush: php">private function displayCurrentPlayer() {
	echoln($this-&gt;players[$this-&gt;currentPlayer] . " é o jogador atual");
}</pre>

<p>Um método com a palavra <code>display</code>! Talvez esse seja nosso primeiro método a mudar de lugar. Tentaremos seguir um pouco o desenvolvimento voltado a testes (TDD) aqui. E, quando os testes falham, não somos permitidos escrever quaisquer outros códigos de produção que não seja absolutamente necessário para o teste passar. E tudo isso que acarreta é apenas a alteração da invocação a <code>echoln()</code> até que os testes unitários passem.</p>

<p>Você pode acelerar esse processo, usando a funcionalidade de busca e substituição do seu editor ou IDE. Apenas execute todos os testes, incluindo o do <em>resultado esperado</em> após você realizar essa substituição. Nossos testes unitários não cobrem todo o código nem todas as chamadas a <code>echoln()</code>.</p>

<p>Podemos começar nosso primeiro nosso candidato, <code>displayCurrentPlayer()</code>. Copie-o para a classe <code>Display</code> e execute os testes. </p>

<p>Depois, torne-o público na classe <code>Display</code> e no método <code>displayCurrentPlayer()</code> na classe <code>Game</code>, invoque <code>$this-&gt;display-&gt;displayCurrentPlayer()</code> ao invés de invocar diretamente <code>echoln()</code>. Por fim, execute seus testes.</p>

<p>Eles falharão. Mas, ao fazer essas mudanças dessa forma, garantimos que apenas alteramos a única coisa que poderia falhar. Todos os outros métodos ainda invocam o método <code>displayCurrentPlayer()</code> da classe <code>Game</code>. E estamos coisa foi delegada à classe <code>Display</code>.</p>

<pre class="brush: bash"> Undefined property: Display::$display</pre>

<p>Nosso método usa campos de classe. Eles precisam virar parâmetros para a função. Se seguir os erros do seu teste, você acabará com algo mais ou menos assim, na classe <code>Game</code>.</p>

<pre class="brush: php">private function displayCurrentPlayer() {
	$this-&gt;display-&gt;displayCurrentPlayer($this-&gt;players[$this-&gt;currentPlayer]);
}</pre>

<p>E algo parecido a isso, na classe <code>Display</code>.</p>

<pre class="brush: php">function displayCurrentPlayer($currentPlayer) {
	$this-&gt;echoln($currentPlayer . " é o jogador atual");
}</pre>

<p>Substitua as invocações ao método local na classe <code>Game</code> pelos do método da classe <code>Display</code>. Não esqueça de mover os parâmetros em um nível, também.</p>

<pre class="brush: php">private function displayStatusAfterRoll($rolledNumber) {
	$this-&gt;display-&gt;displayCurrentPlayer($this-&gt;players[$this-&gt;currentPlayer]);
	$this-&gt;displayRolledNumber($rolledNumber);
}</pre>

<p>Por fim, remova o método não usado na classe <code>Game</code>. E execute seus testes para garantir que tudo está certo.</p>

<p>Esse é um processo tedioso. Você pode acelerá-lo um pouco, levando vários métodos de uma só vez e usando qualquer coisa que sua IDE forneça para ajudar na mudança e substituição de código entre as classes. O resto dos métodos serão um exercício para você ou você ler mais desse tutorial para ver os destaques do processo. O código finalizado está atrelado a esse artigo e conterá a classe <code>Display</code> finalizada.</p>

<p>Ah, e não esqueça do código que ainda não foi extraído dos métodos "display" dentro da classe <code>Game</code>. Você pode mover as invocações a <code>echoln()</code> diretamente para a <code class="inline">Display</code>. Nosso objetivo é não invocar qualquer <code>echoln()</code> de dentro da classe <code>Game</code> e torná-la privada em <code>Display</code>.</p>

<p>Depois de aproximadamente uma hora de trabalho, a classe <code>Display</code> começa a ficar interessante.</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/21593/image/display-function-st1.png"/>
</figure>

<p>Todos os métodos "display" da classe <code>Game</code> estão na classe <code>Display</code>. Agora, podemos procurar por todas as invocações a <code>echoln</code> que permanecem na classe <code>Game</code> e movê-los também. Os testes continuam passando, claro.</p>

<p>Mas, tão logo nos deparamos como método <code>askQuestion()</code>, percebemos que ele também é um método de apresentação. Isso significa que os vários vetores de perguntas também devem ir para a classe <code>Display</code>.</p>

<pre class="brush: php">class Display {
	private $popQuestions = [];
	private $scienceQuestions = [];
	private $sportsQuestions = [];
	private $rockQuestions = [];

	function __construct() {
		$this-&gt;initializeQuestions();
	}
	// ... //
	private function initializeQuestions() {
		$categorySize = 50;
		for ($i = 0; $i &lt; $categorySize; $i++) {
			array_push($this-&gt;popQuestions, "Pergunta sobre Pop " . $i);
			array_push($this-&gt;scienceQuestions, ("Pergunta sobre Ciências " . $i));
			array_push($this-&gt;sportsQuestions, ("Pergunta sobre Esportes " . $i));
			array_push($this-&gt;rockQuestions, "Pergunta sobre Rock " . $i);
		}
	}
}</pre>

<p>Parece certo. Perguntas são apenas cadeias de caracteres, que apresentamos e elas ficam melhor nessa classe. Quando realizamos esse tipo de refatoração, também é uma boa oportunidade de refatorar nosso código recém movimentado. Nós definimos valores iniciais na declaração dos campos, também os tornamos privados e criamos um método com o código que é precisamos executar para não ficar no método construtor. Ao invés disso, ele está escondido ao final da classe, fora de vista.</p>

<p>Após extrair os dois métodos, percebemos que é interessante renomeá-los, dentro da classe <code>Display</code>, sem o prefixo "display".</p>

<pre class="brush: php">function correctAnswer() {
	$this-&gt;echoln("Resposta está correta!!!!");
}

function playerCoins($currentPlayer, $playerCoins) {
	$this-&gt;echoln($currentPlayer . " agora tem " . $playerCoins . " Moedas de Ouro.");
}</pre>

<p>Com nossos testes verde e tudo correndo como esperado, podemos refatorar e renomear os métodos. A IDE PHPStorm é capaz de lidar com renomeação muito bem. Ela renomeará todas as invocações na classe <code>Game</code>, apropriadamente. Até que há esse trecho de código.</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/21593/image/typo-corrent.png"/>
</figure>

<p>Atente bem à linha selecionada, a 119. Parece bastante com o nosso método recém extraído para <code>Display</code>.</p>

<pre class="brush: php">function correctAnswer() {
	$this-&gt;echoln("Resposta está correta!!!!");
}</pre>

<p>Mas, se o invocarmos ao invés do código em si, o teste falhará. Sim! Há um erro de digitação! E, NÃO! Você não deve corrigi-lo. Estamos realizando refatorações. Devemos manter a funcionalidade intocada, mesmo que haja algum erro.</p>

<p>O resto do método não gera qualquer desafio para ajustes.</p>

<h3>Revisão e Redução das Interfaces</h3>

<p>Agora, toda que toda funcionalidade de apresentação está na classe <code>Display</code>, devemos revisar os métodos e manter públicos apenas aqueles usados na classe <code>Game</code>. Esse passo também é motivado pelo <a href="http://code.tutsplus.com/tutorials/solid-part-3-liskov-substitution-interface-segregation-principles--net-36710">Princípio da Segregação de Interfaces</a> que falamos em tutoriais passados.</p>

<p>Em nosso caso, a forma mais fácil de descobrir quais métodos precisam manter-se públicos ou provados, é torná-los todos privados, executar os testes e, se eles falharem, é preciso revertê-los para público.</p>

<p>Por conta da demora da execução dos testes do <em>resultado esperado</em>, também podemos depender de nosso IDE a nos ajudar a acelerar o processo. O PHPStorm é esperto o suficiente para descobrir se o método não é utilizado. Se tornarmos um método privado e ele, de repente, torna-se não usado, é claro que ele era usado fora da classe <code>Display</code> e precisa continuar como público.</p>

<p>Por fim, vemos a classe <code>Display</code> e arranjamos uma forma que os métodos privados fiquem ao final da classe.</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/21593/image/display-done.png"/>
</figure>

<h2>Pontos Finais</h2>

<p>Agora, o último passo do princípio de Refatoração da Extração de Classe é irrelevante para nós. Com isso, concluímos nosso tutorial, mas ainda não concluímos a série. Fique ligado por nosso próximo tutorial, onde trabalharemos a Arquitetura Limpa e inverter as dependências.</p>