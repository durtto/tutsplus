<h1>Construindo Com a API do Twitter: OAuth, Leitura e Publicação</h1>

<p><i>Esse artigo é a segunda de três partes da série sobre como usar a API do Twitter. Se você não leu a parte um, você pode </i><a href="http://code.tutsplus.com/tutorials/building-with-the-twitter-api-getting-started--cms-22192" target="_self"><i>lê-la aqui</i></a><i>.</i></p>

<h2>Autenticação com Twitter via OAuth</h2>

<p>O <a href="http://jeffreifman.com/birdhouse/birdcage" target="_self">Birdcage</a> usa uma extensão do Yii, chamada <a href="http://www.yiiframework.com/extension/twitter/" target="_self">Yii Twitter</a>, criada por <a href="https://github.com/willwharton" target="_self">Will Wharton</a>, que faz uso da biblioteca de código aberto PHP OAuth Twitter, criada por <a href="https://github.com/abraham" target="_self">Abraham Williams</a>.</p>

<p>Coloco a extensão na árvore de diretório do Yii dentro de <code class="inline">/app/protected/extensions/yiitwitteroauth</code>. No Yii, você pode configurar as propriedades da extensão no arquivo de configuração <code class="inline">main.php</code>, dessa forma:</p>

<pre class="brush: php">// componentes da aplicação
	'components'=&gt;array(
	  'twitter' =&gt; array(
    				'class' =&gt; 'ext.yiitwitteroauth.YiiTwitter',
    				'consumer_key' =&gt; '',
    				'consumer_secret' =&gt; '',
    				'callback' =&gt; '',
    			),
</pre>

<p>Normalmente, carregaria essas configurações através de arquivo <code>.ini</code> no Yii, mas para simplificar a preparação e configuração do Birdcage setup, colocarei as chaves de configuração da aplicação no modelo <code class="inline">UserSettings</code>. Estendi o <code class="inline">YiiTwitter.php</code> para carregar as chaves padrão de aplicação do usuário durante a inicialização:</p>

<pre class="brush: php">public function init() {
	  // carrega as chaves de aplicação do Twitter lá da tabela UserSetting
    $result = UserSetting::model()-&gt;loadPrimarySettings();
    $this-&gt;consumer_key = $result['twitter_key'];
    $this-&gt;consumer_secret = $result['twitter_secret'];
    $this-&gt;callback = $result['twitter_url'];
		$this-&gt;registerScripts();
		parent::init();
	}
</pre>

<p>Uma vez instalado e configurado as opções da aplicação, você precisará visitar o menu <strong>Accounts</strong> e clicar em <strong>Add Your Twitter Account</strong>. </p>

<figure class="post_image">
  <img alt="Mange Accounts in the Birdcage application" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/317/posts/22193/image/accounts.jpg"/>
</figure>

<p>Ao clicar no ícone do Twitter, ele executará o método <code class="inline">Connect</code> do controlador do Birdcage:</p>

<pre class="brush: plain">  public function actionConnect()
   {
        unset(Yii::app()-&gt;session['account_id']);
        Yii::app()-&gt;session['account_id']=$_GET['id'];
       $twitter = Yii::app()-&gt;twitter-&gt;getTwitter();
       $request_token = $twitter-&gt;getRequestToken();
       // configurar informações de sessão
       Yii::app()-&gt;session['oauth_token'] = $token =$request_token['oauth_token'];
       Yii::app()-&gt;session['oauth_token_secret'] = $request_token['oauth_token_secret'];

          if ($twitter-&gt;http_code == 200) {
              //obtém url de conexão com twitter
              $url = $twitter-&gt;getAuthorizeURL($token);
              //envia
              Yii::app()-&gt;request-&gt;redirect($url);
          }else{
              //ocorreu erro
              $this-&gt;redirect(Yii::app()-&gt;homeUrl);
          }
      }</pre>

<p>Isso levará você até o Twitter, através do OAuth, para autenticar sua conta:</p>

<figure class="post_image">
  <img alt="Twitter OAuth Challenge Screen" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/317/posts/22193/image/oauth-at-twitter.jpg"/>
</figure>

<p>Uma vez conectado, o Twitter pedirá para você autorizar a aplicação Birdcage:</p>

<figure class="post_image">
  <img alt="Authorize app for Twitter API" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/317/posts/22193/image/oauth-authorize.jpg"/>
</figure>

<p>O Twitter redirecionará o navegador para sua URL <em>callback</em>, que é o método <em>Callback</em> do controlador do Twitter. Isso guardará seu <em>token</em> OAuth de usuário do Twitter e uma chave secreta, dentro da tabela <em>account</em>:</p>

<pre class="brush: php">  public function actionCallback() {
/* Se oauth_token for antigo, redireciona para página de conexão. */
            if (isset($_REQUEST['oauth_token']) &amp;&amp; Yii::app()-&gt;session['oauth_token'] !== $_REQUEST['oauth_token']) {
                Yii::app()-&gt;session['oauth_status'] = 'oldtoken';
            }
/* cria o objeto TwitteroAuth com a chave/segredo do app e chave/segredo do token, da fase padrão */
            $twitter = Yii::app()-&gt;twitter-&gt;getTwitterTokened(Yii::app()-&gt;session['oauth_token'], Yii::app()-&gt;session['oauth_token_secret']);
            /* REquesita tokens de acesso do Twitter */
            $access_token = $twitter-&gt;getAccessToken($_REQUEST['oauth_verifier']);
      /* Guarda os tokens de acesso. Geralmente, eles são salvos em uma base de dados para usos futuros. */
            Yii::app()-&gt;session['access_token'] = $access_token;
            $account = Account::model()-&gt;findByAttributes(array('user_id'=&gt;Yii::app()-&gt;user-&gt;id,'id'=&gt;Yii::app()-&gt;session['account_id']));
            $account['oauth_token'] = $access_token['oauth_token'];
            $account['oauth_token_secret'] = $access_token['oauth_token_secret'];
$account-&gt;save();

            /* Remove os tokens de requisição desnecessários */
            unset(Yii::app()-&gt;session['oauth_token']);
            unset(Yii::app()-&gt;session['oauth_token_secret']);

            if (200 == $twitter-&gt;http_code) {
          /* O usuário foi verificado e os tokens de acesso podem ser salvos para usos futuros */
                Yii::app()-&gt;session['status'] = 'verified';
                $this-&gt;redirect(array('account/admin'));

            } else {
                /* Guarda o estado HTTP para a janela de erro na página de conexão.*/
                //header('Location: /clearsessions.php');
                $this-&gt;redirect(Yii::app()-&gt;homeUrl);
            }
       }
</pre>

<p>Agora, o Birdcage está pronto para começar a realizar requisições em busca de dados do Twitter através da API, no lugar do usuário.</p>

<p>Como verá mais à frente, uma simples chamada com os <em>tokens</em> dão acesso à API:</p>

<pre class="brush: php">$twitter = Yii::app()-&gt;twitter-&gt;getTwitterTokened($account['oauth_token'], $account['oauth_token_secret']);
</pre>

<h2>Processando <em>Tweets</em> em Plano de Fundo</h2>

<p>Para essa parte dois do nosso tutorial, usaremos a API REST do Twitter. Na parte três, aprofundaremo-nos na API de Fluxo de tempo real e intermitente:</p>

<figure class="post_image">
  <img alt="Using the Twitter REST API" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/317/posts/22193/image/streaming-intro-1_1.png"/>
</figure>

<h3>Buscando Linhas do Tempo do Twitter</h3>

<p>Linhas do Tempo do Twitter são uma fila crescente de <em>tweets</em>, logo, monitoramento de atividade é um pouco mais complicado que na maioria das APIs REST. Você pode aprender mais sobre o <a href="https://dev.twitter.com/rest/public/timelines" target="_self">único problema que as linhas do tempo apresentam</a>. Essencialmente, de acordo com que você tenta ler o histórico da linha do tempo, mais e mais <em>tweets</em> são adicionados à ele o tempo todo:</p>

<figure class="post_image">
  <img alt="The Ever Expanding Twitter Timeline" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/317/posts/22193/image/tweet-stack.jpg"/>
</figure>

<p>O Twitter provê uma forma relativamente simples de administrar isso. Você pode seguir o código que realiza esse procedimento no modelo de Tweet do Birdcage, <code class="inline">getRecentTweets()</code>.</p>

<p>Primeiro, veremos o maior (mais recente) <code class="inline">tweet_id</code> em nossa base de dados e retornaremos um valor incrementado:</p>

<pre class="brush: php">  public function getLastTweet($account_id) {
// obtem o maior tweet_id onde account_id = $account_id
    $criteria=new CDbCriteria;
    $criteria-&gt;select='max(tweet_id) AS max_tweet_id';
    $criteria-&gt;condition="account_id = ".$account_id;
    $row = Tweet::model()-&gt;find($criteria);
    if ($row['max_tweet_id'] ==0)
      return 1;
    else
      return $row['max_tweet_id']+1;
  }</pre>

<p>Então, requisitamos uma quantidade (por exemplo, 100) de <em>tweets</em> desde o último que foi processado. A API do Twitter reconhece o <code class="inline">since_id</code> como o ponto na linha do tempo que você deseja começar a buscar os dados. Ela retornará todos os <em>tweets</em> mais recentes que o <code class="inline">since_id</code>. No exemplo abaixo, consultamos o <a href="https://dev.twitter.com/rest/reference/get/statuses/home_timeline" target="_self">método statuses/home_timeline</a> da API REST. A linha do tempo inicial é onde o usuário vê sua tela principal do Twitter.</p>

<pre class="brush: php">$since_id = $this-&gt;getLastTweet($account-&gt;id);
    echo 'since: '.$since_id;lb();
    // busca os tweets a partir do último armazenado
    $tweets= $twitter-&gt;get("statuses/home_timeline",array('count'=&gt;100,'since_id'=&gt;$since_id));
    if (count($tweets)==0) return false; // nada foi retornado
</pre>

<p>Também é importante verificar se tivemos o <a href="https://dev.twitter.com/rest/public/rate-limiting" target="_self">uso limitado pelo Twitter</a>. Cada requisição usuário-aplicação é permitido realizar 180 requisições a linha do tempo inicial do usuário em um período de 15 minutos—mas <a href="https://dev.twitter.com/rest/public/rate-limits" target="_self">as limitações de uso variam por atividade</a>, logo, pode variar bastante para você.</p>

<p>Para cada <em>tweet</em> recebido, invocaremos o método <code class="inline">Parse()</code> para processar os dados e guardá-los em várias tabelas da base de dados. Durante o processo, rastrearemos o <code class="inline">tweet_id</code> mais velho/menor que recebemos do Twitter:</p>

<pre class="brush: php">foreach ($tweets as $i) {
      if ($low_id==0)
        $low_id = intval($i-&gt;id_str);
      else
        $low_id = min(intval($i-&gt;id_str),$low_id);
      Tweet::model()-&gt;parse($account-&gt;id,$i);
    }</pre>

<p>O método <code>parse</code> adiciona informação do usuário de Twitter referenciado e, então, o <em>tweet</em> em si. Há mais detalhes no modelo <code class="inline">Parse.php</code>.</p>

<pre class="brush: php">  public function parse($account_id,$tweet) {
  // adiciona o usuário
      $tu = TwitterUser::model()-&gt;add($tweet-&gt;user);
      // adiciona o tweet
      $tweet_obj = $this-&gt;add($account_id,$tweet);</pre>

<p>Assim, continuamos a requisitar os blocos de <em>tweets</em> usando o menor ID da requisição anterior como o parâmetro <code class="inline">max_id</code> que enviamos para o Twitter. Realizamos as requisições subsequentes usando o <code class="inline">since_id</code> do <em>tweet</em> que começamos <i>e</i> o <code class="inline">max_id</code> do último <em>tweet</em> mais antigo retornado.</p>

<pre class="brush: php">// retorna o próximo bloco até o limite ser alcançado
    while ($count_tweets &lt;= $limit) {
      lb(2);
      $max_id = $low_id-1;
      $tweets= $twitter-&gt;get("statuses/home_timeline",array('count'=&gt;100,'max_id'=&gt;$max_id,'since_id'=&gt;$since_id));
      if (count($tweets)==0) break;
      if ($this-&gt;isRateLimited($tweets)) return false;
      echo 'count'.count($tweets);lb();
      $count_tweets+=count($tweets);
      foreach ($tweets as $i) {
        $low_id = min(intval($i-&gt;id_str),$low_id);
        Tweet::model()-&gt;parse($account-&gt;id,$i);
      }
    }</pre>

<p>Assim, por exemplo, quando novos <em>tweets</em> chegarem, não os veremos—já que o Twitter só nos envia os <em>tweets</em> desde o maior <code class="inline">tweet_id</code> inicial (<code class="inline">since_id</code>) da nossa base de dados. Teremos de voltar para buscar novos <em>tweets</em> depois, que sejam maiores que nosso <code class="inline">since_id</code> inicial.</p>

<p>É importante perceber que não recebemos um número infinito de <em>tweets</em> antigos. O Twitter nos retorna somente o número de <em>tweets</em> que requisitamos que sejam mais velhos que o ID anterior menor (<code class="inline">max_id</code> em nossa próxima chamada).</p>

<p>Uma vez que você se acostuma com o modelo e a nomenclatura, é bem simples.</p>

<p>Embora tenha o comando <code class="inline">Fetch</code> que executará essa operação, também configuraremos uma <em>tarefa</em> <code class="inline">cron</code> para executar nosso <code class="inline">DaemonController</code> a cada cinco minutos:</p>

<pre class="brush: bash"># Para definir o tempo, você proverá valores reais para
# minutos (m), horas (h), dia do mês (dom), mês (mon),
# e dia da semana (dow) ou usar '*' nesses campos (para 'qualquer um').#
# Perceba que as tarefas serão inicializadas de acordo a noção de tempo e
# fuso horários do sistema de daemon.
#
# Por exemplo, você pode executar um backup de todas as contas de usuário
# às 5 da manhã a cada semana:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
#
# m h  dom mon dow   command
*/5 * * * * wget -O /dev/null http://birdcage.yourdomain.com/daemon/index</pre>

<p>Por sua vez, isso invocará nosso método <code class="inline">getStreams</code> que executará as operações descritas acima (nota, a funcionalidade de fluxo será descrita na parte três desta série):</p>

<pre class="brush: php">public function actionIndex() {
	  // Se não usar fluxos do twitter, processaremos pela API REST
	  if (!Yii::app()-&gt;params['twitter_stream']) {
	    Tweet::model()-&gt;getStreams();
	  } else {
	    Stream::model()-&gt;process();
	  }
  }</pre>

<p>O resultado final é mais ou menos assim:</p>

<figure class="post_image">
  <img alt="Birdcage statuses home_timeline via Twitter API" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/317/posts/22193/image/birdcage-tweets.jpg"/>
</figure>

<p>Uma vez, deparei-me com problemas na API do Twitter. Você pode verificar o <a href="https://dev.twitter.com/overview/status" target="_self">estado dos serviços da API do Twitter, aqui</a>.</p>

<h2>Publicando um <em>Tweet</em></h2>

<p>Publicar <em>tweets</em> em sua conta do Twitter é bem simples e direto. Só precisar usar o <a href="https://dev.twitter.com/rest/reference/post/statuses/update" target="_self">método REST statuses/update</a>. Porém, dá um pouco mais de trabalho realizar uma contagem precisa de caracteres. </p>

<p>O Twitter transforma todas as URLs em <a href="http://t.co">http://t.co</a>, assim, para todas as URLs, considere que elas tenham 20 caracteres. Precisei de um código JavaScript que contasse os caracteres e levasse em consideração esse ponto do tamanho das URL. Acabei usando uma combinação de jQuery e JavaScript, que detalharei mais abaixo.</p>

<p>Preferi criar um modelo específico para a composição de <em>tweets</em>, chamado <code class="inline">Status.php</code>. Isso facilitou o trabalho com o Yii para gerar formulários que permitissem publicar os <em>tweets</em> através da API. </p>

<p>Quando você clica no menu <strong>Compose</strong> do Birdcage, ele levará você ao método <code class="inline">Compose</code> do controlador <code class="inline">StatusController</code>:</p>

<pre class="brush: php">public function actionCompose($id=0)
	{
	  if (!UserSetting::model()-&gt;checkConfiguration(Yii::app()-&gt;user-&gt;id)) {
      Yii::app()-&gt;user-&gt;setFlash('warning','Por favor, configure suas opções de Twitter.');
			$this-&gt;redirect(array('/usersetting/update'));
	  }

		$model=new Status;
		$model-&gt;account_id = $id;

		// Descomente a linha abaixo se validação via AJAX for necessária
		// $this-&gt;performAjaxValidation($model);

		if(isset($_POST['Status']))
		{
			$model-&gt;attributes=$_POST['Status'];
			if ($model-&gt;account_id=='' or $model-&gt;account_id==0) {
		    Yii::app()-&gt;user-&gt;setFlash('no_account','Você deve selecionar uma conta antes de publicar um tweet.');
			  $this-&gt;redirect(array('status/compose'));
			}
      $model-&gt;created_at =new CDbExpression('NOW()');
      $model-&gt;modified_at =new CDbExpression('NOW()');

			if($model-&gt;save()) {
			  $account = Account::model()-&gt;findByPK($model-&gt;account_id);
			  $twitter = Yii::app()-&gt;twitter-&gt;getTwitterTokened($account['oauth_token'], $account['oauth_token_secret']);
        // busque tweets até antes o último guardado
        $tweets= $twitter-&gt;post("statuses/update",array('status'=&gt;$model-&gt;tweet_text));
				$this-&gt;redirect(array('view','id'=&gt;$model-&gt;id));

			}
		}

		$this-&gt;render('compose',array(
			'model'=&gt;$model,
		));
	}</pre>

<p>Isso carregará o formulário para a criação de um item <em>Status</em>. Verifique o arquivo <code class="inline">_form.php</code> dentro de <code class="inline">/app/protected/views/status/</code>.</p>

<p>Primeiro, carreguei várias bibliotecas jQuery e JavaScript para a contagem de caracteres:</p>

<pre class="brush: php">$baseUrl = Yii::app()-&gt;baseUrl;
$cs = Yii::app()-&gt;getClientScript();
$cs-&gt;registerScriptFile($baseUrl.'/js/jquery.simplyCountable.js');
$cs-&gt;registerScriptFile($baseUrl.'/js/twitter-text.js');
$cs-&gt;registerScriptFile($baseUrl.'/js/twitter_count.js');
</pre>

<p>Combinei o <a href="https://github.com/aaronrussell/jquery-simply-countable" target="_self"><em>plugin</em> simplyCountable</a> do jQuery, com o <a href="https://github.com/twitter/twitter-text-js" target="_self">twitter-text.js</a> (um <em>script</em> de processamento de texto de Twitter em JavaScript) e com um <em>script</em> encarregado de ajustar o tamanho das URL: <a href="http://blog.pay4tweet.com/2012/04/27/twitter-lifts-140-character-limit/" target="_self">twitter_count.js.</a></p>

<p>O código abaixo criar o restante do formulário de criação de <em>status</em> e ativa os <em>scripts</em> de contagem de caracteres:</p>

<pre class="brush: php">&lt;?php $form=$this-&gt;beginWidget('bootstrap.widgets.TbActiveForm',array(
'id'=&gt;'status-form',
	'enableAjaxValidation'=&gt;false,
)); ?&gt;

&lt;?php
  if(Yii::app()-&gt;user-&gt;hasFlash('no_account')
    ) {
  $this-&gt;widget('bootstrap.widgets.TbAlert', array(
      'alerts'=&gt;array( // configurações para tipo de alerta
  	    'no_account'=&gt;array('block'=&gt;true, 'fade'=&gt;true, 'closeText'=&gt;'×'),
      ),
  ));
}
?&gt;

	&lt;p class="help-block"&gt;Campos com &lt;span class="required"&gt;*&lt;/span&gt; são obrigatórios.&lt;/p&gt;

	&lt;?php echo $form-&gt;errorSummary($model); ?&gt;

  &lt;?php
    if ($model-&gt;account_id == 0 ) {
      echo CHtml::activeLabel($model,'account_id',array('label'=&gt;'Tweet com a conta:'));
      $model-&gt;account_id = 1;
      echo CHtml::activeDropDownList($model,'account_id',Account::model()-&gt;getList(),array('empty'=&gt;'Selecione uma conta'));
    } else {
      echo CHtml::hiddenField('account_id',$model-&gt;account_id);
        }
  ?&gt;

  &lt;br /&gt;
	&lt;?php
	echo $form-&gt;textAreaRow($model,'tweet_text',array('id'=&gt;'tweet_text','rows'=&gt;6, 'cols'=&gt;50, 'class'=&gt;'span8'));
   ?&gt;
   &lt;p class="right"&gt;Restantes: &lt;span id="counter2"&gt;0&lt;/span&gt;&lt;/p&gt;

	&lt;div class="form-actions"&gt;
		&lt;?php $this-&gt;widget('bootstrap.widgets.TbButton', array(
			'buttonType'=&gt;'submit',
			'type'=&gt;'primary',
			'label'=&gt;$model-&gt;isNewRecord ? 'Criar' : 'Salvar',
		)); ?&gt;
	&lt;/div&gt;

&lt;?php $this-&gt;endWidget(); ?&gt;
&lt;script type="text/javascript" charset="utf-8"&gt;
	$(document).ready(function()
	{
	  $('#tweet_text').simplyCountable({
	    counter: '#counter2',
      maxCount: 140,
      countDirection: 'down'
	  });
	});
&lt;/script&gt;
</pre>

<p>O resultado deve parecer com isso:</p>

<figure class="post_image">
  <img alt="The Birdcage Compose a Tweet PHP Twitter API Example" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/317/posts/22193/image/feature-b.jpg"/>
</figure>

<p>Quando o <em>tweet</em> for salvo, ele executa esse código no <code> StatusController</code>—que publica o <code class="inline">tweet_text</code> final, no Twitter, através do OAuth:</p>

<pre class="brush: php">		if($model-&gt;save()) {
			  $account = Account::model()-&gt;findByPK($model-&gt;account_id);
			  $twitter = Yii::app()-&gt;twitter-&gt;getTwitterTokened($account['oauth_token'], $account['oauth_token_secret']);
        // retorna os tweets até o último salvo
        $tweets= $twitter-&gt;post("statuses/update",array('status'=&gt;$model-&gt;tweet_text));
				$this-&gt;redirect(array('view','id'=&gt;$model-&gt;id));
			}</pre>

<h2>Próximos Passos</h2>

<p>Nessa parte desta série, revisamos como autenticar com a API do Twitter usando OAuth; como consultar por períodos de <em>tweets</em> da linha do tempo do usuário; e como realizar contagem de caracteres de <em>tweets</em> e publicá-los através da API. Espero que tenha achado esse artigo útil.</p>

<p>Na parte três, trataremos sobre o uso da API de Fluxos do Twitter e sobre a implementação de código aberto, Phirehose, desse fluxo.</p>

<p>Por favor, deixe quais comentários, correções ou ideais extras abaixo. Você pode navegar pelos meus outros tutoriais aqui no Tuts+ através da <a href="http://tutsplus.com/authors/jeff-reifman" target="_self">minha página aqui</a>, ou me segundo através do <a href="https://twitter.com/intent/user?screen_name=reifman" target="_self">Twitter</a>.</p>