<h1>Refatorando Código Legado: Parte 11: O Fim?</h1>

<p>No antigo anterior, aprendemos uma nova maneira de compreender e criar novo código, a partir da extração até a exaustão. Embora aquele tutorial tenha sido bom para aprender sobre as técnicas, é difícil aceitá-lo como um exemplo ideal para entender os benefícios. Nesse artigo, extrairemos até a exaustão no código do nosso jogo de perguntas e respostas, e analisaremos o resultado final.</p>

<p>Também concluiremos nossa série sobre refatoração. Se você acha que deixei passar algo, sinta-se livre para comentar com a proposta de algum tópico. Se aparecerem algum boa ideia, continuarei com tutoriais extras, baseado em seus pedidos.</p>



<h2>Atacando o Método Mais Longo</h2>

<p>Que melhor maneira para começar nosso artigo que atacando nosso método mais longo e extrair as menores peças possíveis. Criando testes iniciais, como de costume, deixará o procedimento mais eficiente e divertido.</p>

<p>Como de costume, você tem o código no ponto que começamos esse tutorial, presente no diretório <code>php_start</code>, enquanto o resultado final estará no diretório <code>php</code>.</p>

<pre>function wasCorrectlyAnswered() {
	if ($this-&gt;inPenaltyBox[$this-&gt;currentPlayer]) {
		if ($this-&gt;isGettingOutOfPenaltyBox) {
			$this-&gt;display-&gt;correctAnswer();
			$this-&gt;purses[$this-&gt;currentPlayer]++;

			$this-&gt;display-&gt;playerCoins($this-&gt;players[$this-&gt;currentPlayer], $this-&gt;purses[$this-&gt;currentPlayer]);

			$winner = $this-&gt;didPlayerNotWin();
			$this-&gt;currentPlayer++;
			if ($this-&gt;shouldResetCurrentPlayer()) {
				$this-&gt;currentPlayer = 0;
			}

			return $winner;
		} else {
			$this-&gt;currentPlayer++;
			if ($this-&gt;shouldResetCurrentPlayer()) {
				$this-&gt;currentPlayer = 0;
			}
			return true;
		}

	} else {

		$this-&gt;display-&gt;correctAnswerWithTypo();
		$this-&gt;purses[$this-&gt;currentPlayer]++;
		$this-&gt;display-&gt;playerCoins($this-&gt;players[$this-&gt;currentPlayer], $this-&gt;purses[$this-&gt;currentPlayer]);

		$winner = $this-&gt;didPlayerNotWin();
		$this-&gt;currentPlayer++;
		if ($this-&gt;shouldResetCurrentPlayer()) {
			$this-&gt;currentPlayer = 0;
		}

		return $winner;
	}
}</pre>

<p>A nossa primeira vítima é o método <code>wasCorrectlyAnswered()</code>.</p>



<h2>Testando o Método wasCorrectlyAnswered()</h2>

<p>Como aprendemos em artigos anteriores, o primeiro passo para que possamos modificar nosso código legado é criar testes para ele. Esse processo pode ser bem difícil. Felizmente, o método <code>wasCorrectlyAnswered()</code> é bem direto. É composto de vários condicionais <code class="inline">if-else</code>. Cada ramo do código retorna um valor. Quando temos um valor de retorno, sempre é possível achar que o teste é realizável. Não necessariamente fácil, mas possível.</p>

<pre>function testWasCorrectlyAnsweredAndGettingOutOfPenaltyBoxWhileBeingAWinner() {
	$this-&gt;setAPlayerThatIsInThePenaltyBox();
	$this-&gt;game-&gt;isGettingOutOfPenaltyBox = true;
	$this-&gt;game-&gt;purses[$this-&gt;game-&gt;currentPlayer] = Game::$numberOfCoinsToWin;

	$this-&gt;assertTrue($this-&gt;game-&gt;wasCorrectlyAnswered());
}</pre>

<p>Não há qualquer regra sobre o que testar primeiro. Simplesmente escolhemos o caminho de execução. Na verdade, tivemos uma grande surpresa e reusamos um dos métodos privados que extraímos há alguns tutoriais atrás. Mas, ainda não terminamos. Os testes estão passando, então é hora de refatoração.</p>

<pre>function testWasCorrectlyAnsweredAndGettingOutOfPenaltyBoxWhileBeingAWinner() {
	$this-&gt;setAPlayerThatIsInThePenaltyBox();
	$this-&gt;currentPlayerWillLeavePenaltyBox();
	$this-&gt;setCurrentPlayerAWinner();

	$this-&gt;assertTrue($this-&gt;game-&gt;wasCorrectlyAnswered());
}</pre>

<p>Isso é muito mais fácil de ler e, significantemente, mais descritivo. Você pode ver os métodos extraídos no código em anexo ao tutorial.</p>

<pre>function testWasCorrectlyAnsweredAndGettingOutOfPenaltyBoxWhileNOTBeingAWinner() {
	$this-&gt;setAPlayerThatIsInThePenaltyBox();
	$this-&gt;currentPlayerWillLeavePenaltyBox();
	$this-&gt;setCurrentPlayerNotAWinner();

	$this-&gt;assertFalse($this-&gt;game-&gt;wasCorrectlyAnswered());
}

private function setCurrentPlayerNotAWinner() {
	$this-&gt;game-&gt;purses[$this-&gt;game-&gt;currentPlayer] = 0;
}</pre>

<p>Esperamos que esse teste passe, mas ele falhou. Os motivos para isso não estão claros. Uma olhada mais a fundo em <code>didPlayerNotWin()</code> pode ajudar.</p>

<pre>function didPlayerNotWin() {
	return !($this-&gt;purses[$this-&gt;currentPlayer] == self::$numberOfCoinsToWin);
}</pre>

<p>O método retorna <code>true</code> quando o jogador <strong>não</strong> ganhou. Talvez seja melhor renomear nossa variável, mas, primeiro, os testes devem passar.</p>

<pre>private function setCurrentPlayerAWinner() {
	$this-&gt;game-&gt;purses[$this-&gt;game-&gt;currentPlayer] = Game::$numberOfCoinsToWin;
}

private function setCurrentPlayerNotAWinner() {
	$this-&gt;game-&gt;purses[$this-&gt;game-&gt;currentPlayer] = 0;
}</pre>

<p>Ao analisar mais de perto, podemos ver que misturamos alguns valores aqui. Nossa confusão entre o nome do método e o nome da variável, fez com que revertêssemos as condições.</p>

<pre>private function setCurrentPlayerAWinner() {
	$this-&gt;game-&gt;purses[$this-&gt;game-&gt;currentPlayer] = 0;
}

private function setCurrentPlayerNotAWinner() {
	$this-&gt;game-&gt;purses[$this-&gt;game-&gt;currentPlayer] = Game::$numberOfCoinsToWin - 1;
}</pre>

<p>Isso funciona. Ao analisar <code>didPlayerNotWin()</code>, também observamos que ela usar o operador de igualdade para determinar o vencedor. Devemos configurar nosso valor para um a menos, porque o valor é incrementado no código de produção que testamos.</p>

<p>As últimas três partes são bem simples de escrever. Apenas são variações das duas primeiras. Você pode encontrá-las no código em anexo.</p>



<h2>Extrair até a Exaustão o Método wasCorrectlyAnswered()</h2>

<p>O maior problema é o confuso nome de variável, <code>$winner</code>. Ele deveria ser <code>$notAWinner</code>, para simbolizar que <strong>não</strong> é o vencedor.</p>

<pre>$notAWinner = $this-&gt;didPlayerNotWin();
$this-&gt;currentPlayer++;
if ($this-&gt;shouldResetCurrentPlayer()) {
	$this-&gt;currentPlayer = 0;
}
return $notAWinner;
</pre>

<p>Podemos perceber que a variável <code>$notAWinner</code> apenas é usada para retornar algum valor. Poderíamos invocar o método <code>didPlayerNotWin()</code>, diretamente, na declaração <code>return</code>?</p>

<pre>$this-&gt;currentPlayer++;
if ($this-&gt;shouldResetCurrentPlayer()) {
	$this-&gt;currentPlayer = 0;
}
return $this-&gt;didPlayerNotWin();
</pre>

<p>Isso ainda mantém nossos testes passando, mas, se executarmos os testes do <em>resultado esperado</em>, eles falharão com um erro do tipo "<em>not enough memory</em>" (memória insuficiente). Na verdade, a mudança faz com que o jogo nunca termine.</p>

<p>O que está acontecendo é que o jogador atual é atualizado para o próximo jogador. Se tivéssemos apenas um jogador, sempre usaríamos o mesmo. É assim que funcionam os testes. Você nunca saberá quando encontrará alguma lógica escondida em um código difícil.</p>

<pre>function testWasCorrectlyAnsweredAndGettingOutOfPenaltyBoxWhileBeingAWinner() {
	$this-&gt;setAPlayerThatIsInThePenaltyBox();
	$this-&gt;game-&gt;add('Another Player');
	$this-&gt;currentPlayerWillLeavePenaltyBox();
	$this-&gt;setCurrentPlayerAWinner();

	$this-&gt;assertTrue($this-&gt;game-&gt;wasCorrectlyAnswered());
}</pre>

<p>Apenas adicionando outro jogador em cada um dos nossos testes relacionados a esse método, temos certeza que a lógica será coberta. Esse teste fará com que a declaração <code>return</code> modificada logo acima, falhe.</p>

<pre>private function selectNextPlayer() {
	$this-&gt;currentPlayer++;
	if ($this-&gt;shouldResetCurrentPlayer()) {
		$this-&gt;currentPlayer = 0;
	}
}</pre>

<p>Facilmente, percebemos a seleção do próximo jogador é idêntica em ambas as partes da condição. Podemos movê-la para um método próprio. O nome que escolhemos para esse método é <code>selectNextPlayer()</code>. Esse nome ajuda a destacar o fato do valor do jogador atual ser alterado. Ele também sugere que o método <code>didPlayerNotWin()</code> pode ser renomado em algo que reflita a relação com o jogador atual.</p>

<pre>function wasCorrectlyAnswered() {
	if ($this-&gt;inPenaltyBox[$this-&gt;currentPlayer]) {
		if ($this-&gt;isGettingOutOfPenaltyBox) {
			$this-&gt;display-&gt;correctAnswer();
			$this-&gt;purses[$this-&gt;currentPlayer]++;

			$this-&gt;display-&gt;playerCoins($this-&gt;players[$this-&gt;currentPlayer], $this-&gt;purses[$this-&gt;currentPlayer]);

			$notAWinner = $this-&gt;didCurrentPlayerNotWin();
			$this-&gt;selectNextPlayer();
			return $notAWinner;
		} else {
			$this-&gt;selectNextPlayer();
			return true;
		}

	} else {

		$this-&gt;display-&gt;correctAnswerWithTypo();
		$this-&gt;purses[$this-&gt;currentPlayer]++;
		$this-&gt;display-&gt;playerCoins($this-&gt;players[$this-&gt;currentPlayer], $this-&gt;purses[$this-&gt;currentPlayer]);

		$notAWinner = $this-&gt;didCurrentPlayerNotWin();
		$this-&gt;selectNextPlayer();

		return $notAWinner;
	}
}</pre>

<p>Nosso código está ficando menor e mais expressivo. O que podemos fazer mais? Poderíamos alterar o nome da esquisita lógica do "não vencedor" e alterar o método para uma lógica positiva ao invés de negativa. Ou poderíamos continuar extraindo e lidar com a confusão da lógica negativa mais tarde. Não acredito que tenha um método específico a seguir. Então, deixarei o problema da lógica confusa como um exercício para você e continuarei com a extração.</p>

<pre>function wasCorrectlyAnswered() {
	if ($this-&gt;inPenaltyBox[$this-&gt;currentPlayer]) {
		return $this-&gt;getCorrectlyAnsweredForPlayersInPenaltyBox();
	} else {
		return $this-&gt;getCorrectlyAnsweredForPlayersNotInPenaltyBox();
	}
}</pre>

<blockquote>Como regra geral, tente ter uma única linha de código em cada caminho da lógica de decisão.</blockquote>

<p>Extraímos um bloco inteiro de código de cada parte da nossa declaração <code>if</code>. Esse é um passo importante e algo que você sempre deve pensar. Quando tiver um caminho de decisão ou um laço em seu código, dentro dele deveria ter apenas uma única declaração. A pessoa que ler o método não se importará com os detalhes da implementação. Ele ou ela só se preocupará com a lógica da decisão, a declaração <code>if</code>.</p>

<pre>function wasCorrectlyAnswered() {
	if ($this-&gt;inPenaltyBox[$this-&gt;currentPlayer]) {
		return $this-&gt;getCorrectlyAnsweredForPlayersInPenaltyBox();
	}

	return $this-&gt;getCorrectlyAnsweredForPlayersNotInPenaltyBox();
}</pre>

<p>E, se pudermos nos livrar de qualquer código extra, devemos fazê-lo. Removemos o <code>else</code>, mantivemos a mesma lógica e realizamos uma pequena economia. Gosto mais dessa solução porque ela destaca qual o comportamento "padrão" da função. O que que está no primeiro nível interior da função (a última linha de código da função). A declaração <code>if</code> é uma funcionalidade excepcional além da funcionalidade padrão.</p>

<p>Já vi motivos que escrever dessa forma pode esconder o fato que a funcionalidade padrão não executa se a declaração <code>if</code> for ativada. Só posso concordar com isso, então, se preferir manter a parte <code>else</code> para clareza, por favor, o faça.</p>

<pre>private function getCorrectlyAnsweredForPlayersInPenaltyBox() {
	if ($this-&gt;isGettingOutOfPenaltyBox) {
		return $this-&gt;getCorrectlyAnsweredForPlayerGettingOutOfPenaltyBox();
	} else {
		return $this-&gt;getCorrectlyAnsweredForPlayerStayingInPenaltyBox();
	}
}</pre>

<p>Podemos continuar a extração dentro do nosso método privado recém criado. Aplicando o mesmo princípio ao nosso próximo condicional, nos levará ao código a seguir.</p>

<pre>private function giveCurrentUserACoin() {
	$this-&gt;purses[$this-&gt;currentPlayer]++;
}</pre>

<p>Ao olhar os métodos privados <code>getCorrectlyAnsweredForPlayersNotInPenaltyBox()</code> e <code>getCorrectlyAnsweredForPlayerGettingOutOfPenaltyBox()</code>, imediatamente, observamos que uma simples atribuição está duplicada. Essa atribuição pode ser óbvia para alguém como nós, que sabemos como as coisas funcionam, mas não para alguém recém chegado. Extrair essa única linha em um método é uma ótima ideia <code>giveCurrentUserACoin()</code>.</p>

<p>Isso também ajuda com a parte da duplicação. Se, no futuro, modificamos a forma de darmos moedas aos jogadores, apenas precisaremos alterar dentro desse método privado.</p>

<pre>private function getCorrectlyAnsweredForPlayersNotInPenaltyBox() {
	$this-&gt;display-&gt;correctAnswerWithTypo();
	return $this-&gt;getCorrectlyAnsweredForAPlayer();
}

private function getCorrectlyAnsweredForPlayerGettingOutOfPenaltyBox() {
	$this-&gt;display-&gt;correctAnswer();
	return $this-&gt;getCorrectlyAnsweredForAPlayer();
}

private function getCorrectlyAnsweredForAPlayer() {
	$this-&gt;giveCurrentUserACoin();
	$this-&gt;display-&gt;playerCoins($this-&gt;players[$this-&gt;currentPlayer], $this-&gt;purses[$this-&gt;currentPlayer]);

	$notAWinner = $this-&gt;didCurrentPlayerNotWin();
	$this-&gt;selectNextPlayer();
	return $notAWinner;
}</pre>

<p>Então os dois métodos de respostas corretas são idênticos, exceto que um deles retornar com um pequeno erro de digitação. Extraímos o código duplicado e mantemos as diferenças em cada um dos dois. Você talvez ache que deveríamos usar a extração de método e usar um parâmetro no código invocado, retornando uma vez de modo normal e outra vez com o erro. Contudo, a solução proposta abaixo tem uma vantagem: Ela mantem os dois conceitos, de não estar na caixa de penalidades e de sair da caixa de penalidades, separados.</p>

<p>Isso encerra o trabalho no método <code>wasCorrectlyAnswered()</code>.</p>



<h2>E o Método wrongAnswer()?</h2>

<pre>function wrongAnswer() {
	$this-&gt;display-&gt;incorrectAnswer();
	$currentPlayer = $this-&gt;players[$this-&gt;currentPlayer];
	$this-&gt;display-&gt;playerSentToPenaltyBox($currentPlayer);
	$this-&gt;inPenaltyBox[$this-&gt;currentPlayer] = true;

	$this-&gt;currentPlayer++;
	if ($this-&gt;shouldResetCurrentPlayer()) {
		$this-&gt;currentPlayer = 0;
	}
	return true;
}</pre>

<p>Com 11 linhas, esse método não é enorme, mas é grande. Você se lembra da pesquisa que diz que o número mágico é sete mais ou menos dois? Ela diz que nosso cérebro pode pensar, simultaneamente, sobre 7+-2 coisas. Isso é, temos uma capacidade limitada. Então, para entendermos um método mais facilmente e completamente, queremos que a lógica caiba nesse espaço. Com um total de 11 linhas, e um conteúdo de 9 linhas, o método está no limite. Talvez argumente que há uma linha vazia e outro só com as chaves. Isso o faria ter apenas 7 linhas de lógica.</p>

<p>Embora as chaves e espaços sejam curtos em espaço, eles tem significados para nós. Eles separam as partes da lógica, gerando significado, de modo que nosso cérebro possa processá-los. Sim, é mais fácil que comparado com uma única linha de lógica.</p>

<p>É por isso que nosso número de linhas alvo para o método é quatro linhas. Isso está abaixo do mínimo da teoria apresentada, logo, tanto um gênio quanto um programador mediano serão capazes de compreender o método.</p>

<pre>$this-&gt;currentPlayer++;
if ($this-&gt;shouldResetCurrentPlayer()) {
	$this-&gt;currentPlayer = 0;
}</pre>

<p>Já temos um método para esse trecho de código, então, devemos usá-lo.</p>

<pre>function wrongAnswer() {
	$this-&gt;display-&gt;incorrectAnswer();
	$currentPlayer = $this-&gt;players[$this-&gt;currentPlayer];
	$this-&gt;display-&gt;playerSentToPenaltyBox($currentPlayer);
	$this-&gt;inPenaltyBox[$this-&gt;currentPlayer] = true;
	$this-&gt;selectNextPlayer();
	return true;
}</pre>

<p>Melhor, devemos parar ou continuar?</p>

<pre>$currentPlayer = $this-&gt;players[$this-&gt;currentPlayer];
$this-&gt;display-&gt;playerSentToPenaltyBox($currentPlayer);</pre>

<p>Poderíamos colocar essas variáveis em linha. A propriedade <code>$this-&gt;currentPlayer</code>, obviamente, retorna o jogador atual, então, não há necessidade de repetir lógica. Não aprendemos qualquer coisa ou abstraímos algo usando uma variável local.</p>

<pre>function wrongAnswer() {
	$this-&gt;display-&gt;incorrectAnswer();
	$this-&gt;display-&gt;playerSentToPenaltyBox($this-&gt;players[$this-&gt;currentPlayer]);
	$this-&gt;inPenaltyBox[$this-&gt;currentPlayer] = true;
	$this-&gt;selectNextPlayer();
	return true;
}</pre>

<p>Chegamos a 5 linhas. Alguma coisa a mais?</p>

<pre>$this-&gt;inPenaltyBox[$this-&gt;currentPlayer] = true;</pre>

<p>Podemos extrair a linha acima para seu próprio método. Isso ajudará a explicar o que está acontecendo e isolará a lógica com relação a enviar o jogador atual para a caixa de penalidades.</p>

<pre>function wrongAnswer() {
	$this-&gt;display-&gt;incorrectAnswer();
	$this-&gt;display-&gt;playerSentToPenaltyBox($this-&gt;players[$this-&gt;currentPlayer]);
	$this-&gt;sendCurrentPlayerToPenaltyBox();
	$this-&gt;selectNextPlayer();
	return true;
}</pre>

<p>Ainda 5 linhas, mas todas com chamadas de métodos. As duas primeiras estão apresentando coisas. As duas próximas estão relacionadas à nossa lógica. A última linha apenas retorna verdadeiro. Não consigo pensar em qualquer maneira para tornar esse método mais fácil, sem introduzir complexidades através da extrações que fizéssemos. Por exemplo, poderíamos extrair os dois métodos de apresentação para um único método privado. Se fizéssemos isso, onde esse método deveria ficar? Na classe <code>Game</code> ou na classe <code>Display</code>? Acredito que já seja uma questão muito complexa em relação à simplicidade do nosso método.</p>



<h2>Pontos Finais e Algumas Estatísticas</h2>

<p>Vejamos algumas estatísticas, usando uma ótima ferramenta criada pelo criador do PHPUnit <a href="https://github.com/sebastianbergmann/phploc.git">https://github.com/sebastianbergmann/phploc.git</a></p>

<h3>Estatísticas em Relação ao Código Original</h3>

<pre class="brush: bash">./phploc ../Refactoring\ Legacy\ Code\ -\ Part\ 1\:\ The\ Golden\ Master/Source/trivia/php/
phploc 2.1-gca70e70 by Sebastian Bergmann.

Size
  Lines of Code (LOC)                          232
  Comment Lines of Code (CLOC)                       0 (0.00%)
  Non-Comment Lines of Code (NCLOC)                232 (100.00%)
  Logical Lines of Code (LLOC)                      99 (42.67%)
    Classes                                         88 (88.89%)
      Average Class Length                          88
        Minimum Class Length                        88
        Maximum Class Length                        88
      Average Method Length                          7
        Minimum Method Length                        1
        Maximum Method Length                       17
    Functions                                        1 (1.01%)
      Average Function Length                        1
    Not in classes or functions                     10 (10.10%)

Cyclomatic Complexity
  Average Complexity per LLOC                     0.26
  Average Complexity per Class                   25.00
    Minimum Class Complexity                     25.00
    Maximum Class Complexity                     25.00
  Average Complexity per Method                   3.18
    Minimum Method Complexity                     1.00
    Maximum Method Complexity                    10.00

Dependencies
  Global Accesses                                    0
    Global Constants                                 0 (0.00%)
    Global Variables                                 0 (0.00%)
    Super-Global Variables                           0 (0.00%)
  Attribute Accesses                               115
    Non-Static                                     115 (100.00%)
    Static                                           0 (0.00%)
  Method Calls                                      21
    Non-Static                                      21 (100.00%)
    Static                                           0 (0.00%)

Structure
  Namespaces                                         0
  Interfaces                                         0
  Traits                                             0
  Classes                                            1
    Abstract Classes                                 0 (0.00%)
    Concrete Classes                                 1 (100.00%)
  Methods                                           11
    Scope
      Non-Static Methods                            11 (100.00%)
      Static Methods                                 0 (0.00%)
    Visibility
      Public Methods                                11 (100.00%)
      Non-Public Methods                             0 (0.00%)
  Functions                                          1
    Named Functions                                  1 (100.00%)
    Anonymous Functions                              0 (0.00%)
  Constants                                          0
    Global Constants                                 0 (0.00%)
    Class Constants                                  0 (0.00%)</pre>

<h3>Estatísticas em Relação ao Código Refatorado</h3>

<pre>./phploc ../Refactoring\ Legacy\ Code\ -\ Part\ 11\:\ The\ End\?/Source/trivia/php
phploc 2.1-gca70e70 by Sebastian Bergmann.

Size
  Lines of Code (LOC)                          371
  Comment Lines of Code (CLOC)                       0 (0.00%)
  Non-Comment Lines of Code (NCLOC)                371 (100.00%)
  Logical Lines of Code (LLOC)                     151 (40.70%)
    Classes                                        145 (96.03%)
      Average Class Length                          36
        Minimum Class Length                         8
        Maximum Class Length                        89
      Average Method Length                          2
        Minimum Method Length                        1
        Maximum Method Length                       14
    Functions                                        0 (0.00%)
      Average Function Length                        0
    Not in classes or functions                      6 (3.97%)

Cyclomatic Complexity
  Average Complexity per LLOC                     0.15
  Average Complexity per Class                    6.50
    Minimum Class Complexity                      1.00
    Maximum Class Complexity                     17.00
  Average Complexity per Method                   1.46
    Minimum Method Complexity                     1.00
    Maximum Method Complexity                    10.00

Dependencies
  Global Accesses                                    0
    Global Constants                                 0 (0.00%)
    Global Variables                                 0 (0.00%)
    Super-Global Variables                           0 (0.00%)
  Attribute Accesses                                96
    Non-Static                                      94 (97.92%)
    Static                                           2 (2.08%)
  Method Calls                                      74
    Non-Static                                      74 (100.00%)
    Static                                           0 (0.00%)

Structure
  Namespaces                                         0
  Interfaces                                         1
  Traits                                             0
  Classes                                            3
    Abstract Classes                                 0 (0.00%)
    Concrete Classes                                 3 (100.00%)
  Methods                                           59
    Scope
      Non-Static Methods                            59 (100.00%)
      Static Methods                                 0 (0.00%)
    Visibility
      Public Methods                                35 (59.32%)
      Non-Public Methods                            24 (40.68%)
  Functions                                          0
    Named Functions                                  0 (0.00%)
    Anonymous Functions                              0 (0.00%)
  Constants                                          3
    Global Constants                                 0 (0.00%)
    Class Constants                                  3 (100.00%)
</pre>

<h3>Análises</h3>

<p>Dados brutos só são bons se pudermos analisá-los.</p>

<p>O número de linhas de lógica de código aumentou bastante, de 99 para 151. Mas esse número não deve enganar você, fazendo pensar que o código ficou mais complicado. Essa é uma tendência natural se código bem refatorado, por conta do número de métodos e das respectivas invocações.</p>

<p>Assim que vemos o tamanho médio das classes, percebemos uma queda drástica no número de linhas, de 88 para 36.</p>

<p>E isso é tão surpreendente quanto o tamanho dos métodos, que saiu de uma média de sete linhas para apenas duas linhas.</p>

<p>Embora o número de linhas seja um bom indicador de volume de código por unidade de medida, o ganho real está na análise da complexidade ciclomática. Toda vez que tomamos uma decisão em nosso código, aumentamos a complexidade ciclomática. Quando encadeamos um <code class="inline">if</code> dentro de outro, a complexidade ciclomática aumenta exponencialmente. Nossas extrações contínuas nos levaram a uma única decisão nos métodos, reduzindo assim, a complexidade média de 3.18 para 1.00. Você pode ler isso como "nossos métodos refatorados são 3.18 vezes mais simples que o código original". A nível de classe, a queda na complexidade é ainda mais interessante. Caiu de 25.00 para 6.50.</p>

<h3>O Fim?</h3>

<p>Bom. É isso. O fim da série. Sinta-se a vontade de expressar sus opiniões e se achar que deixamos de falar de algum tópico de refatoração, deixa um comentário com um pedido sobre o mesmo. Se for interessante, transformarei em partes extras desta série. </p>

<p>Obrigado pela sua atenção.</p>