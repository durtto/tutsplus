<h1>Projeto de APIs RESTful com NodeJS e Restify</h1>

<p>Uma API RESTful consiste de dois conceitos principais: <strong>Recurso</strong> e <strong>Representação</strong>. Um <em>Recurso</em> pode ser qualquer objeto associado a um dado ou identificado a uma URI (mais de uma URI pode referir-se a um mesmo recurso), e que pode ser operado usando métodos HTTP. Uma <em>Representação</em> é uma forma de apresentar um recurso. Neste tutorial, passaremos um conteúdo teórico sobre projetos de APIs RESTful e implementaremos uma API de blog, usando o NodeJS.</p>

<h2>Recurso</h2>

<p>Escolher os recursos corretos para uma API RESTful é uma parte importante do projeto. Primeiro de tudo, você precisa analisar o domínio do seu negócio e, depois, decidir quantos e quais recursos serão usados e que são relevantes às necessidades do seu negócio. Se você estiver projetando uma API para um blog, provavelmente usará recursos como <strong>Artigo</strong>, <strong>Usuário</strong> e <strong>Comentário</strong>. Esses são os nomes dos recursos e os dados associados a eles são o recurso em si:</p>

<pre class="brush: javascript">{
"title": "Como Projetar uma API RESTful",
    "content": "Projeto de API RESTful é muito importante no mundo do desenvolvimento de software.",
    "author": "erickpatrick",
    "tags": [
        "technology",
        "nodejs",
        "node-restify"
        ]
    "category": "NodeJS"
}</pre>

<h3>Verbos de Recursos</h3>

<p>Podemos prosseguir com a operação do recurso após decidir quais são os recursos obrigatório. Operações referem-se aos métodos HTTP. Por exemplo, para criarmos um artigo, podemos realizar a seguinte requisição:</p>

<pre class="brush: plain">POST /articles HTTP/1.1
Host: localhost:3000
Content-Type: application/json

{
  "title": "Projeto de API RESTful com Restify",
  "slug": "projeto-api-rest-restify",
  "content": "Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas.",
  "author": "erickpatrick"
}</pre>

<p>Da mesma forma, podemos visualizar um artigo realizando a seguinte requisição:</p>

<pre class="brush: plain">GET /articles/123456789012 HTTP/1.1
Host: localhost:3000
Content-Type: application/json</pre>

<p>E quanto a atualizar um artigo já existente? Sei muito bem o que você está pensando:</p>

<blockquote>Posso realizar outra requisição POST em relação a <code>/articles/update/123456789012</code> com os dados a serem atualizados.</blockquote>

<p>Talvez, mas a URI está ficando um pouco mais complexa. Como disse mais cedo, as operações referem-se aos métodos HTTP. Isso significa que devemos apresentar a operação de <strong>atualização</strong> no método HTTP ao invés de colocá-lo na URI. Por exemplo:</p>

<pre class="brush: plain">PUT /articles/123456789012 HTTP/1.1
Host: localhost:3000
Content-Type: application/json
{
"title": "Como Projetar um API RESTful - Atualizada",
    "content": "Como Projetar um API RESTful - Atualizada - é muito importante no mundo do desenvolvimento de software.",
    "author": "erickpatrick",
    "tags": [
        "tecnologia",
        "nodejs",
        "restify",
        "outra tag"
        ]
    "category": "NodeJS"
}</pre>

<p>Por falar em alterações, neste exemplo podemos ver campos de <em>tags</em> e categorias. Eles não são campos obrigatórios. Você pode deixá-los em branco e preenchê-los no futuro. </p>

<p>Algumas vezes, você precisa remover um artigo que esteja desatualizado. Nestes casos, você pode usar uma requisição HTTP do tipo <strong>DELETE</strong> em relação à URI <strong>/articles/123456789012.</strong></p>

<p>Os métodos HTTP são conceitos padrões. Se usá-los como operações, você terá URIs mais simples e esse tipo de API simples ajudará você a obter clientes, clientes felizes.</p>

<p>E se você quisesse publicar um comentário em um artigo? Você pode selecionar o artigo e adicionar um comentário novo a ele. Com essa expressão em mente, você pode realizar a seguinte requisição:</p>

<pre class="brush: plain">POST /articles/123456789012/comments HTTP/1.1
Host: localhost:3000
Content-Type: application/json
{
"text": "Wow! Este é um ótimo tutorial",
    "author": "Zé niguém"
}</pre>

<p>A forma de recurso acima é chamada de <strong>sub-recurso</strong>. <strong>Comentário</strong> é um sub-recurso de <strong>Artigo</strong>. Os <strong>Comentário</strong> e sua carga acima serão inseridos na base de dados como um filho de <strong>Artigo</strong>. Algumas vezes, uma URI diferente refere-se a uma mesmo recurso. Por exemplo, para ver um comentário específico, você pode usar tanto:</p>

<pre class="brush: plain">GET /articles/123456789012/comments/123 HTTP/1.1
Host: localhost:3000
Content-Type: application/json
</pre>

<p>ou:</p>

<pre class="brush: plain">GET /comments/123456789012 HTTP/1.1
Host: localhost:3000
Content-Type: application/json</pre>

<h3>Versionamento</h3>

<p>Geralmente, funcionalidades de uma API alteram-se frequentemente, para que se possa oferecer novas funcionalidades aos clientes. Neste caso, duas versões de uma mesma API podem existir ao mesmo tempo. Para separá-las, você pode usar versionamento. Há duas formas de versionamento</p>

<ol>
  <li><strong>Versão na URI: </strong>Você pode prover o número de versão na própria URI. Por exemplo, <strong><code class="inline">/v1.1/articles/123456789012</code></strong>.</li>
  <li><strong>Versão no Cabeçalho: </strong>Você pode prover o número da versão no cabeçalho e nunca precisar mudar a URI. Por exemplo:</li>
</ol>

<pre class="brush: plain">GET /articles/123456789012 HTTP/1.1
Host: localhost:3000
Accept-Version: 1.0</pre>

<p>Na verdade, a versão apenas altera a representação do recurso, não o conceito do recurso em si. Então, você não precisa alterar a estrutura do URI. Na v1.1, talvez um novo campo seja adicionado ao Artigo. Entretanto, ele ainda retorna um artigo. Na segunda opção, a URI continua simples e os clientes não precisam alterar as URIs em suas implementações. </p>

<p>É importante projetar uma estratégia para situações onde o cliente não provê um número de versão. Você pode lançar um erro quando um número de versão não é apresentado ou você pode retornar uma resposta usando a primeira versão. Se você usar a última versão estável como a versão padrão, os clientes podem obter vários erros em suas implementações.</p>

<h2>Representação</h2>

<p>A Representação é a forma como uma API apresenta um recurso. Ao invocar uma API através de uma URI, você receberá um recurso. Esse recurso pode estar em um formato como o XML, JSON, etc. É preferido o formato JSON caso esteja projetando uma nova API. Entretanto, se você estiver atualizando uma API já existente e que já é acostumada a retornar uma resposta XML, você pode prover outra versão com uma resposta em JSON. </p>

<p>Certo, deixemos a teoria sobre projetos de APIs RESTful de lado. Vejamos como projetar e implementar uma API para blogs usando o Restify.</p>

<h2>API RESTful de um Blog</h2>

<h3>Projeto</h3>

<p>Para projetarmos uma API RESTful, precisamos analisar o domínio do negócio. Só então podemos definir nossos recursos. Em uma API de blogs, precisamos:</p>

<ul>
  <li>Criar, Atualizar, Apagar e Visualizar um <strong>Artigo</strong></li>
  <li>Criar comentários para um <strong>Artigo</strong> específico, além de Atualizar, Apagar e Visualizar um <strong>Comentário</strong></li>
  <li>Criar, Atualizar, Apagar e Visualizar um <strong>Usuário</strong></li>
</ul>

<p>Nesta API, não cobrirei a parte de autenticação necessária para criar um artigo ou comentário. Para essa parte, você pode referir-se ao artigo <a href="http://code.tutsplus.com/pt/tutorials/token-based-authentication-with-angularjs-nodejs--cms-22543" target="_self">Autenticação com Tokens Usando AngularJS &amp; NodeJS</a>. </p>

<p>Os nomes dos nossos recursos estão prontos. Operações de recursos são <em>CRUD</em> simples. Você pode referir-se à tabela a seguir para ter uma visualização geral da API.</p>

<table>
  <thead>
    <tr>
      <th>Nome do Recurso</th>
      <th>Verbos HTTP</th>
      <th>Métodos HTTP</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Artigo</td>
      <td>criar Artigo, atualizar Artigo, remover Artigo, visualizar Artigo</td>
      <td>POST /articles com os dados, PUT /articles/123 com os dados, DELETE /articles/123 e GET /article/123</td>
    </tr>
    <tr>
      <td>Comentário</td>
      <td>criar Comentário, atualizar Comentário, remover Comentário, visualizar Comentário</td>
      <td>POST /articles/123/comments com os dados, PUT /comments/123 com os dados, DELETE /comments/123 e GET /comments/123</td>
    </tr>
    <tr>
      <td>Usuário</td>
      <td>criar Usuário, atualizar Usuário, remover Usuário, visualizar Usuário</td>
      <td>POST /users com os dados, PUT /users/123 com os dados, DELETE /users/123 e GET /users/123</td>
    </tr>
  </tbody>
</table>

<h3>Configuração do Projeto</h3>

<p>Neste projeto, usaremos o <strong>NodeJS</strong> com <strong>Restify</strong>. Os recursos serão salvos em uma base de dados <strong>MongoDB</strong>. Antes de tudo, devemos definir os recursos como modelos no Restify.</p>

<h4><strong>Artigo</strong></h4>

<pre class="brush: javascript">var mongoose = require("mongoose");
var Schema   = mongoose.Schema;

var ArtigoSchema = new Schema({
title: String,
    slug: String,
    content: String,
    author: {
        type: String,
        ref: "Usuario"
    }
});
mongoose.model('Artigo', ArtigoSchema);</pre>

<h4><strong>Comentários</strong></h4>

<pre class="brush: javascript">var mongoose = require("mongoose");
var Schema   = mongoose.Schema;

var ComentarioSchema = new Schema({
text: String,
    article: {
        type: String,
        ref: "Artigo"
    },
    author: {
        type: String,
        ref: "Usuario"
    }
});
mongoose.model('Comentarios', ComentariosSchema);</pre>

<h4>Usuário</h4>

<p>Não haverá operações para o recurso Usuário. Assumiremos que já sabemos o usuário atual que será capaz de operar os artigos ou comentários.</p>

<p>Você deve se perguntar de onde esse módulo <a href="http://mongoosejs.com/index.html" target="_self">mongoose</a> vem. É o <em>framework</em> ORM para MongoDB escrito como módulo para NodeJS mais conhecido. Este módulo está incluso no projeto, dentro de outro arquivo de configuração. </p>

<p>Agora, podemos definir nossos verbos HTTP para os recursos acima. Você pode ver abaixo:</p>

<pre class="brush: javascript">var restify = require('restify')
, fs = require('fs')


var controllers = {}
    , controllers_path = process.cwd() + '/app/controllers'
fs.readdirSync(controllers_path).forEach(function (file) {
    if (file.indexOf('.js') != -1) {
        controllers[file.split('.')[0]] = require(controllers_path + '/' + file)
    }
})

var server = restify.createServer();

server
    .use(restify.fullResponse())
    .use(restify.bodyParser())

// Início dos Artigos
server.post("/articles", controllers.article.createArtigo)
server.put("/articles/:id", controllers.article.updateArtigo)
server.del("/articles/:id", controllers.article.deleteArtigo)
server.get({path: "/articles/:id", version: "1.0.0"}, controllers.article.viewArtigo)
server.get({path: "/articles/:id", version: "2.0.0"}, controllers.article.viewArtigo_v2)
// Fim dos Artigos

// Início dos Comentarios
server.post("/comments", controllers.comment.createComentarios)
server.put("/comments/:id", controllers.comment.viewComentarios)
server.del("/comments/:id", controllers.comment.deleteComentarios)
server.get("/comments/:id", controllers.comment.viewComentarios)
// Fim dos Comentarios

var port = process.env.PORT || 3000;
server.listen(port, function (err) {
    if (err)
        console.error(err)
    else
        console.log('Aplicativo pronto na porta: ' + port)
})

if (process.env.environment == 'production')
    process.on('uncaughtException', function (err) {
        console.error(JSON.parse(JSON.stringify(err, ['stack', 'message', 'inner'], 2)))
    })</pre>

<p>Neste trecho de código, a primeira coisa feita é iterar sobre todos os arquivos dos controladores e inicializá-los, para que uma requisição específica possa ser realizada. Após isso, URIs para operações específicas são definidas em relação às operações CRUD básicas. Também há versionamento para uma das operações em relação ao recurso <em>Artigo</em>. </p>

<p>Por exemplo, se você configurar a versão como sendo a <code class="inline">2</code> no cabeçalho <em>Accept-Version</em>, o método <code class="inline">viewArtigo_v2</code> será executado. <code class="inline">viewArtigo</code> e <code class="inline">viewArtigo_v2</code> realizam o mesmo trabalho, apresentando o recurso, mas mostram o recurso <em>Artigo</em> em formatos diferentes, como pode ser visto através do campo <code class="inline">title</code>, no exemplo abaixo. Finalmente, o servidor é iniciado numa porta específica, além da aplicação de alguns relatórios de erros. Podemos dar continuidade com os métodos dos controladores mapeados às operações HTTP em relação aos recursos.</p>

<h4><strong>article.js</strong></h4>

<pre class="brush: javascript">var mongoose = require('mongoose'),
Artigo = mongoose.model("Artigo"),
    ObjectId = mongoose.Types.ObjectId

exports.createArtigo = function(req, res, next) {
    var articleModel = new Artigo(req.body);
    articleModel.save(function(err, article) {
        if (err) {
            res.status(500);
            res.json({
                type: false,
                data: "Erro ocorrido: " + err
            })
        } else {
            res.json({
                type: true,
                data: article
            })
        }
    })
}

exports.viewArtigo = function(req, res, next) {
    Artigo.findById(new ObjectId(req.params.id), function(err, article) {
        if (err) {
            res.status(500);
            res.json({
                type: false,
                data: "Erro ocorrido: " + err
            })
        } else {
            if (article) {
                res.json({
                    type: true,
                    data: article
                })
            } else {
                res.json({
                    type: false,
                    data: "Artigo: " + req.params.id + " não encontrado"
                })
            }
        }
    })
}

exports.viewArtigo_v2 = function(req, res, next) {
    Artigo.findById(new ObjectId(req.params.id), function(err, article) {
        if (err) {
            res.status(500);
            res.json({
                type: false,
                data: "Erro ocorrido: " + err
            })
        } else {
            if (article) {
                article.title = article.title + " v2"
                res.json({
                    type: true,
                    data: article
                })
            } else {
                res.json({
                    type: false,
                    data: "Artigo: " + req.params.id + " não encontrado"
                })
            }
        }
    })
}

exports.updateArtigo = function(req, res, next) {
    var updatedArtigoModel = new Artigo(req.body);
    Artigo.findByIdAndUpdate(new ObjectId(req.params.id), updatedArtigoModel, function(err, article) {
        if (err) {
            res.status(500);
            res.json({
                type: false,
                data: "Erro ocorrido: " + err
            })
        } else {
            if (article) {
                res.json({
                    type: true,
                    data: article
                })
            } else {
                res.json({
                    type: false,
                    data: "Artigo: " + req.params.id + " não encontrado"
                })
            }
        }
    })
}

exports.deleteArtigo = function(req, res, next) {
    Artigo.findByIdAndRemove(new Object(req.params.id), function(err, article) {
        if (err) {
            res.status(500);
            res.json({
                type: false,
                data: "Erro ocorrido: " + err
            })
        } else {
            res.json({
                type: true,
                data: "Artigo: " + req.params.id + " removido com sucesso"
            })
        }
    })
}
</pre>

<p>Uma explicação básica das operações CRUD em relação ao Mongoose pode ser visto logo abaixo:</p>

<ul>
  <li><strong>createArtigo: </strong>A operação <strong>save</strong> simplesmente salva os dados recebidos no corpo da requisição, usando o modelo <code class="inline">articleModel</code>. Um novo objeto <em>Artigo</em> pode ser criado, enviando os dados do corpo da requisição para o modelo em questão, dessa forma <code class="inline">var articleModel = new Artigo(req.body)</code>. </li>
  <li><strong>viewArtigo: </strong>Para vermos os detalhes do artigo, é preciso que tenhamos o ID de um artigo como parâmetro na URL. O método <code class="inline">findOne</code> usando o ID do parâmetro é mais que o suficiente para retornar os detalhes do artigo.</li>
  <li><strong>updateArtigo: </strong>A atualização de um <em>Artigo</em> é uma simples consulta e manipulação de dados em relação ao artigo retornado. Por fim, o artigo atualizado precisa ser salvo na base de dados, através do comando <code class="inline">save</code>.</li>
  <li><strong>deleteArtigo: O método </strong><code class="inline">findByIdAndRemove</code> é a melhor forma de removermos um artigo a partir do ID de um artigo.</li>
</ul>

<p>Os comandos do Mongoose mencionados acima são quase como métodos estáticos do objeto <em>Artigo</em>, o qual é uma referência a um esquema do Mongoose.</p>

<h4><strong>comment.js</strong></h4>

<pre class="brush: javascript">var mongoose = require('mongoose'),
Comentários = mongoose.model("Comentarios"),
    Artigo = mongoose.model("Artigo"),
    ObjectId = mongoose.Types.ObjectId

exports.viewComentarios = function(req, res) {
    Artigo.findOne({"comments._id": new ObjectId(req.params.id)}, {"comments.$": 1}, function(err, comment) {
        if (err) {
            res.status(500);
            res.json({
                type: false,
                data: "Erro ocorrido: " + err
            })
        } else {
            if (comment) {
                res.json({
                    type: true,
                    data: new Comentarios(comment.comments[0])
                })
            } else {
                res.json({
                    type: false,
                    data: "Comentário: " + req.params.id + " não encontrado"
                })
            }
        }
    })
}

exports.updateComentarios = function(req, res, next) {
    var updatedComentariosModel = new Comentarios(req.body);
    console.log(updatedComentariosModel)
    Artigo.update(
        {"comments._id": new ObjectId(req.params.id)},
        {"$set": {"comments.$.text": updatedComentariosModel.text, "comments.$.author": updatedComentariosModel.author}},
        function(err) {
            if (err) {
                res.status(500);
                res.json({
                    type: false,
                    data: "Erro ocorrido: " + err
                })
            } else {
                res.json({
                    type: true,
                    data: "Comentário: " + req.params.id + " atualizado"
                })
            }
    })
}

exports.deleteComentarios = function(req, res, next) {
    Artigo.findOneAndUpdate({"comments._id": new ObjectId(req.params.id)},
        {"$pull": {"comments": {"_id": new ObjectId(req.params.id)}}},
        function(err, article) {
        if (err) {
            res.status(500);
            res.json({
                type: false,
                data: "Erro ocorrido: " + err
            })
        } else {
            if (article) {
                res.json({
                    type: true,
                    data: article
                })
            } else {
                res.json({
                    type: false,
                    data: "Comentários: " + req.params.id + " não encontrado"
                })
            }
        }
    })
}</pre>

<p>Ao realizar uma requisição a uma das URIs, a função declarada no controlador será executada. Cada função dentro dos arquivos de controladores pode usar os objetos <strong>req</strong> e <strong>res</strong>. O recurso <strong>comentário</strong> logo acima, é um sub-recurso de <strong>Artigo</strong>. Todas as operações de consultas são realizadas através do modelo <em>Artigo</em> para, então, encontrarmos o subdocumento e realizar as atualizações necessárias. Contudo, toda vez que tentamos visualizar um recurso do tipo <em>Comentário</em>, você verá algo, mesmo que não exista uma coleção no MongoDB.  </p>

<h2>Outras Sugestões de Design</h2>

<ul>
  <li>Escolha recursos simples de entender para prover uso fácil aos clientes;</li>
  <li>Não deixe a lógica do negócio ser implementada pelos clientes. Por exemplo, o recurso <em>Artigo</em> tem um campo chamado <strong>slug</strong>. Os clientes não precisam enviar esse detalhe pela API RESTful. A estratégia em relação ao <em>slug</em> deve ser administrada no lado da API RESTful para minimizar o acoplamento entre a API e os clientes. Os clientes só precisam enviar o título e você pode gerar o <em>slug</em> de acordo com as necessidades do negócio, no lado da API RESTful.</li>
  <li>Implemente uma camada de autorização para suas APIs. Clientes não autorizados não podem acessar dados restritos pertencentes a outros usuários. Neste tutorial, não falamos sobre o recurso <em>Usuário, mas você pode ler o artigo <a href="http://code.tutsplus.com/pt/tutorials/token-based-authentication-with-angularjs-nodejs--cms-22543" target="_self">Autenticação com Tokens Usando AngularJS &amp; NodeJS</a> para mais informações em relação a autenticação de APIs.</li>
  <li>URIs amigáveis ao invés de vetor de consulta. <code class="inline">/articles/123</code> é bom, <code class="inline">/articles?id=123</code> é ruim.</li>
  <li>Não mantenha estados; sempre use entrada/saída instantâneas.</li>
  <li>Use substantivos para seus recursos. Você poderá usar os métodos/verbos HTTP para operar sobre os recursos.</li>
</ul>

<p>Finalmente, se você projetar uma API RESTful seguindo essas regras fundamentais, você sempre terá um sistema flexível, manutenível e compreensível.</p>