<h1>Refatorando Código Legado: Parte 8 - Invertendo Dependências para uma Arquitetura Limpa</h1>

<p>Código velho. Código feio. Código complicado. Código macarrônico. Código sem sentido. Em outras palavras, <em>Código Legado</em>. Esta é uma série que ajudará você a trabalhar e lidar com esse tipo de código.</p>

<p>É hora de falar sobre arquitetura e como organizaremos nossas camadas de código. É hora de tentarmos mapear nossa aplicação em relação ao projeto arquitetural teórico.</p>

<h2>Arquitetura Limpa</h2>

<p>Isso é algo que temos visto por nossos artigos e tutoriais. Arquitetura limpa.</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/21659/image/High Level Clean Architecture.png"/>
</figure>

<p>A alto nível, parece-se com o esquema acima e, tenho certeza, ele já deve ser familiar a você. É uma solução arquitetural proposta por Robert C. Martin.</p>

<p>No centro de nossa arquitetura está a lógica de negócios. Essas são as classes que representam os processos de negócios que nossa aplicação tentam resolver. Há entidades e interações representado o domínio de nosso problema.</p>

<p>Além disso, há vários outros tipos de módulos ou classes ao redor da nossa lógica de negócio. Elas podem ser vistas como módulos auxiliares. Eles servem para várias coisas e a maioria deles é indispensável. Eles proveem conexão entre o usuário e nossa aplicação, através de um mecanismo de entrega. No nosso caso, é a interface de linha de comando. Há outro conjunto de classes auxiliares que conectam nossa lógica de negócios à nossa camada de persistência e à todos os dados daquela camada, mas não temos essa camada em nossa aplicação. Além disso, há classes auxiliares de fábricas e construtores responsáveis pela criação de novos objetos de nossa lógica de negócios. Por fim, tem as classes que representam a porta de entrada do nosso sistema. No nosso caso, a classe <code>GameRunner</code> pode ser considerada desse tipo, ou mesmo todos nossos testes podem ser considerados portas de entrada a sua própria maneira.</p>

<p>O que é mais importante atentar no diagrama é a direção das dependências. Todas as classes auxiliares dependem da lógica de negócios. A lógica de negócios não dependem de qualquer outra coisa. Se todos os objetos da nossa lógica de negócios pudessem ter todos os dados com eles, magicamente, e pudéssemos ver o que acontece dentro do computador, veríamos que a lógica de negócio funcionaria sem problemas. Ela deve ser capaz de funcionar sem uma interface de usuário ou sem uma camada de negócios. A lógica de negócios deve existir isolada, em uma bolha em um universo de lógica.</p>

<h2>O Princípio da Inversão de Dependência</h2>

<blockquote>
  <p>A. Módulos de nível mais alto não deveriam depender de módulos de níveis mais baixos. Ambos deveriam depender de abstrações;
B. Abstrações não deveriam depender de detalhes. Detalhes que devem depender das abstrações.</p>
</blockquote>

<p>E é isso, o último dos princípios SOLID e aqueles com o maior efeito sobre seu código. É tanto simples de entender quanto simples de implementar.</p>

<p>De forma simples, é dito que algo concreto sempre deve depender de algo abstrato. Sua base de dados é bem concreta, então ela deve depender de algo mais abstrato. Sua Interface de Usuário é bem concreta, então ela deveria depender de algo mais abstrato. Suas fábricas são bem concretas, também. Logo, devem depender de algo abstrato. Mas, e a lógica do seu negócio? Dentro da lógico do seu negócio você deve continuar aplicando essas ideias, de modo que as classes mais próximas das fronteiras dependam de classes mais abstratas, presentes no coração da sua lógica de negócio.</p>

<p>Uma lógica de negócios pura representam o processo e comportamento de um domínio ou modelo de negócios definidos, de forma abstrata. Tal lógica de negócios não contem especificidade (coisas concretas), como valores, dinheiro, nomes de contas, senhas o tamanho de um botão ou o número de campos em um formulário. A lógica de negócios não deveria se preocupar com coisas concretas. Ela só deveria estar preocupada com os processos do seu negócio.</p>

<h3>O Truque Técnico</h3>

<p>Então, o Princípio da Inversão de Dependência (DIP) diz que deveríamos inverter nossas dependências sempre que há algum código que depende de algo concreto. Neste momento, nossa estrutura de dependências parece mais ou menos com isso.</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/21659/image/initial-dependency.png"/>
</figure>

<p>A classe <code>GameRunner</code>, usando as funções do arquivo <code>RunnerFunctions.php</code> cria um objeto do tipo <code>Game</code> e o usa. Por outro lado, nossa classe <code>Game</code>, representando nossa lógica de negócios, criar e usa um objeto <code>Display</code>.</p>

<p>Logo, o executador depende de nossa lógica de negócios. E isso está correto. Contudo, nossa classe <code>Game</code> depende da classe <code>Display</code>, o que não é bom. Nossa lógica de negócios nunca deve depende de nossa camada de apresentação.</p>

<p>O truque técnico mais simples que podemos usar é lançar mão dos construtos abstratos de nossa linguagem de programação. Uma classe tradicional é bem mais concreta que uma classe abstrata, que, por sua vez, é mais concreta que uma interface.</p>

<p>Uma <em>Classe Abstrata</em> é um tipo especial de classe que não pode ser inicializada. Ela apenas contém definições e implementações parciais. Uma classe abstrata de base, geralmente, tem diversas classes filhas. Essas classes filhas herdam a funcionalidade parcial pré-existente, adicionam seu próprio comportamento e devem implementar todos os métodos não implementados na classe pai abstrata.</p>

<p>Uma <em>Interface</em> é um tipo especial de classe que permite apenas a definição de métodos e variáveis. É o construto mais abstrato na programação orientada a objetos. Qualquer classe que a implemente deve implementar todos os métodos da interface. Uma classe concreta pode implementar diversas interfaces.</p>

<p>Exceto pela família do C de linguagens orientadas a objetos, outras linguagens como o Java ou PHP não permitem herança múltipla. Assim, uma classe concreta pode estender apenas uma única classe abstrata, mas pode implementar diversas interfaces, inclusive os dois ao mesmo tempo, se preciso. Ou, de outra maneira, uma única classe abstrata pode ter diversas implementações, enquanto diversas interfaces podem ter diversas implementações.</p>

<p>Para uma explicação mais completa sobre o princípio da inversão de dependência, por favor, leia <a href="http://code.tutsplus.com/pt/tutorials/solid-part-4-the-dependency-inversion-principle--net-36872">o tutorial dedicado a esse princípio SOLID</a>.</p>

<h3>Invertendo a Dependência Usando uma Interface</h3>

<p>O PHP dá suporte completo a interfaces. Então, começando com a classe <code>Display</code> como nosso modelo, poderíamos definir uma interface com os métodos públicos que todas as classes responsáveis por apresentar dados precisariam implementar.</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/21659/image/display-done.png"/>
</figure>

<p>Dando uma olhada na lista de métodos da classe <code>Display</code>, existem 12 métodos públicos, incluindo o construtor. Essa é uma interface bem grande. Deveríamos manter esse número ao mínimo possível, expondo as interfaces de acordo com as necessidades dos clientes. O <a href="http://code.tutsplus.com/pt/tutorials/solid-part-3-liskov-substitution-interface-segregation-principles--net-36710">Princípio da Segregação de Interfaces</a> nos fornece algumas boas ideias quanto a isso. Talvez lidaremos com esse problema em um tutorial futuro.</p>

<p>Agora, queremos alcançar uma arquitetura semelhante a que temos logo abaixo:</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/21659/image/dependency-inverted-with-interface.png"/>
</figure>

<p>Dessa forma, ao invés de termos uma classe <code>Game</code> dependendo de uma classe concreta <code>Display</code>, ambas dependeriam de uma interface bem abstrata. A classe <code>Game</code> usará a interface, enquanto a classe <code>Display</code> a implementará.</p>

<h3>Nomeando as Interfaces</h3>

<p>Phil Karlton uma vez disse: "Só existem duas coisas complicadas na Ciência da Computação: invalidação de <em>cache</em> e nomeação de coisas."</p>

<p>Enquanto não nos preocupamos com caches, precisamos nomear nossas classes, variáveis e métodos. Nomear interfaces pode ser bem desafiador.</p>

<p>Antigamente, no tempo da Notação Húngara, nós teríamos feito dessa forma:</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/21659/image/naming-hun-notation.png"/>
</figure>

<p>Nesse diagrama, usamos os nomes verdadeiros das classes/arquivos e usamos letras maiúsculas. A interface é chamada de "IDisplay" com "I" maiúsculos na frente de "Display". Para falar a verdade, existem linguagens de programação que exigiam esse tipo de nomeação para suas interfaces. Tenho certeza que alguns leitores ainda as usam e estão com um sorriso no rosto, neste momento.</p>

<p>O problema com esse esquema de nomeação é dúvida desnecessária. As interfaces pertencem a seus clientes. Nossa interface pertence à classe <code>Game</code>. Assim, a classe <code>Game</code> deve saber se usa uma interface ou um objeto real. A classe <code>Game</code> não precisa preocupar-se sobre qual implementação ela vai receber. Do ponto de vista da classe <code>Game</code>, é como se estivesse usando uma classe "Display", e mais nada.</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/21659/image/naming-display-impl.png"/>
</figure>

<p>Isso resolver o problema de nomeação entre <code>Game</code> e <code>Display</code>. Usar o sufixo "Impl" para a implementação é relativamente melhor. Ele ajuda a eliminar a dúvida da classe <code>Game</code>.</p>

<p>Além disso, é muito mais efetivo para nós. Pense na classe <code>Game</code> da forma que está agora. Ela usa um objeto <code>Display</code> e sabe como usá-lo. Se nomearmos nossa interface como "Display", reduziremos o número de mudanças necessárias na classe <code>Game</code>.</p>

<p>Ainda assim, essa nomeação é só um pouco melhor que a que estávamos usando, apenas permitindo uma implementação da classe <code>Display</code> e o nome da implementação não nos dirá com que tipo de apresentação estamos tratando.</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/21659/image/naming-display-cli.png"/>
</figure>

<p>Agora, sim, está consideravelmente melhor. Nossa implementação foi nomeada de "CLIDisplay", já que retorna para a linha de comando. Se quiséssemos um retorno em forma de HTML ou para uma interface de um aplicativo <em>desktop</em>, poderíamos adicioná-los todos à nossa arquitetura.</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/21659/image/naming-multiple-implementations.png"/>
</figure>

<h2>Mostre-me o Código</h2>

<p>Como temos dois tipos de testes, o lento <em>resultado esperado</em> e os rápidos, queremos depender dos testes unitários o máximo possível, o mínimo no <em>resultado esperado</em>. Então, marquemos nosso os testes do <em>resultado esperado</em> para serem pulados e dependamos apenas dos nossos testes unitários. Eles estão verdes e queremos realizar mudanças que os mantenham verdes. Mas, como podemos fazer isso, sem realizar todas as mudanças propostas acima?</p>

<p>Existe algum teste que nos permitiria ir mais devagar?</p>

<h3>A Simulação Salva o Dia</h3>

<p>Sim, existe! Há um conceito chamado de "simulação", nos testes.</p>

<p>A Wikipedia define a simulação assim, "Em programação orientada a objetos, objetos simulados são objetos que imitam o comportamento de objetos reais de forma controlada."</p>

<p>Um objeto desses viria bem a calhar. Na verdade, não precisamos de algo tão complexo a ponto de simular todo o comportamento. Só precisamos de um objeto falso e simplório que podemos enviar para o objeto <code>Game</code> ao invés da lógica de apresentação verdadeira.</p>

<h3>Criando a Interface</h3>

<p>Criemos uma interface chamada <code>Display</code> com todos os métodos públicos da nossa classe concreta atual.</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/21659/image/create-interface.png"/>
</figure>

<p>Como pode observar, a antiga classe <code>Display.php</code> foi renomeada para <code>DisplayOld.php</code>. Esse é apenas um passo temporário, que nos permitirá removê-lo do nosso caminho para concentrarmo-nos na interface.</p>

<pre class="brush: php">interface Display {

} </pre>

<p>Isso é tudo o que é preciso para a criação de uma interface. Veja que ela é definida como "interface" não como "class". Adicionemos os métodos:</p>

<pre class="brush: php">interface Display {
	function statusAfterRoll($rolledNumber, $currentPlayer);
	function playerSentToPenaltyBox($currentPlayer);
	function playerStaysInPenaltyBox($currentPlayer);
	function statusAfterNonPenalizedPlayerMove($currentPlayer, $currentPlace, $currentCategory);
	function statusAfterPlayerGettingOutOfPenaltyBox($currentPlayer, $currentPlace, $currentCategory);
	function playerAdded($playerName, $numberOfPlayers);
	function  askQuestion($currentCategory);
	function correctAnswer();
	function correctAnswerWithTypo();
	function incorrectAnswer();
	function playerCoins($currentPlayer, $playerCoins);
} </pre>

<p>Sim. Uma interface é apenas um conjunto de declarações de métodos. Imagine-os como um arquivo de cabeçalho do C. Sem implementações, apenas declarações. Não podemos ter uma implementação sequer. Se tentar implementar qualquer um dos métodos, resultará em um erro.</p>

<p>Mas essas definições tão abstratas nos permitirão realizar coisas maravilhosas. Nossa classe <code>Game</code> agora depende delas, ao invés de uma implementação concreta. No entanto, ao tentarmos executar nossos testes, eles falharão.</p>

<pre class="brush: php">Fatal error: Cannot instantiate interface Display</pre>

<p>Isso é porque a classe <code>Game</code> tenta criar um novo objeto do tipo <code>Display</code> por conta própria, na linha 25, dentro do construtor.</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/21659/image/creates-display-in-constructor.png"/>
</figure>

<p>Sabemos que não podemos fazer isso. Um interface ou uma classe abstrata não podem ser instanciadas. Precisamos de um objeto real.</p>

<h3>Injeção de Dependência</h3>

<p>Precisamos de um objeto postiço para ser usado em nossos testes. Uma classe simples, implementando todos os métodos da interface <code>Display</code>, mas fazendo nada. Criemos essa classe diretamente em nosso teste unitário. Se sua linguagem de programação não permite diversas classes no mesmo arquivo, sinta-se livre para criar um novo arquivo para sua classe postiça.</p>

<pre class="brush: php">class DummyDisplay implements Display {

	function statusAfterRoll($rolledNumber, $currentPlayer) {
		// TODO: Implementar o método statusAfterRoll().
	}

	function playerSentToPenaltyBox($currentPlayer) {
		// TODO: Implementar o método playerSentToPenaltyBox().
	}

	function playerStaysInPenaltyBox($currentPlayer) {
		// TODO: Implementar o método playerStaysInPenaltyBox().
	}

	function statusAfterNonPenalizedPlayerMove($currentPlayer, $currentPlace, $currentCategory) {
		// TODO: Implementar o método statusAfterNonPenalizedPlayerMove().
	}

	function statusAfterPlayerGettingOutOfPenaltyBox($currentPlayer, $currentPlace, $currentCategory) {
		// TODO: Implementar o método statusAfterPlayerGettingOutOfPenaltyBox().
	}

	function playerAdded($playerName, $numberOfPlayers) {
		// TODO: Implementar o método playerAdded().
	}

	function  askQuestion($currentCategory) {
		// TODO: Implementar o método askQuestion().
	}

	function correctAnswer() {
		// TODO: Implementar o método correctAnswer().
	}

	function correctAnswerWithTypo() {
		// TODO: Implementar o método correctAnswerWithTypo().
	}

	function incorrectAnswer() {
		// TODO: Implementar o método incorrectAnswer().
	}

	function playerCoins($currentPlayer, $playerCoins) {
		// TODO: Implementar o método playerCoins().
	}
}</pre>

<p>Tão logo você diga que sua classe implementa uma determinada interface, sua IDE automaticamente criará os métodos faltantes. Isso torna a criação de objetos desse tipo bem fácil e rápido.</p>

<p>Agora, usemos essa classe postiça na classe <code>Game</code>, inicilizando-a no construtor:</p>

<pre class="brush: php">function  __construct() {

	$this-&gt;players = array();
	$this-&gt;places = array(0);
	$this-&gt;purses = array(0);
	$this-&gt;inPenaltyBox = array(0);

	$this-&gt;display = new DummyDisplay();
}</pre>

<p>Isso faz os testes passarem, mas introduz um enorme problema: A classe <code>Game</code> precisa saber sobre seu teste e não queremos que isso ocorra. Um teste é outro ponto de entrada. A classe <code>DummyDisplay</code> é apenas outra interface de usuário. Nossa lógica de negócio, a classe <code>Game</code>, não deve depender da interface de usuário. Façamo-la depender apenas da interface.</p>

<pre class="brush: php">function  __construct(Display $display) {

	$this-&gt;players = array();
	$this-&gt;places = array(0);
	$this-&gt;purses = array(0);
	$this-&gt;inPenaltyBox = array(0);

	$this-&gt;display = $display;
}</pre>

<p>Contudo, para testar a classe <code>Game</code>, precisamos passar a classe postiça a partir de nossos testes.</p>

<pre class="brush: php">function setUp() {
	$this-&gt;game = new Game(new DummyDisplay());
}</pre>

<p>E é isso! Precisamos modificar uma única linha em nossos testes unitários. Na configuração, devemos enviar, por parâmetro, uma nova instância da classe <code>DummyDisplay</code>. Isso é o que chamamos de injeção de dependência. Usar interfaces e injeção de dependências ajudará, principalmente, se estiver trabalhando em equipe. Nós, na Syneto, percebemos que ao especificar um tipo de interface para uma classe e injetando-a, ajuda-nos a comunicar muito melhor as intenções do objeto cliente. Qualquer um olhando o código do cliente saberá que tipo de objeto é usado nos parâmetros. E um extra bacana é que sua IDE autocompleta os métodos para esses parâmetros, uma vez que eles pode determinar seus tipos.</p>

<h3>Uma Implementação Real para o <em>Resultado Esperado</em></h3>

<p>O teste do <em>resultado esperado</em> executa nosso código como se ele fosse executado no mundo real. Para fazê-lo passar, precisamos transformar nossa antiga classe <code>display</code> em uma implementação real de uma interface e passá-la para nossa lógica de negócio. Eis uma forma de fazê-lo:</p>

<pre class="brush: php">class CLIDisplay implements Display {
	// ... //
}</pre>

<p>Renomeia-a para <code>CLIDisplay</code> e faça-a implementar a interface <code>Display</code>.</p>

<pre class="brush: php">function run() {
	$display = new CLIDisplay();
	$aGame = new Game($display);
	$aGame-&gt;add("Chet");
	$aGame-&gt;add("Pat");
	$aGame-&gt;add("Sue");

	do {
		$dice = rand(0, 5) + 1;
		$aGame-&gt;roll($dice);
	} while (!didSomebodyWin($aGame, isCurrentAnswerCorrect()));
}</pre>

<p>No arquivo <code>RunnerFunctions.php</code>, na função <code>run()</code>, crie um novo objeto de apresentação para linha de comando e o envie-o para a classe <code>Game</code> quando for criado.</p>

<p>Remova o comentário e execute os testes do seu <em>resultado esperado</em>. Eles passarão.</p>

<h2>Pontos Finais</h2>

<p>Efetivamente, essa solução leva a uma arquitetura tal qual o diagrama abaixo.</p>

<figure class="post_image">
  <img alt="" src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/45/posts/21659/image/final-architecture.png"/>
</figure>

<p>Agora, o executador do nosso jogo, que é a porta de entrada para o jogo, criar uma classe concreta do tipo <code>CLIDisplay</code>, dependendo, assim, dela. A classe <code>CLIDisplay</code> depende apenas da interface que divide a camada de apresentação da lógica de negócio. Nosso executador também depende diretamente da lógica de negócio. É assim que nossa aplicação se parece quando projetada com uma arquitetura limpa em mente desde o começo.</p>

<p>Obrigado pela leitura e não perca o próximo tutorial, onde falaremos sobre simulação e interação de classes em mais detalhes.</p>