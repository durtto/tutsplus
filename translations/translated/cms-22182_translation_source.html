<h1>Refatorando Código Legado: Parte 10: Dissecando Métodos Longos Através de Extrações</h1>

<p>Na <a href="http://code.tutsplus.com/tutorials/refactoring-legacy-code-part-6-attacking-complex-methods--cms-21522">sexta parte de nossa série</a>, falamos sobre como trabalhar com métodos longos, através do uso da programação em par e da visualização de código em diferentes níveis. Continuamente, aumentamos e diminuímos o nível de visualização, e observamos tanto coisas pequenas como a parte da nomeação, quanto a forma e a indentação do código.</p>

<p>Hoje, usaremos outra abordagem: Assumiremos que estamos sozinhos, sem companheiros de trabalho para nos ajudar. Usaremos uma técnica chamada "Extrair até a exaustão" que divide o código em várias pequenas partes. Esforçar-nos-emos para fazer com que essas partes sejam o mais entendíveis possível, de modo que nós do futuro, ou qualquer outro programador, sejam capazes de entendê-las facilmente.</p>



<h2>Extrair Até A Exaustão</h2>

<p>A primeira vez que ouvi falar desse conceito foi a partir do Robert C. Martin. Ele apresentou essa ideia em um de seus vídeos, como uma forma simples de refatorar códigos que são difíceis de entender.</p>

<p>A ideia básica é pegar partes pequenas e entendíveis de código e extraí-las. Não importa se você conseguir identificar quatro linhas de código ou quatro caracteres que podem ser extraídos. Ao identificar algo que pode ser encapsulado em um conceito mais claro, você deve extraí-lo. Você continua a fazer isso tanto no método original quanto nas partes recém extraídas, até que você não possa mais encontrar partes de código que possam ser encapsuladas de alguma outra forma. </p>

<p>Essa técnica é bastante útil quando se trabalha sozinho. Ela força você a pensar tanto nas partes pequenas quanto nas partes grandes de código. Ela tem um outro ótimo efeito: ela faz você pensar, e muito, sobre o código! Além da refatoração de extração de método ou variável mencionados acima, você realizará várias renomeações de variáveis, funções, classes e muito mais.</p>

<p>Vejamos um exemplo de um código aleatório da Internet. O Stackoverflow é um ótimo lugar para encontrar pequenos trechos de código. Eis um trecho que <a href="http://stackoverflow.com/questions/15051592/how-to-find-prime-factors-in-a-range-in-php">determina se um número é primo</a>:</p>

<pre class="brush: php">//Verifica se o número é primo
function isPrime($num, $pf = null)
{
if(!is_array($pf))
    {
        for($i=2;$i&lt;intval(sqrt($num));$i++) {
            if($num % $i==0) {
                return false;
            }
        }
        return true;
    } else {
        $pfCount = count($pf);
        for($i=0;$i&lt;$pfCount;$i++) {
            if($num % $pf[$i] == 0) {
                return false;
            }
        }
        return true;
    }
}</pre>

<p>A essa altura, não tenho ideia como esse código funciona. Apenas o encontrei na Internet enquanto escrevia esse artigo e aprenderei mais sobre ele, junto de você. O processo a seguir pode não ser o mais claro. Ao invés disso, ele refletirá meus pensamentos e refatorações de acordo com que elas forem surgindo, sem qualquer planejamento anterior.</p>

<h3>Refatorando o Verificador de Números Primos</h3>

<p>De acordo com a Wikipedia:</p>

<blockquote>Um número primo é um número natural maior que 1 que não possui quaisquer outros divisores além do 1 e dele próprio. </blockquote>

<p>Como pode ver, esse é um método simples para um problema matemático simples. Ele retorna <code class="inline">true</code> ou <code class="inline">false</code>, então, deve ser bem fácil testá-lo.</p>

<pre class="brush: php">class IsPrimeTest extends PHPUnit_Framework_TestCase {

function testItCanRecognizePrimeNumbers() {
		$this-&gt;assertTrue(isPrime(1));
	}

}

// Verifica se um número é primo
function isPrime($num, $pf = null)
{
	// ... o conteúdo do método como visto mais acima
}</pre>

<p>Como estamos apenas brincando com um código de exemplo, o caminho mais fácil é colocar tudo dentro de um arquivo de teste. Dessa forma, não precisaremos pensar sobre quais arquivos criar, a quais diretórios eles pertencem ou como incluí-los uns nos outros. Este é um exemplo simples para familiarizarmo-nos com a técnica antes de aplicarmos em um dos métodos do jogo de perguntas e respostas. Então, como tudo irá num só arquivo de testes, você pode nomeá-lo como deseja. O nomeei de <code>IsPrimeTest.php</code>.</p>

<p>Esse teste passa. Meu instinto me diz que o próximo passo é adicionar alguns outros números primos e escrever um outro teste com números não primos.</p>

<pre class="brush: php">function testItCanRecognizePrimeNumbers() {
$this-&gt;assertTrue(isPrime(1));
	$this-&gt;assertTrue(isPrime(2));
	$this-&gt;assertTrue(isPrime(3));
	$this-&gt;assertTrue(isPrime(5));
	$this-&gt;assertTrue(isPrime(7));
	$this-&gt;assertTrue(isPrime(11));
}</pre>

<p>Isso passa. Mas, e quanto a isso?</p>

<pre class="brush: php">function testItCanRecognizeNonPrimes() {
$this-&gt;assertFalse(isPrime(6));
}</pre>

<p>Inesperadamente, falha: 6 não é um número primo. Esperava que o método retorna-se <code class="inline">false</code>. Não sei como o método funciona, ou o propósito do parâmetro <code>$pf</code> - simplesmente esperava que ele retornasse <code class="inline">false</code>, baseado no seu nome e descrição. Faço a menor ideia do porque não funciona ou como corrigi-lo.</p>

<p>Esse é um dilema bem confuso. O que deveríamos fazer? A melhor resposta de criar testes que passem para uma grande quantidade de número. É na tentativa e erro, mas, pelo menos, teremos alguma ideia sobre o que o método faz. Depois disso, poderemos começar a refatora-lo.</p>

<pre class="brush: php">function testFirst20NaturalNumbers() {
for ($i=1;$i&lt;20;$i++) {
		echo $i . ' - ' . (isPrime($i) ? 'true' : 'false') . "\n";
	}
}</pre>

<p>Ele retorna algo bem interessante:</p>

<pre class="brush: bash">1 - true
2 - true
3 - true
4 - true
5 - true
6 - true
7 - true
8 - true
9 - true
10 - false
11 - true
12 - false
13 - true
14 - false
15 - true
16 - false
17 - true
18 - false
19 - true</pre>

<p>Um padrão começa a emergir. Tudo sai como <code>true</code> até o número 9, quando começa a alternar com <code>false</code> até o 19. Mas, há algum padrão em repetição? Tente executá-lo para 100 números e, imediatamente, verá que não é um padrão. Ele parece funcionar para números entre 40 e 99. Ele falha com números entre 30 e 39, dizendo que o 35 é primo. O mesmo acontecem no conjunto 20 a 29, onde ele diz que o 25 é primo.</p>

<p>Esse exercício iniciou como um código simples para demonstrar uma técnica que se mostra muito mais difícil que o esperado. Resolvi mantê-la, porque ela reflete a vida real de uma forma bem pertinente.</p>

<blockquote>Quantas vezes você começou a trabalhar em uma tarefa que pareceu ser simples e acabou descobrindo que era extremamente difícil?</blockquote>

<p>Não queremos corrigir o código. Independentemente do que o método faz, ele deve continuar a fazê-lo. Queremos refatorá-lo para que outros possam entendê-lo melhor.</p>

<p>Como ele não aponta corretamente os número primos, usaremos a mesma <a href="http://code.tutsplus.com/pt/tutorials/refactoring-legacy-code-part-1-the-golden-master--cms-20331">abordagem do <em>Resultado Esperado</em> que usamos no primeiro artigo</a>.</p>

<pre class="brush: php">function testGenerateGoldenMaster() {
for ($i=1;$i&lt;10000;$i++) {
		file_put_contents(__DIR__ . '/IsPrimeGoldenMaster.txt', $i . ' - ' . (isPrime($i) ? 'true' : 'false') . "\n", FILE_APPEND);
	}
}</pre>

<p>Execute esse código uma vez para gerar o <em>Resultado Esperado</em>. Ele deve executar bem rápido. Se precisar executá-lo novamente, não esqueça de remover o arquivo gerado antes de executar o teste. Ou o resultado será adicionado ao final do conteúdo anterior.</p>

<pre class="brush: php">function testMatchesGoldenMaster() {
$goldenMaster = file(__DIR__ . '/IsPrimeGoldenMaster.txt');
	for ($i=1;$i&lt;10000;$i++) {
		$actualResult = $i . ' - ' . (isPrime($i) ? 'true' : 'false'). "\n";
		$this-&gt;assertTrue(in_array($actualResult, $goldenMaster), 'O valor ' . $actualResult . ' não é o resultado esperado.');
	}
}</pre>

<p>Agora, crie o testes para o resultado esperado. Essa solução pode não ser a mais rápida, mas é fácil de entender e dirá qual o número exato não combina, caso algo dê errado. Mas, do jeito que está, existe duplicação de código em dois métodos de testes. Poderíamos extraí-la em um método <code class="inline">private</code>.</p>

<pre class="brush: php">class IsPrimeTest extends PHPUnit_Framework_TestCase {

function testGenerateGoldenMaster() {
		$this-&gt;markTestSkipped();
		for ($i=1;$i&lt;10000;$i++) {
			file_put_contents(__DIR__ . '/IsPrimeGoldenMaster.txt', $this-&gt;getPrimeResultAsString($i), FILE_APPEND);
		}
	}

	function testMatchesGoldenMaster() {
		$goldenMaster = file(__DIR__ . '/IsPrimeGoldenMaster.txt');
		for ($i=1;$i&lt;10000;$i++) {
			$actualResult = $this-&gt;getPrimeResultAsString($i);
			$this-&gt;assertTrue(in_array($actualResult, $goldenMaster), 'O valor ' . $actualResult . ' não é o resultado esperado.');
		}
	}

	private function getPrimeResultAsString($i) {
		return $i . ' - ' . (isPrime($i) ? 'true' : 'false') . "\n";
	}
}</pre>

<p>Agora, podemos continuar para nosso código de produção. Os testes executam em cerca de dois segundos no meu computador, então, é algo aceitável.</p>

<h3>Extraindo Tudo Que Pudermos</h3>

<p>Primeiro, podemos extrair um método chamado <code class="inline">isDivisible()</code>, na primeira parte do código.</p>

<pre class="brush: php">if(!is_array($pf))
{
for($i=2;$i&lt;intval(sqrt($num));$i++) {
		if(isDivisible($num, $i)) {
			return false;
		}
	}
	return true;
}</pre>

<p>Isso nos permitirá reusar o código na segunda parte do código, dessa forma:</p>

<pre class="brush: php">} else {
$pfCount = count($pf);
	for($i=0;$i&lt;$pfCount;$i++) {
		if(isDivisible($num, $pf[$i])) {
			return false;
		}
	}
	return true;
}</pre>

<p>E, tão logo começamos a trabalhar com esse código, percebemos que ele é mal indentado e alinhado. Algumas vezes, as chaves aparecem no começo da linha, outras vezes, no final. </p>

<p>Algumas vezes, vemos o uso de tabulação para indentação, outra vezes vemos espaços. Algumas vezes, há espaços entre operando e operador, outras vezes não. E, não, esse código não foi criado para ser desse jeito. Isso é código da vida real. Código de verdade, não algum exercício artificial.</p>

<pre class="brush: php">//Verifica se um númeor é primo
function isPrime($num, $pf = null) {
if (!is_array($pf)) {
		for ($i = 2; $i &lt; intval(sqrt($num)); $i++) {
			if (isDivisible($num, $i)) {
				return false;
			}
		}
		return true;
	} else {
		$pfCount = count($pf);
		for ($i = 0; $i &lt; $pfCount; $i++) {
			if (isDivisible($num, $pf[$i])) {
				return false;
			}
		}
		return true;
	}
}</pre>

<p>Assim está muito melhor. Imediatamente, as duas declarações <code class="inline">if</code> estão bem parecidas. Mas não podemos extraí-las por conta das declarações <code class="inline">return</code>. Se não retornarmos algo, quebraremos a lógica.</p>

<p>Se o método extraído retornar um booleano e tivermos de verificar se devemos retornar do <code>isPrime()</code>, isso não ajudaria em qualquer coisa. Deve existir uma forma de extraí-lo através do uso <a href="http://code.tutsplus.com/tutorials/functional-programming-in-php--net-35043">de conceitos funcionais no PHP</a>, talvez depois. Podemos fazer algo mais simples, primeiro.</p>

<pre class="brush: php">function isPrime($num, $pf = null) {
if (!is_array($pf)) {
		return checkDivisorsBetween(2, intval(sqrt($num)), $num);
	} else {
		$pfCount = count($pf);
		for ($i = 0; $i &lt; $pfCount; $i++) {
			if (isDivisible($num, $pf[$i])) {
				return false;
			}
		}
		return true;
	}
}

function checkDivisorsBetween($start, $end, $num) {
	for ($i = $start; $i &lt; $end; $i++) {
		if (isDivisible($num, $i)) {
			return false;
		}
	}
	return true;
}</pre>

<p>Extrair o laço <code class="inline">for</code> por completo é um pouco mais fácil, mas, ao tentarmos reutilizar nosso método extraído na segunda parte do <code>if</code>, percebemos que ele não funciona. Isso se dá pela existência da misteriosa variável <code>$pf</code>, a qual sabemos quase nada. </p>

<p>Parece que ela verifica se o número é divisível por um conjunto específico de divisores ao invés de pegar todos os divisores até o número mágico determinado por <code>intval(sqrt($num))</code>. Talvez devêssemos renomear <code>$pf</code> em <code>$divisors</code>.</p>

<pre class="brush: php">function isPrime($num, $divisors = null) {
if (!is_array($divisors)) {
		return checkDivisorsBetween(2, intval(sqrt($num)), $num);
	} else {
		return checkDivisorsBetween(0, count($divisors), $num, $divisors);
	}
}

function checkDivisorsBetween($start, $end, $num, $divisors = null) {
	for ($i = $start; $i &lt; $end; $i++) {
		if (isDivisible($num, $divisors ? $divisors[$i] : $i)) {
			return false;
		}
	}
	return true;
}</pre>

<p>Essa é uma das formas de fazer. Adicionamos um quarto parâmetro adicional em nosso método de verificação. Se ele possuir algum valor, usamos, caso contrário, usamos <code>$i</code>. </p>

<p>Podemos extrair alguma outra coisa? Que tal esse pequeno trecho de código: <code>intval(sqrt($num))</code>?</p>

<pre class="brush: php">function isPrime($num, $divisors = null) {
if (!is_array($divisors)) {
		return checkDivisorsBetween(2, integerRootOf($num), $num);
	} else {
		return checkDivisorsBetween(0, count($divisors), $num, $divisors);
	}
}

function integerRootOf($num) {
	return intval(sqrt($num));
}</pre>

<p>Isso não está muito melhor? De certa forma. Está melhor se a pessoa não souber o que <code>intval()</code> e <code>sqrt()</code> realizam, mas não ajuda a melhorar o entendimento da lógica. Por que terminamos nosso laço <code class="inline">for</code> naquele número em específico? Talvez essa seja a pergunta o nome da nossa função devesse responder.</p>

<pre class="brush: php">[PHP]//Verifica se um númeor é primo
function isPrime($num, $divisors = null) {
if (!is_array($divisors)) {
		return checkDivisorsBetween(2, highestPossibleFactor($num), $num);
	} else {
		return checkDivisorsBetween(0, count($divisors), $num, $divisors);
	}
}

function highestPossibleFactor($num) {
	return intval(sqrt($num));
}[PHP]</pre>

<p>Isso está melhor, já que explica o porque paramos nele. Talvez, no futuro, possamos inventar uma fórmula diferente para determinar aquele número. A nomeação também trouxe um pouco de inconsistência. Nós chamamos de fatores dos números, que é um sinônimo de divisores. Talvez devêssemos escolher um e usar apenas aquele. Permitirei você realizar a renomeação e refatoração como um exercício.</p>

<p>A pergunta é: podemos extrair algo mais? Bem, devemos tentar até a exaustão. Mencionei a possibilidade de aplicar o paradigma funcional no PHP, alguns parágrafos acima. Existem duas características da programação funcional que podemos aplicar no PHP, facilmente: funções de primeira ordem e recursão. Toda vez que vejo uma declaração <code class="inline">if</code> junto de um <code class="inline">return</code> dentro de um laço <code class="inline">for</code>, como no nosso método <code>checkDivisorsBetween()</code>, imagino a aplicação de uma ou das duas técnicas.</p>

<pre class="brush: php">function checkDivisorsBetween($start, $end, $num, $divisors = null) {
for ($i = $start; $i &lt; $end; $i++) {
		if (isDivisible($num, $divisors ? $divisors[$i] : $i)) {
			return false;
		}
	}
	return true;
}</pre>

<p>Mas, por que deveríamos passar por esse processo tão complexo? O motivo mais chato para isso é que esse método realiza duas coisas distintas: Ele itera e toma decisões. Quero que ele apenas itere e deixe a decisão para outro método. Um método sempre deve realizar uma única coisa e da melhor forma possível.</p>

<pre class="brush: php">function checkDivisorsBetween($start, $end, $num, $divisors = null) {
$numberIsNotPrime = function ($num, $divisor) {
		if (isDivisible($num, $divisor)) {
			return false;
		}
	};
	for ($i = $start; $i &lt; $end; $i++) {
		$numberIsNotPrime($num, $divisors ? $divisors[$i] : $i);
	}
	return true;
}</pre>

<p>Nossa primeira tentativa foi extrair a condição e a declaração de retorno em uma variável. Ela será local, por hora. Mas o código não funciona. Na verdade, o laço <code>for</code> complica bastante as coisas. Acho que precisaremos lançar mão de recursão.</p>

<pre class="brush: php">function checkRecursiveDivisibility($current, $end, $num, $divisor) {
if($current == $end) {
		return true;
	}
}</pre>

<p>Quando pensamos sobre recursividade, devemos sempre começar com os casos excepcionais. Nossa primeira exceção é quando chegamos ao final da recursão.</p>

<pre class="brush: php">function checkRecursiveDivisibility($current, $end, $num, $divisor) {
if($current == $end) {
		return true;
	}

	if (isDivisible($num, $divisor)) {
		return false;
	}
}</pre>

<p>Nosso segundo caso excepcional que quebrará a recursão é quando o número for divisível. Não queremos que a recursão continue. E esses sãos todos nossos casos excepcionais.</p>

<pre class="brush: php">ini_set('xdebug.max_nesting_level', 10000);
function checkDivisorsBetween($start, $end, $num, $divisors = null) {
return checkRecursiveDivisibility($start, $end, $num, $divisors);
}

function checkRecursiveDivisibility($current, $end, $num, $divisors) {
	if($current == $end) {
		return true;
	}

	if (isDivisible($num, $divisors ? $divisors[$current] : $current)) {
		return false;
	}

	checkRecursiveDivisibility($current++, $end, $num, $divisors);
}</pre>

<p>Essa é uma outra tentativa de usar recursão em nosso problema, mas, infelizmente, mais de 10mil recursões no PHP induz a uma falha na sistema do PHP ou do PHPUnit, no meu computador. Então, isso talvez seja um outro beco sem saída. Mas, se tivesse funcionando, seria um ótima substituto para a lógica original.</p>



<h2>Desafio</h2>

<p>Quando criei o <em>Resultado Esperado</em>, deixei passar algo, intencionalmente. Digamos apenas que os testes não cobrem tanto código quanto deveriam. Você é capaz de encontrar o problema? Se sim, como você o resolveria?</p>



<h2>Pontos Finais</h2>

<p>"Extraia até a exaustão" é uma ótima maneira de dissecar métodos longos. Ela força você a pensar em pequenos trechos de códigos e dar sentido a essas peças, extraindo-as em métodos. Acho incrível como esse simples  procedimento, junto de renomeação frequente, ajudam-me a descobrir que algum código é capaz de fazer algo que eu nunca pensei que pudesse.</p>

<p>Em nosso próximo e último artigo sobre refatoração, aplicaremos essa técnica no jogo de perguntas e respostas. Espero que tenha gostado desse tutorial, um tanto quanto diferente. Ao invés de trabalhar com exemplos de livros, pegamos um código de verdade e começamos a lutar contra exemplos reais que vemos todos os dias.</p>