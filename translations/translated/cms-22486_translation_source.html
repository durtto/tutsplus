<h1>Laravel, BDD e Você: A Primeira Funcionalidade</h1>

<p>Na segunda parte desta série chamada <em>Laravel, BDD e Você</em>, começaremos a descrever e construir nossa primeira funcionalidade, usando o Behat e o PhpSpec. No artigo anterior, preparamos tudo e vimos o quão fácil podemos interagir com o Laravel, usando cenários do Behat.</p>

<p>Recentemente, o autor do Behat, Konstantin Kudryashov (também conhecido como everzet), escreveu um ótimo artigo: <a href="http://everzet.com/post/99045129766/introducing-modelling-by-example" target="_self">Introduzindo Modelagem Através de Exemplos</a>. O fluxo de trabalho que usaremos, ao construir essa funcionalidade, é bastante inspirada na apresentada por everzet. </p>

<p>Em resumo, usaremos a mesma <code class="inline">.feature</code> para projetar tanto o domínio base quanto nossa interface de usuário. Sempre senti que tinha muita duplicidade em minhas características nos meus conjuntos de testes de aceitação/funcional e de integração. Ao ler a sugestão de everzet sobre usar as mesmas características para múltiplos contextos, tive uma epifania e acredito que esse seja o jeito certo de fazer as coisas. </p>

<p>Em nosso caso, teremos o contexto funcional, que, por hora, também servirá como nossa camada de aceitação, e o contexto de integração, que cobrirá nosso domínio. Começaremos pela construção do domínio e, então, adicionaremos nossa interface de usuário e coisas específicas do <em>framework</em> mais para frente.</p>

<h2>Pequenas Refatorações</h2>

<p>Para usarmos a abordagem de "característica compartilhada, contextos múltiplos", precisamos realizar algumas refatorações em nosso projeto.</p>

<p>Primeiro, removeremos a <em>feature</em> de boas-vindas que fizemos no primeiro tutorial, uma vez que ela não é necessária, além de não seguir qualquer estilo genérico que precisamos para permitir os contextos múltiplos.</p>

<div>
  <pre class="brush: bash">$ git rm features/functional/welcome.feature</pre>
</div>

<p>Segundo, colocaremos nossas características na raiz do diretório <code>features</code>. Assim, podemos remover o atributo <code>path</code> do nosso arquivo <code>behat.yml</code>. Também renomearemos o contexto <code>LaravelFeatureContext</code> para <code>FunctionalFeatureContext</code> (lembre-se de também renomear a classe correspondente):</p>

<div>
  <pre class="brush: plain">default:
suites:
        functional:
            contexts: [ FunctionalFeatureContext ]</pre>
</div>

<p>Finalmente, para limpar um pouco as coisas, acredito que devemos mover todas as coisas relacionadas ao Laravel para uma <code class="inline">trait</code> própria:</p>

<div>
  <pre class="brush: php"># features/bootstrap/LaravelTrait.php

&lt;?php

use Illuminate\Foundation\Testing\ApplicationTrait;

trait LaravelTrait
{
/**
     * Responsável por prover uma instância do app Laravel.
     */
    use ApplicationTrait;

    /**
     * @BeforeScenario
     */
    public function setUp()
    {
        if ( ! $this-&gt;app)
        {
            $this-&gt;refreshApplication();
        }
    }

    /**
     * Cria a aplicação.
     *
     * @return \Symfony\Component\HttpKernel\HttpKernelInterface
     */
    public function createApplication()
    {
        $unitTesting = true;

        $testEnvironment = 'testing';

        return require __DIR__.'/../../bootstrap/start.php';
    }
}

</pre>
</div>

<p>Então podemos usar o <em>trait</em> que acabamos de criar, lá no contexto <code>FunctionalFeatureContext</code>, e remover as coisas que acabamos de copiar:</p>

<div>
  <pre class="brush: php">/**
 * Behat context class.
 */
class FunctionalFeatureContext implements SnippetAcceptingContext
{
use LaravelTrait;

    /**
     * Initializes context.
     *
     * Every scenario gets its own context object.
     * You can also pass arbitrary arguments to the context constructor through behat.yml.
     */
    public function __construct()
    {
    }</pre>
</div>

<p>Os <em>traits</em> são uma ótima forma de deixar seus contextos mais limpos e simples.</p>

<h2>Compartilhando a Característica</h2>

<p>Como apresentado na parte um, construiremos uma pequena aplicação de marcação de tempo. A primeira característica será em relação à marcação do tempo em si e da geração de uma planilha com todos os tempos registrados. Eis a descrição da nossa característica:</p>

<div>
  <pre>Feature: Marcação de tempo
Para marcar o tempo gasto nas tarefas
    Como um funcionário
    Preciso administrar uma planinha com os registros dos tempos gastos

    Scenario: Gerando a planilha de tempo
        Given A planilha abaixo com as marcações
            | tarefa           | duracao |
            | programando      | 90      |
            | programando      | 30      |
            | documentando     | 150     |
        When na hora de gerar a planilha de tempo
        Then meu tempo total gasto programando deve ser de 120 minutos
        And meu tempo total gasto documentando deve ser de 150 minutos
        And meu tempo total em reuniões deve ser de 0 minutos
        And meu tempo total gasto deve ser de 270 minutos
</pre>
</div>

<p>Lembre-se, isso é só um exemplo. Eu acho mais fácil de definir uma as características em casos da vida real, uma vez que você possui um problema real para resolver e, geralmente, tem a chance de discutir as características com os colegas, clientes ou outros interessados.</p>

<p>Certo, deixemos o Behat gerar os passos do cenário para nós:</p>

<div>
  <pre class="brush: bash">$ vendor/bin/behat --dry-run --append-snippets</pre>
</div>

<p>Precisamos ajustar os passos gerados só um pouco. Só precisamos de quatro passos para cobrir o cenário. O resultado final deve parece com isso:</p>

<div>
  <pre class="brush: php">/**
 * @Given A planilha abaixo com as marcações
 */
public function iHaveTheFollowingTimeEntries(TableNode $table)
{
throw new PendingException();
}

/**
 * @When Na hora de gerar a planilha de tempo
 */
public function iGenerateTheTimeSheet()
{
    throw new PendingException();
}

/**
 * @Then meu tempo total gasto :tarefa deve ser de :duracaoEsperada minutos
 */
public function myTotalTimeSpentOnTaskShouldBeMinutes($tarefa, $duracaoEsperada)
{
    throw new PendingException();
}

/**
 * @Then meu tempo total gasto deve ser de :duracaoEsperada minutos
 */
public function myTotalTimeSpentShouldBeMinutes($duracaoEsperada)
{
    throw new PendingException();
}
</pre>
</div>

<p>Nosso contexto funcional está pronto para usar, mas também precisamos de um contexto para nosso conjunto de integração. Primeiro, adicionaremos o conjunto no arquivo <code>behat.yml</code>:</p>

<div>
  <pre>default:
suites:
        functional:
            contexts: [ FunctionalFeatureContext ]
        integration:
            contexts: [ IntegrationFeatureContext ]
</pre>
</div>

<p>Agora, podemos apenas duplicar o contexto padrão, <code>FeatureContext</code>:</p>

<div>
  <pre class="brush: bash">$ cp features/bootstrap/FeatureContext.php features/bootstrap/IntegrationFeatureContext.php
</pre>
</div>

<p>Lembre-se de renomear a classe para <code>IntegrationFeatureContext</code> e também copiar a declaração <code class="inline">use</code> para a exceção <code>PendingException</code>.</p>

<p>Por fim, como estamos compartilhando essa característica, podemos apenas copiar as quatro definições de passos do contexto funcional. Se executar o Behat, você verá que a característica é executada duas vezes: uma para cada contexto.</p>

<h2>Projetando o Domínio</h2>

<p>Já podemos continuar com os passos pendentes em nosso contexto de integração, para projetar o domínio base de nossa aplicação. O primeiro passo é <code>Given A planilha abaixo com as marcações</code>, seguida pela tabela com os registros dos tempos. Mantendo a simplicidade, iteremos pelos registros da tabela, tentando instanciar um objeto de registro de tempo (<em>TimeEntry</em>), adicionando-os a um vetor com todas as entradas no contexto:</p>

<div>
  <pre class="brush: php">use TimeTracker\TimeEntry;

...

/**
 * @Given A planilha abaixo com as marcações
 */
public function iHaveTheFollowingTimeEntries(TableNode $table)
{
$this-&gt;entries = [];

    $rows = $table-&gt;getHash();

    foreach ($rows as $row) {
        $entry = new TimeEntry;

        $entry-&gt;tarefa  = $row['tarefa'];
        $entry-&gt;duracao = $row['duracao'];

        $this-&gt;entries[] = $entry;
    }
}
</pre>
</div>

<p>Executar o Behat causará um erro fatal, uma vez que a classe <code>TimeTracker\TimeEntry</code> não existe ainda. É aqui que o PhpSpec entra em ação. No final das contas, <code>TimeEntry</code> será uma classe filha do Eloquent, mesmo que não nos preocupemos com ela ainda. O PhpSpec e ORMs como o Eloquent não se dão muito bem juntos, mas podemos usar o PhpSpec para gerar a classe e até especificar algum comportamento básico. Usemos os geradores do PhpSpec para gerar a classe <code>TimeEntry</code>:</p>

<div>
  <pre class="brush: bash">$ vendor/bin/phpspec desc "TimeTracker\TimeEntry"
$ vendor/bin/phpspec run
Do you want me to create `TimeTracker\TimeEntry` for you? y
</pre>
</div>

<p>Após a classe ser gerada, precisamos atualizar a seção de auto carregamento (<em>autoload</em>) do nosso arquivo <code>composer.json</code>:</p>

<div>
  <pre class="brush: javascript">"autoload": {
"classmap": [
        "app/commands",
        "app/controllers",
        "app/models",
        "app/database/migrations",
        "app/database/seeds"
    ],
    "psr-4": {
        "TimeTracker\\": "src/TimeTracker"
    }
},
</pre>
</div>

<p>E, claro, executar o comando <code>composer dump-autoload</code>.</p>

<p>Executando o PhpSpec nos dará tudo verde. Executando o Behat também. Ótimo começo!</p>

<p>Permitindo que o Behat guie nosso caminho, é hora de seeguir para o próximo passo, <code>na hora de gerar a planilha de tempo</code>, certo?</p>

<p>A palavra-chave aqui é "gerar", que parecer ser um termo de nosso domínio. No mundo de um programador, traduzir "gerar planilha de tempo" em código apenas significa instancia a classe <code>TimeSheet</code> com um conjunto de registros de tempo. É importante tentar aderir à linguagem do nosso domínio ao projetar nosso código. Dessa forma, nosso código ajudará a descrever o comportamento intendido da aplicação. </p>

<p>Tomo o temo <code>gerar</code> como importante para o domínio, porque acredito que deveríamos ter um método estático de geração, na classe <code class="inline">TimeSheet</code>, que sirva como uma alternativa para o método construtor. Esse método receberia uma coleção de registros de tempo e os salvaria em uma planilha de tempos. </p>

<p>Ao invés de usar um vetor, acredito que faça mais sentido usar a classe <code>Illuminate\Support\Collection</code> que vem com o Laravel. Uma vez que a classe <code>TimeEntry</code> é um modelo Eloquente, quando consultarmos a base de dados por registros, usaremos uma dessas coleções do Laravel de qualquer jeito. Que tal algo mais ou menos assim:</p>

<div>
  <pre class="brush: php">use Illuminate\Support\Collection;
use TimeTracker\TimeSheet;
use TimeTracker\TimeEntry;

...

/**
 * @When na hora de gerar a planilha de tempo
 */
public function iGenerateTheTimeSheet()
{
$this-&gt;sheet = TimeSheet::generate(Collection::make($this-&gt;entries));
}
</pre>
</div>

<p>Por falar nisso, <code class="inline">TimeSheet</code> <em>não</em> será uma subclasse do Eloquent. Pelo menos, não por agora. Nós só precisamos que os registros de tempo sejam persistidos e a planilha de tempo será <em>gerada</em> a partir desses registros.</p>

<p>Executar o Behat, novamente, causará um erro fatal, porque a classe <code>TimeSheet</code> não existe. O PhpSpec pode nos ajudar com isso:</p>

<div>
  <pre class="brush: bash">$ vendor/bin/phpspec desc "TimeTracker\TimeSheet"
$ vendor/bin/phpspec run
Do you want me to create `TimeTracker\TimeSheet` for you? y
$ vendor/bin/phpspec run

$ vendor/bin/behat

PHP Fatal error:  Call to undefined method TimeTracker\TimeSheet::generate()
</pre>
</div>

<p>Ainda obtemos um erro fatal após criar a classe, porque o método estático <code>generate()</code> ainda não existe. Uma vez que ele é um método bem simples, não creio que precisemos de uma especificação para ele. Ele não passar de um invólucro para o construtor:</p>

<div>
  <pre class="brush: php">&lt;?php

namespace TimeTracker;

use Illuminate\Support\Collection;

class TimeSheet
{
protected $entries;

    public function __construct(Collection $entries)
    {
        $this-&gt;entries = $entries;
    }

    public static function generate(Collection $entries)
    {
        return new static($entries);
    }
}
</pre>
</div>

<p>Isso fará com que o Behat volte a ficar verde, mas, agora, o PhpSpec reclama da gente, dizendo: <code class="inline">Argument 1 passed to TimeTracker\TimeSheet::__construct() must be an instance of Illuminate\Support\Collection, none given</code>. Podemos resolver isso, bastando criar uma função <code>let()</code> simples, que será chamada antes de cada especificação:</p>

<div>
  <pre class="brush: php">&lt;?php

namespace spec\TimeTracker;

use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

use Illuminate\Support\Collection;
use TimeTracker\TimeEntry;

class TimeSheetSpec extends ObjectBehavior
{
function let(Collection $entries)
    {
        $entries-&gt;put(new TimeEntry);

        $this-&gt;beConstructedWith($entries);
    }

    function it_is_initializable()
    {
        $this-&gt;shouldHaveType('TimeTracker\TimeSheet');
    }
}
</pre>
</div>

<p>Isso nos trará de volta ao verde em todos os lugares. A função garante que a planilha de tempo sempre seja construída com um simulacro da classe <code class="inline">Collection</code>.</p>

<p>Podemos continuar, sem problemas, para o passo <code>Then meu tempo total gasto...</code>. Precisamos de um método que receba o nome de uma tarefa e retorne a duração acumulada de todos os registros em que a tarefa tenha aquele nome. Traduzido diretamente do código <em>gherkin</em>, Isso poderia ser algo mais ou menos assim <code>totalTimeSpentOn($task)</code>:</p>

<div>
  <pre class="brush: php">/**
* @Then meu tempo total gasto on :task deve ser de :expectedDuration minutos
*/
public function myTotalTimeSpentOnTaskShouldBeMinutes($task, $expectedDuration)
{
$actualDuration = $this-&gt;sheet-&gt;totalTimeSpentOn($task);

    PHPUnit::assertEquals($expectedDuration, $actualDuration);
}
</pre>
</div>

<p>O método não existe, logo, ao executar o Behat, retornará <code>Call to undefined method TimeTracker\TimeSheet::totalTimeSpentOn()</code>.</p>

<p>Para especificar o método, criaremos uma especificação que se assemelha ao que já temos no cenário:</p>

<div>
  <pre class="brush: php">function it_should_calculate_total_time_spent_on_task()
{
$entry1 = new TimeEntry;
    $entry1-&gt;tarefa = 'dormindo';
    $entry1-&gt;duracao = 120;

    $entry2 = new TimeEntry;
    $entry2-&gt;tarefa = 'comendo';
    $entry2-&gt;duracao = 60;

    $entry3 = new TimeEntry;
    $entry3-&gt;tarefa = 'dormindo';
    $entry3-&gt;duracao = 120;

    $collection = Collection::make([$entry1, $entry2, $entry3]);

    $this-&gt;beConstructedWith($collection);

    $this-&gt;totalTimeSpentOn('dormindo')-&gt;shouldBe(240);
    $this-&gt;totalTimeSpentOn('comendo')-&gt;shouldBe(60);
}
</pre>
</div>

<p>Perceba que não usamos simulacros para as instâncias de <code>TimeEntry</code> e<code>Collection</code>. Esse é o nosso conjunto de integração e não creio que haja necessidade de simular as coisas por aqui. Os objetos são bem simples e queremos ter certeza que os objetos do nosso domínio interagem da forma que esperamos que o façam. Com certeza, há inúmeras opiniões sobre isso, mas é isso o que faz sentido para mim.</p>

<p>Continuando:</p>

<div>
  <pre class="brush: bash">$ vendor/bin/phpspec run
Do you want me to create `TimeTracker\TimeSheet::totalTimeSpentOn()` for you? y

$ vendor/bin/phpspec run

  25  ✘ it should calculate total time spent on task
  expected [integer:240], but got null.
</pre>
</div>

<p>Para filtrar os registros, podemos usar o método <code>filter()</code> da classe <code>Collection</code>. Uma solução simples que nos traz de volta ao verde:</p>

<div>
  <pre class="brush: php">public function totalTimeSpentOn($task)
{
$entries = $this-&gt;entries-&gt;filter(function($entry) use ($task)
    {
        return $entry-&gt;tarefa === $task;
    });

    $duration = 0;

    foreach ($entries as $entry) {
        $duration += $entry-&gt;duracao;
    }

    return $duration;
}
</pre>
</div>

<p>Nossa especificação está verde, mas acredito que nos beneficiaríamos se refatorássemos algo aqui. O método parece realizar duas coisas diferentes: filtragem dos registros e acúmulo da duração. Extraiamos o segundo em seu próprio método:</p>

<div>
  <pre class="brush: php">public function totalTimeSpentOn($task)
{
$entries = $this-&gt;entries-&gt;filter(function($entry) use ($task)
    {
        return $entry-&gt;tarefa === $task;
    });

    return $this-&gt;sumDuration($entries);
}

protected function sumDuration($entries)
{
    $duration = 0;

    foreach ($entries as $entry) {
        $duration += $entry-&gt;duracao;
    }

    return $duration;
}
</pre>
</div>

<p>O PhpSpec continua verde e agora temos três passos verdes no Behat. O último passo deve ser de fácil implementação, já que é bem parecido com o que acabamos de fazer.</p>

<div>
  <pre class="brush: php">/**
 * @Then meu tempo total gasto deve ser de :expectedDuration minutos
 */
public function myTotalTimeSpentShouldBeMinutes($expectedDuration)
{
$actualDuration = $this-&gt;sheet-&gt;totalTimeSpent();

    PHPUnit::assertEquals($expectedDuration, $actualDuration);
}
</pre>
</div>

<p>Executando o Behat teremos <code>Call to undefined method TimeTracker\TimeSheet::totalTimeSpent()</code>. Ao invés de criar um exemplo separado em nossa especificação para esse método, que tal apenas adicioná-lo à que já temos? Pode não ser bem a forma "correta" de se fazer as coisas, mas sejamos um pouco pragmáticos:</p>

<div>
  <pre class="brush: php">...

$this-&gt;beConstructedWith($collection);

$this-&gt;totalTimeSpentOn('dormindo')-&gt;shouldBe(240);
$this-&gt;totalTimeSpentOn('comendo')-&gt;shouldBe(60);
$this-&gt;totalTimeSpent()-&gt;shouldBe(300);
</pre>
</div>

<p>Deixemos o PhpSpec gerar o método:</p>

<div>
  <pre class="brush: bash">$ vendor/bin/phpspec run
Do you want me to create `TimeTracker\TimeSheet::totalTimeSpent()` for you? y

$ vendor/bin/phpspec run

  25  ✘ it should calculate total time spent on task
  expected [integer:300], but got null.
</pre>
</div>

<p>Conseguir ficar verde é fácil, agora que temos o método <code>sumDuration()</code>:</p>

<div>
  <pre class="brush: php">public function totalTimeSpent()
{
return $this-&gt;sumDuration($this-&gt;entries);
}
</pre>
</div>

<p>E, agora, temos uma característica toda verde. Nosso domínio está evoluindo um pouco!</p>

<h2>Projetando a Interface do Usuário</h2>

<p>Agora, iremos para o conjunto de testes funcional. Projetaremos a interface do usuário para lidar com todas as coisas específicas do Laravel que não problema do nosso domínio.</p>

<p>Ao trabalha no conjunto funcional, podemos adicionar o semáforo <code>-s</code> para instruir o Behat a executar nossas características apenas pelo <code>FunctionalFeatureContext</code>:</p>

<div>
  <pre class="brush: bash">$ vendor/bin/behat -s functional
</pre>
</div>

<p>O primeiro passo será parecido com o primeiro do contexto de integração. Ao invés de apenas persistir os registros do contexto em um vetor, precisamos fazer com eles sejam persistidos numa base de dados para que sejam obtidos futuramente:</p>

<div>
  <pre class="brush: php">use TimeTracker\TimeEntry;

...

/**
 * @Given A planilha abaixo com as marcações
 */
public function iHaveTheFollowingTimeEntries(TableNode $table)
{
$rows = $table-&gt;getHash();

    foreach ($rows as $row) {
        $entry = new TimeEntry;

        $entry-&gt;tarefa  = $row['tarefa'];
        $entry-&gt;duracao = $row['duracao'];

        $entry-&gt;save();
    }
}
</pre>
</div>

<p>Executar o Behat trará um erro fatal <code>Call to undefined method TimeTracker\TimeEntry::save()</code>, uma vez que a classe <code>TimeEntry</code> ainda não é um modelo do Eloquent. Isso é fácil de corrigir:</p>

<div>
  <pre class="brush: php">namespace TimeTracker;

class TimeEntry extends \Eloquent
{
}
</pre>
</div>

<p>Se executarmos o Behat novamente, o Laravel reclamará, informando que não pode conectar-se à base de dados. Podemos corrigir isso, adicionando um arquivo <code>database.php</code> no diretório <code>app/config/testing</code>, para popular os detalhes da conexão para nossa base de dados. Para projetos maiores, provavelmente, quererá usar algum servidor de base de dados para seus códigos de testes e de produção, mas, em nosso caso, usaremos uma base de dados em memória com o SQLite. Isso é bem simples de configurar, usando o Laravel:</p>

<div>
  <pre class="brush: php">&lt;?php

return array(

'default' =&gt; 'sqlite',

    'connections' =&gt; array(

        'sqlite' =&gt; array(
            'driver'   =&gt; 'sqlite',
            'database' =&gt; ':memory:',
            'prefix'   =&gt; '',
        ),

    ),

);
</pre>
</div>

<p>Agora, se executarmos o Behat, ele informará que não existe a tabela <code>time_entries</code>. Para corrigir isso, precisamos criar uma migração:</p>

<div>
  <pre class="brush: bash">$ php artisan migrate:make createTimeEntriesTable --create="time_entries"
</pre>
</div>

<div>
  <pre class="brush: php">Schema::create('time_entries', function(Blueprint $table)
{
$table-&gt;increments('id');
    $table-&gt;string('tarefa');
    $table-&gt;integer('duracao');
    $table-&gt;timestamps();
});
</pre>
</div>

<p>Ainda não estamos verdes, uma vez que precisamos de uma forma para instruir o Behat para executar nossas migrações antes de cada cenário, para que tenhamos um ambiente recém construído todas as vezes. Ao usar as anotações do Behat, podemos adicionar esses dois métodos ao <em>trait</em> <code>LaravelTrait</code>:</p>

<div>
  <pre class="brush: php">/**
 * @BeforeScenario
 */
public function setupDatabase()
{
$this-&gt;app['artisan']-&gt;call('migrate');
}

/**
 * @AfterScenario
 */
public function cleanDatabase()
{
    $this-&gt;app['artisan']-&gt;call('migrate:reset');
}
</pre>
</div>

<p>Isso é bem legal e é o nosso primeiro passo em direção ao verde.</p>

<p>Agora, é a vez do passo <code>When na hora de gerar a planilha de tempo</code>. A geração da planilha de tempo é o equivalente a visitar a ação <code>index</code> do recurso de registro de tempo, uma vez que a planilha de tempo é uma coleção de todos os registros de tempo. Assim, o objeto da planilha de tempo é como um recipiente para todos os registros de tempo e nos fornece uma forma fácil de manipular os registros. Ao invés de acessar <code class="inline">/time-entries</code> para ver a planilha, acredito que o empregado deveria acessar <code>/time-sheet</code>. Devemos colocar isso na definição do nosso passo:</p>

<div>
  <pre class="brush: php">/**
 * @When na hora de gerar a planilha de tempo
 */
public function iGenerateTheTimeSheet()
{
$this-&gt;call('GET', '/time-sheet');

    $this-&gt;crawler = new Crawler($this-&gt;client-&gt;getResponse()-&gt;getContent(), url('/'));
}
</pre>
</div>

<p>Isso trará uma exceção do tipo <code>NotFoundHttpException</code>, uma vez que a rota ainda não está definida. Como acabei de explicar, acredito que essa URL deve ser mapeada para a ação <code>index</code> do recurso dos registros de tempo:</p>

<div>
  <pre class="brush: php">Route::get('time-sheet', ['as' =&gt; 'time_sheet', 'uses' =&gt; 'TimeEntriesController@index']);
</pre>
</div>

<p>Para obtermos o verde, precisamos gerar o controlador:</p>

<div>
  <pre class="brush: bash">$ php artisan controller:make TimeEntriesController
$ composer dump-autoload
</pre>
</div>

<p>E, criamos.</p>

<p>Finalmente, precisamos rastrear a página para encontrar a duração total de cada registro de tempo. Sei que teremos uma espécie de tabela que resumirá as durações. Os dois últimos passos são tão semelhantes que os implementaremos ao mesmo tempo:</p>

<div>
  <pre class="brush: php">/**
 * @Then meu tempo total gasto on :tarefa deve ser de :expectedDuration minutos
 */
public function myTotalTimeSpentOnTaskShouldBeMinutes($tarefa, $expectedDuration)
{
$actualDuration = $this-&gt;crawler-&gt;filter('td#' . $tarefa . 'TotalDuration')-&gt;text();

    PHPUnit::assertEquals($expectedDuration, $actualDuration);
}

/**
 * @Then meu tempo total gasto deve ser de :expectedDuration minutos
 */
public function myTotalTimeSpentShouldBeMinutes($expectedDuration)
{
    $actualDuration = $this-&gt;crawler-&gt;filter('td#totalDuration')-&gt;text();

    PHPUnit::assertEquals($expectedDuration, $actualDuration);
}
</pre>
</div>

<p>O rastreador procurará por um node <code>&lt;td&gt;</code> com um identificador <code>[nome_da_tarefa]TotalDuration</code>ou <code>totalDuration</code> no último exemplo.</p>

<p>Como ainda não temos uma visão, o rastreador dirá <code>The current node list is empty.</code> (A lista de nodos atual está vazia)</p>

<p>Para corrigir isso, criemos a ação <code>index</code>. Primeiro, buscaremos a coleção dos registros de tempo. Segundo, geraremos uma planilha de tempo a partir dos registros e enviaremos para uma visão (ainda inexistente).</p>

<div>
  <pre class="brush: php">use TimeTracker\TimeSheet;
use TimeTracker\TimeEntry;

class TimeEntriesController extends \BaseController {

/**
     * Apresenta uma listagem do recurso.
     *
     * @return Response
     */
    public function index()
    {
        $entries = TimeEntry::all();
        $sheet = TimeSheet::generate($entries);

        return View::make('time_entries.index', compact('sheet'));
    }

...

</pre>
</div>

<p>A visão, por hora, consistirá apenas de uma tabela simples, com o resumo dos valores das durações:</p>

<div>
  <pre class="brush: php">&lt;h2&gt;Planilha de tempo&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
        &lt;th&gt;Tarefa&lt;/th&gt;
        &lt;th&gt;Duração Total&lt;/th&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;coding&lt;/td&gt;
            &lt;td id="programandoTotalDuration"&gt;{{ $sheet-&gt;totalTimeSpentOn('programando') }}&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;documentado&lt;/td&gt;
            &lt;td id="documentadoTotalDuration"&gt;{{ $sheet-&gt;totalTimeSpentOn('documentado') }}&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;reunioes&lt;/td&gt;
            &lt;td id="reunioesTotalDuration"&gt;{{ $sheet-&gt;totalTimeSpentOn('reunioes') }}&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;&lt;strong&gt;Total&lt;/strong&gt;&lt;/td&gt;
            &lt;td id="totalDuration"&gt;{{ $sheet-&gt;totalTimeSpent() }}&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;
</pre>
</div>

<p>Se executar o Behat novamente, verá que fomos bem sucedidos na implementação da característica. Talvez devêssemos para um momento para perceber que, em momento algum, abrimos o navegador! Isso é um aprimoramento absurdo em nosso fluxo de trabalho e, como um bônus, temos testes automatizados para nossa aplicação. YEAH!</p>

<h2><a name="user-content-conclusion" href="https://github.com/petersuhm/writings/blob/master/laravel-bdd-second-article.md#conclusion"/>Conclusão</a></h2>

<p>Se executar <code>vendor/bin/behat</code> para rodar ambas os conjuntos de testes do Behat, você verá que ambos estão verdes, agora. Se executar o PhpSpec, infelizmente, verá que nossas especificações falharam. Obtemos um erro fatal <code>Class 'Eloquent' not found in ...</code>. Isso se dá porque <em>Eloquent</em> é um apelido. Se você olhar no arquivo <code>app/config/app.php</code> na chave <code class="inline">aliases</code>, você verá que <code>Eloquent</code> é, na verdade, um apelido para <code>Illuminate\Database\Eloquent\Model</code>. Para fazer com que o PhpSpec torne ao verde, devemos importar essa classe:</p>

<div>
  <pre class="brush: php">namespace TimeTracker;

use Illuminate\Database\Eloquent\Model as Eloquent;

class TimeEntry extends Eloquent
{
}
</pre>
</div>

<p>Se executar esses dois comandos:</p>

<div>
  <pre class="brush: bash">$ vendor/bin/phpspec run; vendor/bin/behat
</pre>
</div>

<p>Você verá que todos os testes estão verdes, tanto os do Behat quanto os do PhpSpec. Que beleza! </p>

<p>Nós descrevemos e projetamos nossa primeira funcionalidade, usando a abordagem do BDD. Vimos como podemos nos beneficiar do projeto do domínio base da nossa aplicação, antes de preocuparmo-nos com interface do usuário e coisas específicas de <em>framework</em>. Também vimos o quão fácil é interagir com o Laravel e, especialmente, a base de dados, nos contextos do Behat. </p>

<p>No próximo artigo, realizaremos várias refatorações para evitar muita lógica em nossos modelos <em>Eloquent</em>, uma vez que eles são mais difíceis de testar isoladamente e estão bastante acoplados ao Laravel. Fique ligado!</p>