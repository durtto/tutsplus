<h1>Testando Controladores no Laravel</h1>

<p>Testar controladores não é das tarefas mais fáceis. Bem, deixe-me reformular essa frase: Testar controladores é fácil, o problema, pelo menos inicialmente, é <em>o que se deve</em> testar</p>

<p>Um teste de controlador deve verificar textos em uma página? Ele deveria comunicar-se com a base de dados? Deve garantir que certas variáveis existem nas visões? Se essa é sua primeira vez com testes, todos esses pontos podem ser bem confusos! Deixe-me ajudá-lo.</p>


<blockquote>
<p>Testes de controladores devem verificar respostas enviadas; garantir que a chamada aos corretos métodos de acesso às bases de dados; e confirmar que as variáveis de instância corretas foram enviadas para a visão.</p>
</blockquote>

<p>O processo de testar um controlador pode ser dividido em três partes:</p>

<ul><li><strong>Isolamento:</strong> Simule todas as dependências (exceto, talvez a classe <code>View</code>).</li>
<li><strong>Chamada:</strong> Chame o método desejado do controlador.</li>
<li><strong>Garantia:</strong> Execute as declarações de teste, verificando se tudo foi feito corretamente.</li>
</ul>

<h2>O "Hello World" dos Testes de Controladores</h2>

<p>A melhor maneira de aprender algo é através de exemplos. Eis o equivalente a um "<em>hello world</em>" para testes de controladores no Laravel.</p>

<pre class="brush: php">
&lt;?php

# app/tests/controllers/PostsControllerTest.php

class PostsControllerTest extends TestCase {

public function testIndex()
{
    $this-&gt;client-&gt;request('GET', 'posts');
}

}</pre>

<p>O Laravel lança mão de vários componentes do Symfony para facilitar o processo de testar rotas e visões, incluindo o HttpKernel, DomCrawler e BrowserKit. É por isso que é importante seus testes com PHPUnit estendam a classe <code>TestCase</code>, não a classe <code>PHPUnit\_Framework\_TestCase</code>. Não se preocupe, a classe que o Laravel provê estende a classe original do PHPUnit. Além disso, ajuda a preparar sua aplicação em Laravel para os testes, além de prover uma variedade de métodos que auxiliarão em seus testes e que seria bom você utilizá-los. Nós falaremos mais sobre eles daqui a pouco.</p>

<p>No trecho de código acima, nós fazemos uma requisição <code>GET</code> para posts <code>/posts</code> ou <code>localhost:8000/posts</code>. Assumindo que esse código é adicionado a uma instalação recém criada do Laravel, o Symfony lançará uma exceção do tipo <code>NotFoundHttpException</code>. Se estiver codificando junto, vá até a linha de comando e execute o comando <code>phpunit</code>.</p>

<pre class="brush: bash">
$ phpunit
1) PostsControllerTest::testIndex
Symfony\Component\HttpKernel\Exception\NotFoundHttpException:</pre>

<p>Traduzindo para algo que <em>humanos</em> entendam, isso, essencialmente, está dizendo: "<em>Ei, tentei chamar aquela rota, mas você não registro algo, ainda, bobo!</em>"</p>

<p>Como pode imaginar, esse tipo de requisição é tão comum, que faz sentido ter um método auxiliar. Algo como <code>$this-&gt;call()</code>. Para falar a verdade, o Laravel faz isso! Isso significa que o exemplo anterior pode ser refatorado, dessa forma:</p>

<pre class="brush: php">
#app/tests/controllers/PostsControllerTest.php

public function testIndex()
{
  $this-&gt;call('GET', 'posts');
}</pre>

<h3>A Sobrecarga é sua Amiga</h3>

<p>Embora nós iremos nos ater à funcionalidade básica nesse capítulo, em meus projetos pessoais, vou além e permito a existência de métodos como <code>$this-&gt;get()</code>, <code>$this-&gt;post()</code>, etc. Graças à sobrecarga do PHP, isso só requer a adição de um único método, o qual você pode adicionar a <code>app/tests/TestCase.php</code>.</p>

<pre class="brush: php">
# app/tests/TestCase.php

public function __call($method, $args)
{
  if (in_array($method, ['get', 'post', 'put', 'patch', 'delete']))
  {
      return $this-&gt;call($method, $args[0]);
  }

  throw new BadMethodCallException;
}</pre>

<p>Agora, você já pode escrever algo como <code>$this-&gt;get('posts')</code> e obter o mesmo resultado dos dois exemplos anteriores. Mas, como disse, vamos continuar só com as funcionalidades básicas da framework, para não complicar as coisas.</p>

<p>Para fazer o teste passar, só precisamos criar a rota apropriada.</p>

<pre class="brush: php">
&lt;?php

# app/routes.php

Route::get('posts', function()
{
  return 'todos os posts';
});</pre>

<p>Executar, novamente, <code>phpunit</code> fará com que voltemos ao estado verde.</p>

<h2>As Declarações Auxiliares do Laravel</h2>

<p>Um teste que você criará bastante, é aquele que garante que o controlador passou uma variável em particular para a visão. Por exemplo, o método <code>index</code> de <code>PostsController</code> deve passar uma variável <code>$posts</code> à sua visão correspondente, certo? Dessa forma, a visão pode percorrer por todos os posts e mostrá-los na página. Esse é um teste importante de se escrever!</p>

<p>E, se isso é tão comum, mais uma vez, não faria sentido o Laravel provê declarações auxiliares para que possamos realizar essa tarefa? Claro que faria. E, claro, o Laravel provê!</p>

<p>A classe <code>Illuminate\Foundation\Testing\TestCase</code> inclui uma série de métodos que reduzem, drasticamente, a quantidade de código necessária para realizar essas declarações de testes, básicas. A lista inclui:</p>

<ul>
<li><code>assertViewHas</code></li>
<li><code>assertResponseOk</code></li>
<li><code>assertRedirectedTo</code></li>
<li><code>assertRedirectedToRoute</code></li>
<li><code>assertRedirectedToAction</code></li>
<li><code>assertSessionHas</code></li>
<li><code>assertSessionHasErrors</code></li>
</ul><p>O exemplo a seguir fazem uma requisição <code>GET /posts</code> e verificam se a visão recebe a variável <code>$posts</code>.</p>

<pre class="brush: php">
# app/tests/controllers/PostsControllerTest.php

public function testIndex()
{
  $this-&gt;call('GET', 'posts');

  $this-&gt;assertViewHas('posts');
}</pre>

<blockquote>
<p><strong>Dica:</strong> Quando se trata de formatação dos testes, prefiro adicionar uma linha em branco entre a declaração do teste e o código que prepara o ambiente para o teste.</p>
</blockquote>

<p><code>assertViewHas</code> é uma espécie de "açúcar sintático" (atalho, se preferi) que inspeciona o objeto resposta - o retorno da chamada a <code>$this-&gt;call()</code> - e verifica se os dados associados à visão contem a variável <code>posts</code>.</p>

<p>Quando estiver inspecionando o objeto resposta, você tem duas alternativas.</p>

<ul>
<li><code>$response-&gt;getOriginalContent()</code>: Busca o conteúdo original ou a <code>View</code> retornada. Opcionalmente, você pode acessar a propriedade <code>original</code> diretamente, ao invés de chamar o método <code>getOriginalContent</code>.</li>
<li><code>$response-&gt;getContent()</code>: Busca o resultado renderizado. Se uma instância de <code>View</code> é retornada de uma rota, então <code>getContent()</code> será igual ao HTML resultante. Isso pode ser útil em verificações em relação a DOM, como: "<em>a visão deve conter essa string.</em>"</li>
</ul>

<p>Assumamos que a rota <code>posts</code> seja da seguinte forma:</p>

<pre class="brush: php">
&lt;?php

# app/routes.php

Route::get('posts', function()
{
  return View::make('posts.index');
});</pre>

<p>Se executarmos o <code>phpunit</code>, ele reclamará e apontará o que devemos fazer:</p>

<pre class="brush: bash">
1) PostsControllerTest::testIndex
Failed asserting that an array has the key 'posts'.</pre>

<p>O <code>phpunit</code> apontou que não conseguiu encontrar qualquer variável chamada 'posts'. Para fazer com que o teste fique verde, temos que buscar os posts e enviá-los para a visão.</p>

<pre class="brush: php">

# app/routes.php

Route::get('posts', function()
{
  $posts = Post::all();

  return View::make('posts.index', ['posts', $posts]);
});</pre>

<p>Uma coisa a se ter em mente é que, com o código que temos até agora, a única garantia que temos é que uma variável <code>$posts</code> é enviada para a visão. Ele não inspeciona o valor dessa variável. O método de teste <code>assertViewHas</code>, opcionalmente, aceita um segundo parâmetro contendo o valro esperado da variável, para, assim como atestar a existência da variável, poder verificar o valor dela.</p>

<pre class="brush: php">

# app/tests/controllers/PostsControllerTest.php

public function testIndex()
{
  $this-&gt;call('GET', 'posts');

  $this-&gt;assertViewHas('posts', 'foo');
}</pre>

<p>Com essa modificação no código, a menos que a variável tenha uma variável <code>$posts</code> com valor igual a <code>foo</code>, o teste falhará. Nessa situação, porém, é melhor não especificarmos um valor em si, mas declararmos que o valor será uma instância da classe <code>Illuminate\Database\Eloquent\Collection</code> do Laravel. Como podemos fazer isso? O PHPUnit nos fornece um método útil, chamado <code>assertInstanceOf</code>.</p>

<pre class="brush: php">

# app/tests/controllers/PostsControllerTest.php

public function testIndex()
{
  $response = $this-&gt;call('GET', 'posts');

  $this-&gt;assertViewHas('posts');

  // getData() retorna todas as variáveis associadas à resposta.
  $posts = $response-&gt;original-&gt;getData()['posts'];

  $this-&gt;assertInstanceOf('Illuminate\Database\Eloquent\Collection', $posts);
}</pre>

<p>Com essa modificação, declaramos que o controlador <strong>deve</strong> enviar a variável <code>$posts</code> - uma instância da classe <code>Illuminate\Database\Eloquent\Collection</code> - para a visão. Excelente.</p>

<h2>Simulando a Base de Dados</h2>

<p>Há um problema bastante evidente com os nossos testes, até agora. Você percebeu?</p>

<blockquote>
<p>Para cada teste, uma consulta SQL tem sido executada e acessado a base de dados. Embora isso seja útil em alguns tipos de testes (testes de aceitação e integração), para testes básicos dos controladores, isso só servirá para diminuir a performance.</p>
</blockquote>

<p>Eu já devo ter encravado isso no seu cérebro de tanto falar (nota: esse texto faz parte do livro <em>Laravel Testing Decoded</em>, do próprio Jeffrey Way). Não estamos interessados em testar as capacidades do Eloquente em buscar os registros da base de dados. Ele tem seus próprios testes. Taylor (Otwell, criador da framework) sabe que ele funciona! Não percamos tempo nem poder de processamento repetindo todos esses testes.</p>

<p>Ao invés disso, é melhor simular a base de dados e verificar se os métodos apropriados são chamados com seus respectivos argumentos necessários. Ou, em outras palavras, nós queremos garantir que a chamada <code>Post::all()</code> nunca seja disparada de verdade nem acessa a base de dados. Nós sabemos que ela funciona, logo não precisa de testes.</p>

<p>Essa seção dependerá bastante da biblioteca Mockery. Por favor, revise esse capítulo do <a href="http://leanpub.com/laravel-testing-decoded">meu livro</a>, se você ainda não a conhece.</p>

<h3>Refatoração Necessária</h3>

<p>Infelizmente, até agora, nós estruturamos nosso código de uma forma que, virtualmente, é impossível de testar.</p>

<pre class="brush: php">
# app/routes.php

Route::get('posts', function()
{
  // Oh, não! Não podemos testar isso!!
  $posts = Post::all();

  return View::make('posts.index')
      -&gt;with('posts', $posts);
});</pre>

<p>É, exatamente, por isso que é considerado má prática inserir chamadas ao Eloquent em seus controladores. Não confunda com as <em>facade</em> do Laravel, que são testáveis e podem ser substituídas por simulacros (<code>Queue::shouldReceive()</code>), com seus modelos Eloquent. A solução é injetar a camada da base de dados no controlador através do método construtor. Isso requer refatoração.</p>

<blockquote>
<p><strong>Atenção:</strong> Manter a lógica de um projeto dentro das rotas é útil qual ele é pequeno ou quando se quer criar uma API, mas isso torna a testabilidade do projeto incrivelmente difícil. Para aplicações de tamanhos consideráveis, use controladores.</p>
</blockquote>

<p>Registremos um novo recurso, substituindo a rota <code>posts</code> com:</p>

<pre class="brush: php">
# app/routes.php

Route::resource('posts', 'PostsController');</pre>

<p>...e criemos o controlador inteligente utilizando o Artisan.</p>

<pre class="brush: bash">
$ php artisan controller:make PostsController
Controller created successfully!</pre>

<p>Now, rather than referencing the <code>Post</code> model directly, we'll inject it into the controller's constructor. Here's a condensed example that omits all restful methods except the one that we're currently interested in testing.</p>

<pre class="brush: php">
&lt;?php

# app/controllers/PostsController.php

class PostsController extends BaseController {

protected $post;

public function __construct(Post $post)
{
    $this-&gt;post = $post;
}

public function index()
{
    $posts = $this-&gt;post-&gt;all();

    return View::make('posts.index')
        -&gt;with('posts', $posts);
}

}</pre>

<blockquote>
<p>Please note that it's a better idea to typehint an interface, rather than reference the Eloquent model, itself. But, one thing at a time! Let's work up to that.</p>
</blockquote>

<p>This is a significantly better way to structure the code. Because the model is now injected, we have the ability to swap it out with a mocked version for testing. Here's an example of doing just that:</p>

<pre class="brush: php">
&lt;?php

# app/tests/controllers/PostsControllerTest.php

class PostsControllerTest extends TestCase {

public function __construct()
{
    // We have no interest in testing Eloquent
    $this-&gt;mock = Mockery::mock('Eloquent', 'Post');
}

public function tearDown()
{
    Mockery::close();
}

public function testIndex()
{
    $this-&gt;mock
         -&gt;shouldReceive('all')
         -&gt;once()
         -&gt;andReturn('foo');

    $this-&gt;app-&gt;instance('Post', $this-&gt;mock);

    $this-&gt;call('GET', 'posts');

    $this-&gt;assertViewHas('posts');
}

}</pre>

<p>The key benfit to this restructuring is that, now, the database will never needlessly be hit. Instead, using Mockery, we merely verify that the <code>all</code> method is triggered on the model.</p>

<pre class="brush: php">
$this-&gt;mock
  -&gt;shouldReceive('all')
  -&gt;once();</pre>

<p>Unfortunately, if you choose to forego coding to an interface, and instead inject the <code>Post</code> model into the controller, a bit of trickery has to be used in order to get around Eloquent's use of statics, which can clash with Mockery. This is why we hijack both the <code>Post</code> and <code>Eloquent</code> classes within the test's constructor, before the official versions have been loaded. This way, we have a clean slate to declare any expectations. The downside, of course, is that we can't default to any existing methods, through the use of Mockery methods, like <code>makePartial()</code>.</p>

<h3>The IoC Container</h3>

<p>Laravel's IoC container drastically eases the process of injecting dependencies into your classes. Each time a controller is requested, it is resolved out of the IoC container. As such, when we need to declare that a mock version of <code>Post</code> should be used for testing, we only need to provide Laravel with the instance of <code>Post</code> that should be used.</p>

<pre class="brush: php">
$this-&gt;app-&gt;instance('Post', $this-&gt;mock);</pre>

<blockquote>
<p>Think of this code as saying, "<em>Hey Laravel, when you need an instance of <code>Post</code>, I want you to use my mocked version.</em>" Because the app extends the <code>Container</code>, we have access to all IoC methods directly off of it.</p>
</blockquote>

<p>Upon instantiation of the controller, Laravel leverages the power of PHP reflection to read the typehint and inject the dependency for you. That's right; you don't have to write a single binding to allow for this; it's automated!</p>

<h2>Redirections</h2>

<p>Another common expectation that you'll find yourself writing is one that ensures that the user is redirected to the proper location, perhaps upon adding a new post to the database. How might we accomplish this?</p>

<pre class="brush: php">
# app/tests/controllers/PostsControllerTest.php

public function testStore()
{
  $this-&gt;mock
       -&gt;shouldReceive('create')
       -&gt;once();

  $this-&gt;app-&gt;instance('Post', $this-&gt;mock);

  $this-&gt;call('POST', 'posts');

  $this-&gt;assertRedirectedToRoute('posts.index');

}</pre>

<p>Assuming that we're following a restful flavor, to add a new post, we'd <code>POST</code> to the collection, or <code>posts</code> (don't confuse the <code>POST</code> request method with the resource name, which just happens to have the same name).</p>

<pre class="brush: php">
$this-&gt;call('POST', 'posts');</pre>

<p>Then, we only need to leverage another of Laravel's helper assertions, <code>assertRedirectedToRoute</code>.</p>

<blockquote>
<p><strong>Tip:</strong> When a resource is registered with Laravel (<code>Route::resource()</code>), the framework will automatically register the necessary named routes. Run <code>php artisan routes</code> if you ever forget what these names are.</p>
</blockquote>

<p>You might prefer to also ensure that the <code>$_POST</code> superglobal is passed to the <code>create</code> method. Even though we aren't physically submitting a form, we can still allow for this, via the <code>Input::replace()</code> method, which allows us to "stub" this array. Here's the modified test, which uses Mockery's <code>with()</code> method to verify the arguments passed to the method referenced by <code>shouldReceive</code>.</p>

<pre class="brush: php">
# app/tests/controllers/PostsControllerTest.php

public function testStore()
{
  Input::replace($input = ['title' =&gt; 'My Title']);&lt;/p&gt;

  $this-&gt;mock
       -&gt;shouldReceive('create')
       -&gt;once()
       -&gt;with($input);

  $this-&gt;app-&gt;instance('Post', $this-&gt;mock);

  $this-&gt;call('POST', 'posts');

  $this-&gt;assertRedirectedToRoute('posts.index');
}</pre>

<h2>Paths</h2>

<p>One thing that we haven't considered in this test is validation. There should be two separate paths through the <code>store</code> method, dependent upon whether the validation passes:</p>

<ol>
<li>Redirect back to the "Create Post" form, and display the form validation errors.<br /></li>
<li>Redirect to the collection, or the named route, <code>posts.index</code>.<br /></li>
</ol>

<blockquote>
<p>As a best practice, each test should represent but one path through your code.</p>
</blockquote>

<p>This first path will be for failed validation.</p>

<pre class="brush: php">
# app/tests/controllers/PostsControllerTest.php

public function testStoreFails()
{
  // Set stage for a failed validation
  Input::replace(['title' =&gt; '']);

  $this-&gt;app-&gt;instance('Post', $this-&gt;mock);

  $this-&gt;call('POST', 'posts');

  // Failed validation should reload the create form
  $this-&gt;assertRedirectedToRoute('posts.create');

  // The errors should be sent to the view
  $this-&gt;assertSessionHasErrors(['title']);
}</pre>

<p>The code snippet above explicitly declares which errors should exist. Alternatively, you may omit the argument to <code>assertSessionHasErrors</code>, in which case it will merely verify that a message bag has been flashed (in translation, your Redirection includes <code>withErrors($errors)</code>).</p>

<p>Now for the test that handles successful validation.</p>

<pre class="brush: php">
# app/tests/controllers/PostsControllerTest.php

public function testStoreSuccess()
{
  // Set stage for successful validation
  Input::replace(['title' =&gt; 'Foo Title']);&lt;/p&gt;

  $this-&gt;mock
       -&gt;shouldReceive('create')
       -&gt;once();

  $this-&gt;app-&gt;instance('Post', $this-&gt;mock);

  $this-&gt;call('POST', 'posts');

  // Should redirect to collection, with a success flash message
  $this-&gt;assertRedirectedToRoute('posts.index', ['flash']);
}</pre>

<p>The production code for these two tests might look like:</p>

<pre class="brush: php">
# app/controllers/PostsController.php

public function store()
{
  $input = Input::all();

  // We'll run validation in the controller for convenience
  // You should export this to the model, or a service
  $v = Validator::make($input, ['title' =&gt; 'required']);

  if ($v-&gt;fails())
  {
      return Redirect::route('posts.create')
          -&gt;withInput()
          -&gt;withErrors($v-&gt;messages());
  }

  $this-&gt;post-&gt;create($input);

  return Redirect::route('posts.index')
      -&gt;with('flash', 'Your post has been created!');
}</pre>

<p>Notice how the <code>Validator</code> is nested directly in the controller? Generally, I'd recommend that you abstract this away to a service. That way, you can test your validation in isolation from any controllers or  routes. Nonetheless, let's leave things as they are for simplicity's sake. One thing to keep in mind is that we aren't mocking the <code>Validator</code>, though you certainly could do so. Because this class is a facade, it can easily be swapped out with a mocked version, via the Facade's <code>shouldReceive</code> method, without us needing to worry about injecting an instance through the constructor. Win!</p>

<pre class="brush: php">
# app/controllers/PostsController.php

Validator::shouldReceive('make')
  -&gt;once()
  -&gt;andReturn(Mockery::mock(['fails' =&gt; 'true']));</pre>

<p>From time to time, you'll find that a method that needs to be mocked should return an object, itself. Luckily, with Mockery, this is a piece of cake: we only need to create an anonymous mock, and pass an array, which signals the method name and response value, respectively. As such:</p>

<pre class="brush: php">
Mockery::mock(['fails' =&gt; 'true'])</pre>

<p>will prepare an object, containing a <code>fails()</code> method that returns <code>true</code>.</p>

<h2>Repositories</h2>

<p>To allow for optimal flexibility, rather than creating a direct link between your controller and an ORM, like Eloquent, it's better to code to an interface. The considerable advantage to this approach is that, should you perhaps need to swap out Eloquent for, say, Mongo or Redis, doing so literally requires the modification of a single line. Even better, the controller doesn't ever need to be touched.</p>

<blockquote>
<p>Repositories represent the data access layer of your application.</p>
</blockquote>

<p>What might an interface for managing the database layer of a <code>Post</code> look like? This should get you started.</p>

<pre class="brush: php">
&lt;?php

# app/repositories/PostRepositoryInterface.php

interface PostRepositoryInterface {

  public function all();

  public function find($id);

  public function create($input);

}</pre>

<p>This can certainly be extended, but we've added the bare minimum methods for the demo: <code>all</code>, <code>find</code>, and <code>create</code>. Notice that the repository interfaces are being stored within <code>app/repositories</code>. Because this folder is not autoloaded by default, we need to update the <code>composer.json</code> file for the application to reference it.</p>

<pre class="brush: js">
// composer.json

"autoload": {
"classmap": [
  // ....
  "app/repositories"
]
}</pre>

<blockquote>
<p>When a new class is added to this directory, don't forget to <code>composer dump-autoload -o</code>. The <code>-o</code>, (<em>optimize</em>) flag is optional, but should always be used, as a best practice.</p>
</blockquote>

<p>If you attempt to inject this interface into your controller, Laravel will snap at you. Go ahead; try it out and see. Here's the modified <code>PostController</code>, which has been updated to inject an interface, rather than the <code>Post</code> Eloquent model.</p>

<pre class="brush: php">
&lt;?php

# app/controllers/PostsController.php

use Repositories\PostRepositoryInterface as Post;

class PostsController extends BaseController {

  protected $post;

  public function __construct(Post $post)
  {
      $this-&gt;post = $post;
  }

  public function index()
  {
      $posts = $this-&gt;post-&gt;all();

      return View::make('posts.index', ['posts' =&gt; $posts]);
  }

}</pre>

<p>If you run the server and view the output, you'll be met with the dreaded (but beautiful) Whoops error page, declaring that "<em>PostRepositoryInterface is not instantiable.</em>"</p>

<figure class="tutorial_image"><img src="http://cdn.tutsplus.com/net/uploads/2013/04/instantiable.jpg" data-original-url="http://cdn.tutsplus.com/net.tutsplus.com/uploads/2013/04/instantiable.jpg" alt="Not Instantiable" /><br /></figure>

<p>If you think about it, of course the framework is squawking! Laravel is smart, but it's not a mind reader. It needs to be told which implementation of the interface should be used within the controller.</p>

<p>For now, let's add this binding to <code>app/routes.php</code>. Later, we'll instead make use of service providers to store this sort of logic.</p>

<pre class="brush: php">
# app/routes.php

App::bind(
  'Repositories\PostRepositoryInterface',
  'Repositories\EloquentPostRepository'
);</pre>

<p>Verbalize this function call as, "<em>Laravel, baby, when you need an instance of <code>PostRepositoryInterface</code>, I want you to use <code>EloquentPostRepository</code>.</em>"</p>

<p><code>app/repositories/EloquentPostRepository</code> will simply be a wrapper around Eloquent that implements <code>PostRepositoryInterface</code>. This way, we're not restricting the API (and every other implementation) to Eloquent's interpretation; we can name the methods however we wish.</p>

<pre class="brush: php">
&lt;?php namespace Repositories;

# app/repositories/EloquentPostRepository.php

use Repositories\PostRepositoryInterface;
use Post;

class EloquentPostRepository implements PostRepositoryInterface {

public function all()
{
    return Post::all();
}

public function find($id)
{
    return Post::find($id);
}

public function create($input)
{
    return Post::create($input);
}

}</pre>

<blockquote>
<p>Some might argue that the <code>Post</code> model should be injected into this implementation for testability purposes. If you agree, simply inject it through the constructor, per usual.</p>
</blockquote>

<p>That's all it should take! Refresh the browser, and things should be back to normal. Only, now, your application is far better structured, and the controller is no longer linked to Eloquent.</p>

<p>Let's imagine that, a few months from now, your boss informs you that you need to swap Eloquent out with Redis. Well, because you've structured your application in this future-proof way, you only need to create the new <code>app/repositories/RedisPostRepository</code> implementation:</p>

<pre class="brush: php">
&lt;?php namespace Repositories;

# app/repositories/RedisPostRepository.php

use Repositories\PostRepositoryInterface;

class RedisPostRepository implements PostRepositoryInterface {

public function all()
{
    // return all with Redis
}

public function find($id)
{
    // return find one with Redis
}

public function create($input)
{
    // return create with Redis
}

}</pre>

<p>And update the binding:</p>

<pre class="brush: php">
# app/routes.php

App::bind(
  'Repositories\PostRepositoryInterface',
  'Repositories\RedisPostRepository'
);</pre>

<p>Instantly, you're now leveraging Redis in your controller. Notice how <code>app/controllers/PostsController.php</code> was never touched? That's the beauty of it!</p>

<h2>Structure</h2>

<p>So far in this lesson, our organization has been a bit lacking. IoC bindings in the <code>routes.php</code> file? All repositories grouped together in one directory? Sure, that may work in the beginning, but, very quickly, it'll become apparent that this doesn't scale.</p>

<p>In the final section of this article, we'll PSR-ify our code, and leverage service providers to register any applicable bindings.</p>

<blockquote>
<p>PSR-0 defines the mandatory requirements that must be adhered to for autoloader interoperability.</p>
</blockquote>

<p>A PSR-0 loader may be registered with Composer, via the <code>psr-0</code> object.</p>

<pre class="brush: js">
// composer.json

"autoload": {
  "psr-0": {
      "Way": "app/lib/"
  }
}</pre>

<p>The syntax can be confusing at first. It certainly was for me. An easy way to decipher <code>"Way": "app/lib/"</code> is to think to yourself, "<em>The base folder for the <code>Way</code> namespace is located in <code>app/lib</code>.</em>" Of course, replace my last name with the name of your project. The directory structure to match this would be:</p>

<ul>
<li>app/
<ul><li>lib/</li>
<li>Way/</li>
</ul></li>
</ul>

<p>Next, rather than grouping all repositories into a <code>repositories</code> directory, a more elegant approach might be to categorize them into multiple directories, like so:</p>

<ul><li>app/
<ul><li>lib/</li>
<li>Way/
<ul><li>Storage/</li>
<li>Post/
<ul><li>PostRepositoryInterface.php</li>
<li>EloquentPostRepository.php</li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<p>It's vital that we adhere to this naming and folder convention, if we want the autoloading to work as expected. The only remaining thing to do is update the namespaces for <code>PostRepositoryInterface</code> and <code>EloquentPostRepository</code>.</p>

<pre class="brush: php">
&lt;?php namespace Way\Storage\Post;

# app/lib/Way/Storage/Post/PostRepositoryInterface.php

interface PostRepositoryInterface {

  public function all();

  public function find($id);

  public function create($input);

}</pre>

<p>And for the implementation:</p>

<pre class="brush: php">
&lt;?php namespace Way\Storage\Post;

# app/lib/Way/Storage/Post/EloquentPostRepository.php

use Post;

class EloquentPostRepository implements PostRepositoryInterface {

  public function all()
  {
      return Post::all();
  }

  public function find($id)
  {
      return Post::find($id);
  }

  public function create($input)
  {
      return Post::create($input);
  }

}</pre>

<p>There we go; that's much cleaner. But what about those pesky bindings? The routes file may be a convenient place to experiment, but it makes little sense to store them there permanently. Instead, we'll use service providers.</p>

<blockquote>
<p>Service providers are nothing more than bootstrap classes that can be used to do anything you wish: register a binding, hook into an event, import a routes file, etc.</p>
</blockquote>

<p>A service provider's <code>register()</code> will be triggered automatically by Laravel.</p>

<pre class="brush: php">
&lt;?php namespace Way\Storage;

# app/lib/Way/Storage/StorageServiceProvider.php

use Illuminate\Support\ServiceProvider;

class StorageServiceProvider extends ServiceProvider {

  // Triggered automatically by Laravel
  public function register()
  {
      $this-&gt;app-&gt;bind(
          'Way\Storage\Post\PostRepositoryInterface',
          'Way\Storage\Post\EloquentPostRepository'
      );
  }

}</pre>

<p>To make this file known to Laravel, you only need to include it in <code>app/config/app.php</code>, within the <code>providers</code> array.</p>

<pre class="brush: php">
# app/config/app.php

'providers' =&gt; array(
  'Illuminate\Foundation\Providers\ArtisanServiceProvider',
  'Illuminate\Auth\AuthServiceProvider',
  // ...
  'Way\Storage\StorageServiceProvider'
)</pre>

<p>Good; now we have a dedicated file for registering new bindings.</p>

<h3>Updating the Tests</h3>

<p>With our new structure in place, rather than mocking the Eloquent model, itself, we can instead mock <code>PostRepositoryInterface</code>. Here's an example of one such test:</p>

<pre class="brush: php">
# app/tests/controllers/PostsControllerTest.php

public function testIndex()
{
  $mock = Mockery::mock('Way\Storage\Post\PostRepositoryInterface');
  $mock-&gt;shouldReceive('all')-&gt;once();

  $this-&gt;app-&gt;instance('Way\Storage\Post\PostRepositoryInterface', $mock);

  $this-&gt;call('GET', 'posts');

  $this-&gt;assertViewHas('posts');
}</pre>

<p>However, we can improve this. It stands to reason that every method within <code>PostsControllerTest</code> will require a mocked version of the repository. As such, it's better to extract some of this prep work into its own method, like so:</p>

<pre class="brush: php">
# app/tests/controllers/PostsControllerTest.php

public function setUp()
{
  parent::setUp();

  $this-&gt;mock('Way\Storage\Post\PostRepositoryInterface');
}

public function mock($class)
{
  $mock = Mockery::mock($class);

  $this-&gt;app-&gt;instance($class, $mock);

  return $mock;
}

public function testIndex()
{
  $this-&gt;mock-&gt;shouldReceive('all')-&gt;once();

  $this-&gt;call('GET', 'posts');

  $this-&gt;assertViewHas('posts');
}</pre>

<p>Not bad, ay?</p>

<p>Now, if you want to be super-fly, and are willing to add a touch of test logic to your production code, you could even perform your mocking within the Eloquent model! This would allow for:</p>

<pre class="brush: php">
Post::shouldReceive('all')-&gt;once();</pre>

<p>Behind the scenes, this would mock <code>PostRepositoryInterface</code>, and update the IoC binding. You can't get much more readable than that!</p>

<p>Allowing for this syntax only requires you to update the <code>Post</code> model, or, better, a <code>BaseModel</code> that all of the Eloquent models extend. Here's an example of the former:</p>

<pre class="brush: php">
&lt;?php

# app/models/Post.php

class Post extends Eloquent {

  public static function shouldReceive()
  {
      $class = get_called_class();
      $repo = "Way\\Storage\\{$class}\\{$class}RepositoryInterface";
      $mock = Mockery::mock($repo);

      App::instance($repo, $mock);

      return call_user_func_array([$mock, 'shouldReceive'], func_get_args());
  }

}</pre>

<p>If you can manage the inner "<em>Should I be embedding test logic into production code</em>" battle, you'll find that this allows for significantly more readable tests.</p>

<pre class="brush: php">
&lt;?php

# app/tests/controllers/PostsControllerTest.php

class PostsControllerTest extends TestCase {

  public function tearDown()
  {
      Mockery::close();
  }

  public function testIndex()
  {
      Post::shouldReceive('all')-&gt;once();

      $this-&gt;call('GET', 'posts');

      $this-&gt;assertViewHas('posts');
  }

  public function testStoreFails()
  {
      Input::replace($input = ['title' =&gt; '']);

      $this-&gt;call('POST', 'posts');

      $this-&gt;assertRedirectedToRoute('posts.create');
      $this-&gt;assertSessionHasErrors();
  }

  public function testStoreSuccess()
  {
      Input::replace($input = ['title' =&gt; 'Foo Title']);

      Post::shouldReceive('create')-&gt;once();

      $this-&gt;call('POST', 'posts');

      $this-&gt;assertRedirectedToRoute('posts.index', ['flash']);
  }

}</pre>

<p>It feels good, doesn't it? Hopefully, this article hasn't been too overwhelming. The key is to learn how to organize your repositories in such a way to make them as easy as possible to mock and inject into your controllers. As a result of that effort, your tests will be lightning fast!</p>

<blockquote>
<p>This article is an excerpt from book, <a href="https://leanpub.com/laravel-testing-decoded">Laravel Testing Decoded</a>.</p>
</blockquote>
