<h1>Os 30 Seletores CSS Que Você Deve Memorizar</h1>

<p>Então, você aprender os seletores básicos: <code>identificador</code>, <code>classe</code>, e <code>descendente</code> - e achou que tinha aprendido tudo? Se acha que sim, então você está deixando de aproveitar uma gama de possibilidades. Enquanto a maioria dos seletores mencionados nesse artigo fazem parte da especificação do CSS3, e são, consequentemente, disponíveis apenas em navegadores modernos, você saber todos eles de cabeça.</p>

<h2><span> 1. </span>*</h2>

<pre class="brush: css">
* {
 margin: 0;
 padding: 0;
}</pre>

<p>Vamos falar primeiro dos mais óbvios, para os iniciantes, antes de começarmos a falar dos seletores mais avançados.</p>

<p>O asterísco (ou estrela) tem como alvo todos os elementos em uma página. Muitos desenvolvedores usam-no para zerar as as margens e o preenchimento (<code>margin</code>e <code>padding</code>, respectivamente). Embora isso funcione para testes rápidos, recomendo o não uso dessa técnica em produção. Ela deixa o navegador muito <em>pesado</em> (por ter de selecionar todo e cada elemento), além de ser desnecessário.</p>

<p>O <code>*</code> também pode ser usado como um seletor filho. </p>

<pre class="brush: css">
#container * {
 border: 1px solid black;
}</pre>

<p>Isso mirará todo elemento que for filho de uma <code>div</code> com id <code>#container</code>. Novamente, não use muito essa técnica em produção. De preferência, nunca.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/star.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/star.html">Visualizar Demonstração </a></h5>

<h3> Compatibilidade </h3>
<ul><li>IE6+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 2. </span>#X</h2>

<pre class="brush: css">
#container {
 width: 960px;
 margin: auto;
}</pre>

<p>Prefixar um seletor com o "jogo da velha" (ou cerquilha, caso prefira), permite mirar algum elemento com algum <code>identificador</code>. Ele é um dos seletores mais usados, contudo, seja cuidadoso ao usar seletores com <code>identificador</code>.</p>

<blockquote>
<p>Faça-se a seguinte pergunta: Preciso, realmente, aplicar um <code>identificador</code> a esse elemento para poder selecioná-lo</p>
</blockquote>

<p>Seletores <code>identificador</code> são rígidos e não permitem reuso. Se possível, tente usar, primeiro, o nome da tag, um dos novos elementos do HTML5 ou uma pseudo-classe.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/id.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/id.html">Visualizar Demonstração </a> </h5>
<h3> Compatibilidade </h3>
<ul><li>IE6+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 3. </span>.X</h2>

<pre class="brush: css">
.error {
color: red;
}</pre>

<p>Esse é um seletor de <code>classe</code>. A diferença entre um <code>identificador</code> e uma <code>classe</code> é que, com a classe, você pode selecionar vários elementos. Use uma <code>classe</code> quando você precisar estilizar um grupo de elementos. Alternativamente, use um <code>identificador</code> quando precisar achar "uma agulha num palheiro", para estilizar um único elemento.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/class.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/class.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE6+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 4. </span>X Y</h2>

<pre class="brush: css">
li a {
text-decoration: none;
}</pre>

<p>O próximo seletor mais comum é o seletor de <code>descendência</code>.Quando precisar ser mais específico em seus seletores, use esse. Por exemplo, se, ao invés de mirar todas as tags de âncora (<code>a</code>), talvez você só precise selecionar aquelas que estão dentro de uma lista não ordenada? Esse seletor, o seletor descendente, é especificamente para isso. </p>

<blockquote>
<p><strong>Dica</strong> - Se seu seletor parecer com isso <code>X Y Z A B.error</code>, tem algo errado. Pergunte-se se, realmente, é necessário todo esse peso, toda essa <em>especificidade</em>.</p>
</blockquote>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/descend.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/descend.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE6+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 5. </span>X</h2>

<pre class="brush: css">
a { color: red; }
ul { margin-left: 0; }</pre>

<p>E se você quiser selecionar todos os elementos da página, de acordo com o <code>tipo</code> deles, ao ivés do seu <code>identificador</code> ou <code>classe</code>? Faça o simples e use um seletor de tipo. Se você precisar selecionar todas as listas não ordenadas, use <code>ul {}</code>.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/tagName.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/tagName.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE6+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 6. </span>X:visited e X:link</h2>

<pre class="brush: css">
a:link { color: red; }
a:visted { color: purple; }</pre>

<p>We use the <code>:link</code> pseudo-class to target all anchors tags which have yet to be clicked on.</p>

<p>Alternatively, we also have the <code>:visited</code> pseudo class, which, as you'd expected, allows us to apply specific styling to only the anchor tags on the page which <em>have</em> been clicked on, or <em>visited</em>.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/links.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/links.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE7+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span>7.</span> X + Y</h2>

<pre class="brush: css">
ul + p {
 color: red;
}</pre>

<p>Isso é referenciado como seletor adjacente. Ele selecionará <em>somente</em> o elemento imediatamente após o primeiro elemento. No exemplo acima, selecionará só o primeiro parágrado após cada <code>ul</code> na página, e fará que ele tenha a cor vermelha.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/adjacent.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/adjacent.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE7+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span>8.</span> X &gt; Y</h2>

<pre class="brush: css">
div#container &gt; ul {
border: 1px solid black;
}</pre>

<p>A diferença entre o seletor descendente <code>X Y</code> padrão e o seletor <code>X &gt; Y</code> é que o último somente seleciona filhos diretos. Por exemplo, considere o código HTML abaixo.</p>

<pre class="brush: html">
 &lt;div id="container"&gt;
    &lt;ul&gt;
       &lt;li&gt; Item da lista
         &lt;ul&gt;
            &lt;li&gt; Filho &lt;/li&gt;
         &lt;/ul&gt;
       &lt;/li&gt;
       &lt;li&gt; Item da lista &lt;/li&gt;
       &lt;li&gt; Item da lista &lt;/li&gt;
       &lt;li&gt; Item da lista &lt;/li&gt;
    &lt;/ul&gt;
 &lt;/div&gt;</pre>

<p>Um seletor <code>#container &gt; ul</code> somente selecionará aquelas <code>ul</code>s que são filhas diretas de uma <code>div</code> com <code>identificador</code> nomeado como <code>container</code>. Ele não selecionará, por exemplo, a <code>ul</code> que é filha do primeiro <code>li</code>. </p>

<p>Por esse motivo, há benefícios relacionados a performances ao usar o combinador de filhos. Na verdade, é recomendável utilizá-lo quando estiver trabalhando com motores de seleção de CSS criados em JavaScript.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/childcombinator.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/childcombinator.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE7+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 9.</span> X ~ Y</h2>

<pre class="brush: css">
ul ~ p {
 color: red;
}</pre>

<p>O seletor de irmão é parecido com o seletor <code>X + Y</code>, contudo, é menos restritivo. Enquanto o seletor adjacente (<code>ul + p</code>) só selecionará o primeiro elemento, imediatamente, após o elemento inicial, esse é mais generalista. Ele selecionará, usando o nosso exemplo acima, qualquer elemento <code>p</code>, desde que ele venha depois de um elemento <code>ul</code>. </p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/generalcombinator.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/generalcombinator.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE7+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 10.</span> X[title]</h2>

<pre class="brush: css">
a[title] {
 color: green;
}</pre>

<p>Chamado de <em>seletor de atributos</em>, no nosso exemplo acima, ele só selecionará aquelas âncoras com um atributo <code>title</code> attribute. As âncoras que não tiverem esse atributo, não receberão esse estilo em particular. Mas, e se precisarmos ser mais específicos? Bem...</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/attributes.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/attributes.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE7+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 11.</span> X[href="foo"]</h2>

<pre class="brush: css">
a[href="http://net.tutsplus.com"] {
color: #1f6053; /* nettuts green */
}</pre>

<p>O trecho acima estilizará todas as âncoras que apontem para o endereço <em>http://net.tutsplus.com</em>; eles serão estilizados com o nosso verde. Todas as outras âncoras não serão afetadas.</p>
<blockquote>

<p>Atente que estamos envolvendo o valor entre aspas. Lembre-se de fazer isso quando estiver trabalhando com motores de seleção CSS criados em JavaScript. Quando possível, sempre use os seletores CSS3 ao invés dos métodos não oficiais.</p>
</blockquote>

<p>Ele funciona muito bem, embora seja um tanto rígido. E se o link, realmente, direcionar para o Nettuts+, mas, o endereço usado seja o <em>nettuts.com</em> ao invés da URL completa? Para esses casos, podemos usar a sintaxe de expressões regulares.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/attributes2.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/attributes2.html">Visualizar Demonstração</a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE7+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 12.</span> X[href*="nettuts"]</h2>

<pre class="brush: css">
a[href*="tuts"] {
color: #1f6053; /* nettuts green */
}</pre>

<p>Aqui está; é isso o que precisamos. O asterísco designa que o valor utilizado no seletor deve aparecer em <em>algum lugar</em> do valor do atributo do elemento. Assim, esse novo seletor cobre <em>nettuts.com</em>, <em>net.tutsplus.com,</em> e até o <em>tutsplus.com</em>. </p>

<p>Tenha em mente que ele é bem abrangente. E se a âncora apontar para alguma site que não seja da Envato, mas que tenha em sua URL a cadeia de caracteres <em>tuts</em>? Quando precisar ser mais específico, use <code>^</code> e <code>&amp;</code>, para referenciar o começo e o fim de uma cadeia de caracteres, respectivamente.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/attributes3.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/attributes3.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE7+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 13. </span> X[href^="http"]</h2>

<pre class="brush: css">
a[href^="http"] {
 background: url(path/to/external/icon.png) no-repeat;
 padding-left: 10px;
}</pre>

<p>Você, alguma vez, já parou para pensar como alguns sites fazem para mostrar um pequeno ícone ao lado de alguns links que levam para outros sites? Tenho certeza que você já viu algo parecido antes; Eles são ótimos lembretes que o link em questão levará você para um site completamente diferente.</p>

<p>Isso é bem fácil de fazer, usando o ácento circunflexo. Ele é, comumente, usado em expressões regulares para designar o começo de uma cadeia de caracteres. Se quisermos selecionar todas as âncoras que tem um atributo <code>href</code> que começam com <code>http</code>, nós poderíamos usar um trecho de código parecido com o que temos acima.</p>

<blockquote>
<p>Atente que não estamos procurando por <code>http://</code>; isso é desnecessário e não leva em consideração as URLs que começam com <code>https://</code>. </p>
</blockquote>

<p>Agora, e se quiséssemos estilizar todos os links que apontam, digamos, para uma foto? Nesses casos, temos de pesquisar pelo <em>final</em> da cadeia de caracteres.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/attributes4.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/attributes4.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE7+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 14. </span>X[href$=".jpg"]</h2>

<pre class="brush: css">
a[href$=".jpg"] {
 color: red;
}</pre>

<p>Again, we use a regular expressions symbol, <code>$</code>, to refer to the end of a string. In this case, we're searching for all anchors which link to an image -- or at least a url that ends with <code>.jpg</code>. Keep in mind that this certainly won't work for <code>gifs</code> and <code>pngs</code>.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/attributes5.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/attributes5.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE7+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 15.</span> X[data-*="foo"]</h2>

<pre class="brush: css">
a[data-filetype="image"] {
 color: red;
}</pre>

<p>Lembre-se do exemplo oito; como fazer para referenciar todos os tipos de imagens: <code>png</code>, <code>jpeg,</code><code>jpg</code> e <code>gif</code>? Bem, poderíamos criar múltiplos seletores, dessa forma:</p>

<pre class="brush: css">
a[href$=".jpg"],
a[href$=".jpeg"],
a[href$=".png"],
a[href$=".gif"] {
 color: red;
}</pre>

<p>Mas, isso é muito chato e ineficiente. Outra possível solução é usar atributos customizados. E se adicionarmos um atributo <code>data-filetype</code> a cada uma das âncoras que apontem para uma imagem?</p>

<pre class="brush: html">
&lt;a href="path/to/image.jpg" data-filetype="image"&gt; Link para Imagem&lt;/a&gt;</pre>

<p>Então, com esse <em>gancho</em>, podemos usar os seletores de atributo padrão para selecionar somente essas âncoras. </p>

<pre class="brush: css">
a[data-filetype="image"] {
 color: red;
}</pre>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/attributes6.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/attributes6.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE7+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 16. </span>X[foo~="bar"]</h2>

<pre class="brush: css">
 a[data-info~="external"] {
 color: red;
}

a[data-info~="image"] {
 border: 1px solid black;
}</pre>

<p>Eis um seletor especial que impressionará seus amigos. Nem todo mundo sabe desse truque. O til (<code>~</code>) permite-nos selecionar um atributo que tem, em seus valores, uma lista separada por espaços. </p>

<p>Seguindo com o nosso atributo customizado do seletor quinze, poderíamos criar um atributo <code>data-info</code>, que pode receber uma lista de itens, separados por espaço, para podermos anotar o que quisermos. Nesse caso, nós tomaremos nota dos links externos e dos links para iamgens &ndash; só para exemplificar.</p>

<pre class="brush: html">
"&lt;a href="path/to/image.jpg" data-info="external image"&gt; Clique em mim &lt;/a&gt;</pre>

<p>Com esse código, agora podemos selecionar qualquer tag que tenha qualquer um desses valores, usando o truque do seletor de atributos com o ~.</p>

<pre class="brush: css">
/* Selecionar o atributo data-info que contem o valor "external" */
a[data-info~="external"] {
 color: red;
}

/* E aquele que contem o valor "image" */
a[data-info~="image"] {
border: 1px solid black;
}</pre>

<p>Pretty nifty, ay?</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/attributes7.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/attributes7.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE7+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 17.</span> X:checked</h2>

<pre class="brush: css">
input[type=radio]:checked {
 border: 1px solid black;
}</pre>

<p>Essa pseudo-classe somente selecionará o elemento da interface que foi marcado como selecionado &ndash; como um botão <code>radio</code> ou <code>checkbox</code>. Simples assim.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/checked.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/checked.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE9+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 18. </span>X:after</h2>

<p>As pseudo-classes <code>before</code> e <code>after</code> são muito boas. Parece que, todos os dias, o pessoal encontra maneiras criativas e efetivas de usá-las. Elas, simplesmente, geram conteúdo ao redor do elemento selecionado.</p>

<p>Vários aprenderam sobre eles quando foram encontrar o <em>hack</em> do ajuste dos <em>floats</em> (alguns conhecem como <em>clear-fix hack</em>).</p>

<pre class="brush: css">
.clearfix:after {
  content: "";
  display: block;
  clear: both;
  visibility: hidden;
  font-size: 0;
  height: 0;
  }

.clearfix {
 *display: inline-block;
 _height: 1%;
}</pre>

<p>Esse <em>hack</em> usa a pseudo-classe <code>:after</code> para adicionar um espaço após o elemento e, então, limpa-lo. É um ótimo truque para se ter em seu cinto de utilidades, principalmente quando a técnica do <code>overflow: hidden;</code> não é possível ser utilizada.</p>

<p>Para outros usos criativos dessa técnica, <a href="http://net.tutsplus.com/tutorials/html-css-techniques/quick-tip-getting-clever-with-css3-shadows/">veja meu guia rápido sobre como criar sombras</a>. </p>

<blockquote>
<p>De acordo com a especificação dos Seletores CSS3, você deveria, tecnicamente, usar a sintaxe dos pseudo-elementos de dois "dois pontos", <code>::</code>. Entretanto, para manter-se compatível, o navegador aceitar o uso com um único "dois pontos". Na verdade, é melhor você usar a versão com um único "dois pontos" em seus projetos.</p>
</blockquote>

<h3> Compatibilidade </h3>
<ul><li>IE8+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 19. </span>X:hover</h2>

<pre class="brush: css">
div:hover {
background: #e3e3e3;
}</pre>

<p>Vamos lá. Você já conhece esse. O termo oficial para esse seletor é <code>pseudo-classe de ação do usuário</code>. Pode parecer confuso, mas não é. Quer adicionar algum estilo específico ao passar o mouse sobre algum elemento? Esse seletor dará conta do recado!</p>

<blockquote>
<p>Tenha em mente que versões antigas do Inter Explorer não respondem quando a pseudo-classe <code>:hover</code> é aplicada a qualquer outra coisa que não seja uma âncora (<code>a</code>). </p>
</blockquote>

<p>Você, geralmente, selecionará esse seletor quando for aplicar, por exemplo, um <code>border-bottom</code> a âncoras quando passar o mouse sobre o link.</p>

<pre class="brush: css">
a:hover {
 border-bottom: 1px solid black;
}</pre>

<blockquote>
<p><strong>Dica</strong> - <code>border-bottom: 1px solid black;</code> é bem melhor que usar <code>text-decoration: underline;</code>. </p>
</blockquote>

<h3> Compatibilidade </h3>
<ul><li>IE6+ (In IE6, :hover must be applied to an anchor element) </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 20. </span> X:not(selector)</h2>

<pre class="brush: css">
div:not(#container) {
 color: blue;
}</pre>

<p>A pseudo-classe <code>negação</code> é, particularmente, útil. Digamos que você queira selecionar todas as divs, exceto por aquelas que contenham um <code>identificador</code> nomeado de <code>container</code>. O trecho acima lidar com essa tarefa, perfeitamente.</p>

<p>Ou, se eu quisess selecionar todos os elementos (o que não é recomendado), exceto pelas tags de parágrafo, poderíamos fazer assim:</p>

<pre class="brush: css">
*:not(p) {
color: green;
}</pre>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/not.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/not.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE9+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 21. </span> X::pseudoElemento</h2>

<pre class="brush: css">
p::first-line {
 font-weight: bold;
 font-size: 1.2em;
}</pre>

<p>Nós podemos usar pseudo-elementos (designados por <code>::</code>) para estilizar fragmentos de um elemento, como a primeira linha ou uma primeira letra. Lembre-se que essa regra precisa ser aplicada a elementos do tipo bloco para surtirem efeito.</p>

<blockquote>
<p>Um pseudo-elemento é compost por dois "dois pontos": <code>::</code></p>
</blockquote>

<h4>Selecione a Primeira Letra de um Paraágrafo</h4>

<pre class="brush: css">
p::first-letter {
 float: left;
 font-size: 2em;
 font-weight: bold;
 font-family: cursive;
 padding-right: 2px;
}</pre>

<p>Esse trecho encontrará os parágrafos de uma página e, então, buscará só a primeira letra de cada um desses elementos para aplicar o estilo. </p>

<p>Isso é, geralmente, usado para criar estilos que remotem à estilização que jornais aplicam à primeira letra de um artigo.</p>

<h4>Selecione a Primeira Letra de um Parágrafo</h4>

<pre class="brush: css">
p::first-line {
 font-weight: bold;
 font-size: 1.2em;
}</pre>

<p>De forma semelhante, o pseudo-elemento <code>::first-line</code> irá, como esperado, estilizar, somente, a primeira linha do elemento em questão. </p>

<blockquote>
<p>"Para manter a compatibilidade com as folhas de estilos existentes, os navegadores devem, também, aceitar a notação anterior, com um 'dois pontos', introduzida nas especificações CSS nível 1 e 2 (precisamente, :first-line, :first-letter, :before e :after). Essa compatibilidade não é permitida para os novos pseudo-elementos nesta especificação." - <a href="http://www.w3.org/TR/css3-selectors/">Fonte</a></p>
</blockquote>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/pseudoElements.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/pseudoElements.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE6+ </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 22. </span>X:nth-child(n)</h2>

<pre class="brush: css">
li:nth-child(3) {
 color: red;
}</pre>

<p>Você se lembra quando tinha de especificar um elemento específico de um conjunto de elementos? a pseudo-classe <code>nth-child</code> acaba com esse problema!</p>

<p>Atente que o <code>nth-child</code> aceita um inteiro como parâmetro, entretanto, a contagem não inicia em zero (como nas <code>arrays</code> e <code>strings</code> em programação). Se você deseja selecionar o segundo item de uma lista, faça assim <code>li:nth-child(2)</code>. </p>

<p>Nós podemos, até mesmo, selecionar um número variáve de elementos filhos. Por exemplo, nós podemos fazer algo como <code>li:nth-child(4n)</code>, para selecionar todos os itens que estejam em uma posição que seja múltipla de quatro. </p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/nth.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/nth.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE9+ </li>
<li>Firefox 3.5+ </li>
<li>Chrome </li>
<li>Safari </li>
</ul>

<h2><span> 23. </span>X:nth-last-child(n)</h2>

<pre class="brush: css">
li:nth-last-child(2) {
 color: red;
}</pre>

<p>E se tivéssemos uma enorme lista de itens em uma <code>ul</code> e só precisássemos acessar o terceiro item, começando a contagem a partir do último elemento? Ao invés de fazer algo como <code>li:nth-child(397)</code>, você pode usar a pseudo-classe <code>nth-last-child</code>.</p>

<p>Essa técnica funciona quase igual à técnica dezesseis, acima, entretanto, a diferença é que ela começa do último elemento do conjunto e faz o caminho inverso até o primeiro elemento.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/nthLast.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/nthLast.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE9+ </li>
<li>Firefox 3.5+ </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 24. </span>X:nth-of-type(n)</h2>

<pre class="brush: css">
ul:nth-of-type(3) {
 border: 1px solid black;
}</pre>

<p>Haverá vezes que, ao invés de selecionar um elemento <code>filho</code>, você precisará um certo elemento de um certo <code>tipo</code>. </p>

<p>Imagine um código que contenha cinco listas não ordenadas. Se você quiser estilizar, somente, a terceira <code>ul</code> e não tem um <code>identificador</code> para usar, você pode usar a pseudo-classe <code>nth-of-type(n)</code>. No trecho acima, somente a terceira  <code>ul</code> terá uma borda.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/nthOfType.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/nthOfType.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE9+ </li>
<li>Firefox 3.5+ </li>
<li>Chrome </li>
<li>Safari </li>
</ul>

<h2><span> 25. </span>X:nth-last-of-type(n)</h2>

<pre class="brush: css">
ul:nth-last-of-type(3) {
 border: 1px solid black;
}</pre>

<p>E, sim, para manter a consistência, nós também podemos usar a pseudo classe <code>nth-last-of-type</code> para iniciar a contagem dos seletores pelo fim da lista, e fazer o caminho inverso até o elemento desejado.</p>

<h3> Compatibilidade </h3>
<ul><li>IE9+ </li>
<li>Firefox 3.5+ </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 26. </span>X:first-child</h2>

<pre class="brush: css">
ul li:first-child {
 border-top: none;
}</pre>

<p>Essa pseudo-classe estrutural permite-nos selecionar o primeiro elemento do conjunto alvo. Você, geralmente, usará essa técnica para remover bordas dos primeiros e últimos elementos de listas. </p>

<p>Por exemplo, digamos que você tem uma lista e cada item dessa lista tem <code>border-top</code> e <code>border-bottom</code>. Bem, com esse arranjo, o primeiro e último elementos parecerão um pouco estranhos. </p>

<p>Muitos projetistas aplicam classes chamadas <code>primeira</code> e <code>última</code> para compensar isso. Para evitar isso, você pode usar essa pseudo-classe.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/firstChild.html" data-original-url="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/firstChild.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE7+  </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 27. </span>X:last-child</h2>

<pre class="brush: css">
ul &gt; li:last-child {
 color: green;
}</pre>

<p>O seletor oposto ao <code>first-child</code>, o  <code>last-child</code>, selecionará o último item do conjunto alvo.</p>

<h3>Exemplo</h3>
<p>Vamos construir um exemplo simples para demonstrar um dos possíveis usos da dessas pseudo-classes. Criaremos uma lista estilizada. </p>

<h4>Markup</h4>
<pre class="brush: html">
&lt;ul&gt;
   &lt;li&gt; Item da Lista &lt;/li&gt;
   &lt;li&gt; Item da Lista &lt;/li&gt;
   &lt;li&gt; Item da Lista &lt;/li&gt;
&lt;/ul&gt;</pre>

<p>Nada especial, aqui. Só uma lista simples.</p>

<h4>CSS</h4>
<pre class="brush: css">
ul {
 width: 200px;
 background: #292929;
 color: white;
 list-style: none;
 padding-left: 0;
}

li {
 padding: 10px;
 border-bottom: 1px solid black;
 border-top: 1px solid #3c3c3c;
}</pre>

<p>Esse estilo trabalhará o plano de fundo (<code>background</code>), removerá o preenchimento padrão (<code>padding</code>) que o navegador atribui à <code>ul</code> e aplica as bordas a cada elemento <code>li</code> para criar um ar de profundidade.</p>

<figure>
<img src="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/extraBorders.png" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/extraBorders.png" alt="Styled List" /></figure>

<blockquote>
<p>Para criar um ar de profundidade às suas listas, aplique uma cor à <code>border-bottom</code> a cada <code>li</code> que seja um ou dois tons <em>mais escuros</em> que a cor do plano de fundo do <code>li</code>. Depois, aplique uma cor à <code>border-top</code> que seja um ou dois tons <em>mais claros</em>. </p>
</blockquote>

<p>O único problema, como mostrado na imagem acima, é que uma borda será aplicada à parte de cima e à parte de baixo da lista desordenada &ndash; o que é estranho. Vamos usar as pseudo-classes <code>:first-child</code> e <code>:last-child</code> para ajustar isso.</p>

<pre class="brush: css">
li:first-child {
  border-top: none;
}

li:last-child {
 border-bottom: none;
}</pre>

<figure>
<img src="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/fixed.png" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/fixed.png" alt="Fixed" /></figure>
<p>E é isso. Resolvemos!</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/firstChild.html" data-original-url="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/firstChild.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE9+  </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<p><em>SIM &ndash; o IE8 dá suporte ao <code>:first-child</code>, mas não ao <code>:last-child</code>. Vai entender. </em> </p>

<h2><span> 28. </span>X:only-child</h2>

<pre class="brush: css">
div p:only-child {
 color: red;
}</pre>

<p>Francamente, você, provavelmente, não usará muito a pseudo-classe <code>only-child</code>. De qualquer modo, ele existe para o caso de você precisar.</p>

<p>Ela permite que você selecione aqueles elementos que são os <em>únicos</em> filhos de um certo elemento. Levando em consideração o trecho acima, somente o parágrafo que for o único filho de uma <code>div</code> ficará colorido de vermelho.</p>

<p>Vamos assumir que seja esse o nosso HTML.</p>

<pre class="brush: html">
&lt;div&gt;&lt;p&gt; Meu parágrafo aqui. &lt;/p&gt;&lt;/div&gt;

&lt;div&gt;
 &lt;p&gt; Dois parágrafos no total. &lt;/p&gt;
 &lt;p&gt; Dois parágrafos no total. &lt;/p&gt;
&lt;/div&gt;</pre>

<p>Nesse caso, os parágrafos da segunda <code>div</code> não serão afetados; somente os da primeira <code>div</code>. Assim que você inserir mais de um elemento filho nessa <code>div</code>, a pseudo-classe <code>only-child</code> deixará de funcionar.</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/onlyChild.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/onlyChild.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE9+  </li>
<li>Firefox </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 29. </span>X:only-of-type</h2>

<pre class="brush: css">
li:only-of-type {
 font-weight: bold;
}</pre>

<p>Essa pseudo-classe estrutural pode ser usada de algumas formas bem interessantes. Ela selecionará elementos que não tem nenhum elemento irmão dentro do elemento pai. Como exemplo, selecionemos todas as <code>ul</code>s que tem somente um único <code>li</code>. </p>

<p>Primeiro, pergunte-se como você resolveria isso. Você poderia usar o <code>ul li</code>, mas, ele selecionaria <em>todos</em> os itens da lista. A única solução é usar a pseudo-classe <code>only-of-type</code>.</p>

<pre class="brush: css">
ul &gt; li:only-of-type {
 font-weight: bold;
}</pre>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/onlyOfType.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/onlyOfType.html">Visualizar Demonstração </a> </h5>

<h3> Compatibilidade </h3>
<ul><li>IE9+  </li>
<li>Firefox 3.5+ </li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2><span> 30. </span>X:first-of-type</h2>

<p>A pseudo-classe <code>first-of-type</code> permite que você selecione o primeiro irmão de um conjunto de elementos do mesmo tipo. </p>

<h4>Um Teste</h4>
<p>Para entender melhor, façamos um teste. Copie o código abaixo em seu editor de códigos:</p>

<pre class="brush: html">
&lt;div&gt;
 &lt;p&gt; Meu parágrafo aqui. &lt;/p&gt;
 &lt;ul&gt;
    &lt;li&gt; Item 1 da Lista &lt;/li&gt;
    &lt;li&gt; Item 2 da Lista &lt;/li&gt;
 &lt;/ul&gt;

 &lt;ul&gt;
    &lt;li&gt; Item 3 da Lista &lt;/li&gt;
    &lt;li&gt; Item 4 da Lista &lt;/li&gt;
 &lt;/ul&gt;
&lt;/div&gt;</pre>

<p>Agora, sem continuar lendo, descubra como selecionar somente o <em>"Item 2 da Lista"</em>. Quando descobrir (ou desistir), continue a leitura.</p>

<h4>Solução 1</h4>
<p>Há várias maneira de resolver esse teste. Nós usaremos alguns deles. Primeiro, usando o <code>first-of-type</code>. </p>

<pre class="brush: css">
ul:first-of-type &gt; li:nth-child(2) {
 font-weight: bold;
}</pre>

<p>Esse trecho de código, essencialmente, diz "encontre a primeira lista não ordenada na página, então encontre somente os filhos imediatos dessa lista e que são "itens de lista". Depois, filtre esses itens e pegue somente o segundo.</p>

<h4>Solução 2</h4>
<p>Outra opção seria usar o seletor adjacente.</p>

<pre class="brush: css">
p + ul li:last-child {
 font-weight: bold;
}</pre>

<p>Nesse cenário, nós encontramos a <code>ul</code> que está, imediatamente, após um <code>p</code>, e, então, encontramos o último item desse elemento.</p>

<h4>Solução 3</h4>
<p>Nós podemos ser bem desagradáveis ou brincalhões o quanto quisermos com esses seletores. </p>

<pre class="brush: css">
ul:first-of-type li:nth-last-child(1) {
 font-weight: bold;
}</pre>

<p>Dessa vez, nós pegamos o primeiro elemento <code>ul</code> da página e, então, encontramos o primeiro item da lista, na ordem reversa dos itens! :)</p>

<h5> <a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/firstOfType.html" data-original-url="http://nettuts.s3.amazonaws.com/840_cssSelectors/selectors/firstOfType.html">Visualizar Demonstração </a> </h5>
<h3> Compatibilidade </h3>
<ul><li>IE9+  </li>
<li>Firefox 3.5+</li>
<li>Chrome </li>
<li>Safari </li>
<li>Opera </li>
</ul>

<h2>Conclusão </h2>

<p>Se você tem de lidar com navegadores antigos, como o Internet Explorer 6, você ainda tem de tomar cuidado com esses novos seletores. Porém, não deixe isso deter seu aprendizado. Você estaria fazendo um disserviço a você mesmo. Tenha certeza <a href="http://www.quirksmode.org/css/contents.html">de visualizar a lista de compatibilidade com os navegadores.</a> Alternativamente, você pode usar <a href="http://code.google.com/p/ie7-js/">O excelente script IE9.js do Dean Edward</a>, para permitir que esses seletores sejam usados em navegadores.  </p>

<p>Segundo, quando for trabalhar com bibliotecas, como a popularlike jQuery, sempre usar os seletores nativos do CSS3 ao invés dos métodos/seletores customizados da biblioteca, sempre que possível. Isso <a href="http://jsperf.com/jquery-css3-not-vs-not">fará seu código mais performático</a>, uma vez que o motor de seleção poderão usar o analisador nativo do padrão, ao invés do seu próprio. </p>

<p>Obrigado por ler! Espero que tenha aprendido uma ou dois truques!</p>
